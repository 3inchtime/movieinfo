# 04-日志系统

## 目标说明

本步骤的目标是构建一个完整的日志系统，为 MovieInfo 项目提供统一的日志记录和管理能力：
- 设计统一的日志格式和级别体系
- 实现结构化日志记录
- 支持多种日志输出方式（控制台、文件、远程）
- 集成日志轮转和归档功能
- 实现日志性能优化和异步写入
- 提供日志分析和监控接口
- 支持分布式链路追踪

完成本步骤后，将拥有一套完整的日志系统，为后续的服务开发和运维监控提供强大的日志支持。

## 前置条件

- 已完成项目初始化（01-项目初始化.md）
- 已完成数据库设计（02-数据库设计.md）
- 已完成配置管理系统（03-配置管理系统.md）
- 熟悉 Go 语言的接口和并发编程
- 了解结构化日志的概念和最佳实践
- 理解日志级别和日志轮转的原理

## 技术要点

### 日志系统设计原则
- **结构化记录**：使用结构化格式（JSON）便于解析和分析
- **分级管理**：支持多种日志级别，便于过滤和查看
- **性能优化**：异步写入，避免阻塞主业务逻辑
- **可扩展性**：支持多种输出方式和自定义格式化器

### 技术选型
- **日志库**：使用 logrus 作为基础日志库
- **日志轮转**：使用 lumberjack 实现日志文件轮转
- **链路追踪**：集成 OpenTelemetry 进行分布式追踪
- **性能监控**：集成 Prometheus 指标收集

### 日志级别设计
- **TRACE**：最详细的调试信息
- **DEBUG**：调试信息，开发环境使用
- **INFO**：一般信息，记录重要的业务流程
- **WARN**：警告信息，需要注意但不影响运行
- **ERROR**：错误信息，需要立即处理
- **FATAL**：致命错误，导致程序退出

## 实现步骤

### 步骤1：设计日志接口和结构

#### 1.1 创建日志接口定义

```go
// pkg/logger/interface.go
package logger

import (
	"context"
	"io"
)

// Level 日志级别
type Level int

const (
	TraceLevel Level = iota
	DebugLevel
	InfoLevel
	WarnLevel
	ErrorLevel
	FatalLevel
)

// String 返回日志级别的字符串表示
func (l Level) String() string {
	switch l {
	case TraceLevel:
		return "TRACE"
	case DebugLevel:
		return "DEBUG"
	case InfoLevel:
		return "INFO"
	case WarnLevel:
		return "WARN"
	case ErrorLevel:
		return "ERROR"
	case FatalLevel:
		return "FATAL"
	default:
		return "UNKNOWN"
	}
}

// ParseLevel 解析日志级别字符串
func ParseLevel(level string) Level {
	switch level {
	case "trace", "TRACE":
		return TraceLevel
	case "debug", "DEBUG":
		return DebugLevel
	case "info", "INFO":
		return InfoLevel
	case "warn", "WARN", "warning", "WARNING":
		return WarnLevel
	case "error", "ERROR":
		return ErrorLevel
	case "fatal", "FATAL":
		return FatalLevel
	default:
		return InfoLevel
	}
}

// Fields 日志字段类型
type Fields map[string]interface{}

// Logger 日志接口
type Logger interface {
	// 基础日志方法
	Trace(msg string)
	Debug(msg string)
	Info(msg string)
	Warn(msg string)
	Error(msg string)
	Fatal(msg string)

	// 格式化日志方法
	Tracef(format string, args ...interface{})
	Debugf(format string, args ...interface{})
	Infof(format string, args ...interface{})
	Warnf(format string, args ...interface{})
	Errorf(format string, args ...interface{})
	Fatalf(format string, args ...interface{})

	// 带字段的日志方法
	WithFields(fields Fields) Logger
	WithField(key string, value interface{}) Logger
	WithError(err error) Logger
	WithContext(ctx context.Context) Logger

	// 配置方法
	SetLevel(level Level)
	GetLevel() Level
	SetOutput(output io.Writer)
	SetFormatter(formatter Formatter)

	// 生命周期方法
	Flush() error
	Close() error
}

// Formatter 日志格式化器接口
type Formatter interface {
	Format(entry *Entry) ([]byte, error)
}

// Entry 日志条目
type Entry struct {
	Level     Level                  `json:"level"`
	Time      int64                  `json:"timestamp"`
	Message   string                 `json:"message"`
	Fields    map[string]interface{} `json:"fields,omitempty"`
	Caller    *Caller                `json:"caller,omitempty"`
	TraceID   string                 `json:"trace_id,omitempty"`
	SpanID    string                 `json:"span_id,omitempty"`
	RequestID string                 `json:"request_id,omitempty"`
}

// Caller 调用者信息
type Caller struct {
	File     string `json:"file"`
	Line     int    `json:"line"`
	Function string `json:"function"`
}

// Hook 日志钩子接口
type Hook interface {
	Levels() []Level
	Fire(entry *Entry) error
}
```

#### 1.2 创建日志配置结构

```go
// pkg/logger/config.go
package logger

import (
	"time"
)

// Config 日志配置
type Config struct {
	// 基础配置
	Level      string `yaml:"level" validate:"required,oneof=trace debug info warn error fatal"`
	Format     string `yaml:"format" validate:"required,oneof=json text"`
	Output     string `yaml:"output" validate:"required,oneof=stdout stderr file"`
	TimeFormat string `yaml:"time_format"`

	// 文件输出配置
	File FileConfig `yaml:"file"`

	// 性能配置
	Async      bool          `yaml:"async"`
	BufferSize int           `yaml:"buffer_size"`
	FlushTime  time.Duration `yaml:"flush_time"`

	// 功能配置
	EnableCaller    bool `yaml:"enable_caller"`
	EnableTrace     bool `yaml:"enable_trace"`
	EnableRequestID bool `yaml:"enable_request_id"`

	// 采样配置
	Sampling SamplingConfig `yaml:"sampling"`

	// 钩子配置
	Hooks HooksConfig `yaml:"hooks"`
}

// FileConfig 文件输出配置
type FileConfig struct {
	Path       string `yaml:"path" validate:"required"`
	MaxSize    int    `yaml:"max_size" validate:"min=1"`     // MB
	MaxBackups int    `yaml:"max_backups" validate:"min=0"`  // 保留文件数
	MaxAge     int    `yaml:"max_age" validate:"min=1"`      // 天数
	Compress   bool   `yaml:"compress"`                      // 是否压缩
	LocalTime  bool   `yaml:"local_time"`                    // 使用本地时间
}

// SamplingConfig 采样配置
type SamplingConfig struct {
	Enabled    bool    `yaml:"enabled"`
	Rate       float64 `yaml:"rate" validate:"min=0,max=1"`       // 采样率
	Threshold  int     `yaml:"threshold" validate:"min=0"`        // 阈值
	Tick       int     `yaml:"tick" validate:"min=1"`             // 时间窗口（秒）
	First      int     `yaml:"first" validate:"min=0"`            // 窗口内前N条必记录
	Thereafter int     `yaml:"thereafter" validate:"min=0"`       // 之后每N条记录1条
}

// HooksConfig 钩子配置
type HooksConfig struct {
	Slack      SlackHookConfig      `yaml:"slack"`
	Webhook    WebhookHookConfig    `yaml:"webhook"`
	Prometheus PrometheusHookConfig `yaml:"prometheus"`
}

// SlackHookConfig Slack钩子配置
type SlackHookConfig struct {
	Enabled   bool     `yaml:"enabled"`
	WebhookURL string  `yaml:"webhook_url"`
	Channel   string   `yaml:"channel"`
	Username  string   `yaml:"username"`
	Levels    []string `yaml:"levels"`
}

// WebhookHookConfig Webhook钩子配置
type WebhookHookConfig struct {
	Enabled bool     `yaml:"enabled"`
	URL     string   `yaml:"url"`
	Timeout int      `yaml:"timeout"` // 秒
	Levels  []string `yaml:"levels"`
}

// PrometheusHookConfig Prometheus钩子配置
type PrometheusHookConfig struct {
	Enabled   bool     `yaml:"enabled"`
	Namespace string   `yaml:"namespace"`
	Subsystem string   `yaml:"subsystem"`
	Levels    []string `yaml:"levels"`
}

// DefaultConfig 返回默认配置
func DefaultConfig() *Config {
	return &Config{
		Level:      "info",
		Format:     "json",
		Output:     "stdout",
		TimeFormat: time.RFC3339,
		File: FileConfig{
			Path:       "logs/app.log",
			MaxSize:    100,
			MaxBackups: 10,
			MaxAge:     30,
			Compress:   true,
			LocalTime:  true,
		},
		Async:           true,
		BufferSize:      1000,
		FlushTime:       time.Second,
		EnableCaller:    true,
		EnableTrace:     true,
		EnableRequestID: true,
		Sampling: SamplingConfig{
			Enabled:    false,
			Rate:       1.0,
			Threshold:  100,
			Tick:       1,
			First:      10,
			Thereafter: 100,
		},
	}
}
```

### 步骤2：实现日志格式化器

#### 2.1 创建JSON格式化器

```go
// pkg/logger/formatter.go
package logger

import (
	"encoding/json"
	"fmt"
	"time"
)

// JSONFormatter JSON格式化器
type JSONFormatter struct {
	TimeFormat    string
	PrettyPrint   bool
	DisableColors bool
}

// Format 格式化日志条目
func (f *JSONFormatter) Format(entry *Entry) ([]byte, error) {
	// 创建输出映射
	data := make(map[string]interface{})

	// 基础字段
	data["level"] = entry.Level.String()
	data["message"] = entry.Message

	// 时间字段
	timeFormat := f.TimeFormat
	if timeFormat == "" {
		timeFormat = time.RFC3339
	}
	data["timestamp"] = time.Unix(0, entry.Time).Format(timeFormat)

	// 添加自定义字段
	for k, v := range entry.Fields {
		data[k] = v
	}

	// 调用者信息
	if entry.Caller != nil {
		data["caller"] = map[string]interface{}{
			"file":     entry.Caller.File,
			"line":     entry.Caller.Line,
			"function": entry.Caller.Function,
		}
	}

	// 链路追踪信息
	if entry.TraceID != "" {
		data["trace_id"] = entry.TraceID
	}
	if entry.SpanID != "" {
		data["span_id"] = entry.SpanID
	}
	if entry.RequestID != "" {
		data["request_id"] = entry.RequestID
	}

	// 序列化
	var bytes []byte
	var err error

	if f.PrettyPrint {
		bytes, err = json.MarshalIndent(data, "", "  ")
	} else {
		bytes, err = json.Marshal(data)
	}

	if err != nil {
		return nil, fmt.Errorf("failed to marshal log entry: %w", err)
	}

	// 添加换行符
	bytes = append(bytes, '\n')
	return bytes, nil
}

// TextFormatter 文本格式化器
type TextFormatter struct {
	TimeFormat     string
	EnableColors   bool
	FullTimestamp  bool
	DisableSorting bool
}

// Format 格式化日志条目
func (f *TextFormatter) Format(entry *Entry) ([]byte, error) {
	// 时间格式
	timeFormat := f.TimeFormat
	if timeFormat == "" {
		if f.FullTimestamp {
			timeFormat = time.RFC3339
		} else {
			timeFormat = "15:04:05"
		}
	}

	// 格式化时间
	timestamp := time.Unix(0, entry.Time).Format(timeFormat)

	// 级别颜色
	levelText := entry.Level.String()
	if f.EnableColors {
		levelText = f.colorizeLevel(entry.Level)
	}

	// 构建基础消息
	msg := fmt.Sprintf("%s [%s] %s", timestamp, levelText, entry.Message)

	// 添加字段
	if len(entry.Fields) > 0 {
		msg += " |"
		for k, v := range entry.Fields {
			msg += fmt.Sprintf(" %s=%v", k, v)
		}
	}

	// 添加调用者信息
	if entry.Caller != nil {
		msg += fmt.Sprintf(" | caller=%s:%d", entry.Caller.File, entry.Caller.Line)
	}

	// 添加追踪信息
	if entry.TraceID != "" {
		msg += fmt.Sprintf(" | trace_id=%s", entry.TraceID)
	}
	if entry.RequestID != "" {
		msg += fmt.Sprintf(" | request_id=%s", entry.RequestID)
	}

	msg += "\n"
	return []byte(msg), nil
}

// colorizeLevel 为日志级别添加颜色
func (f *TextFormatter) colorizeLevel(level Level) string {
	switch level {
	case TraceLevel:
		return "\033[37mTRACE\033[0m" // 白色
	case DebugLevel:
		return "\033[36mDEBUG\033[0m" // 青色
	case InfoLevel:
		return "\033[32mINFO\033[0m"  // 绿色
	case WarnLevel:
		return "\033[33mWARN\033[0m"  // 黄色
	case ErrorLevel:
		return "\033[31mERROR\033[0m" // 红色
	case FatalLevel:
		return "\033[35mFATAL\033[0m" // 紫色
	default:
		return level.String()
	}
}
```

### 步骤3：实现核心日志器

#### 3.1 创建日志器实现

```go
// pkg/logger/logger.go
package logger

import (
	"context"
	"fmt"
	"io"
	"os"
	"runtime"
	"strings"
	"sync"
	"time"

	"go.opentelemetry.io/otel/trace"
)

// StandardLogger 标准日志器实现
type StandardLogger struct {
	mu        sync.RWMutex
	level     Level
	output    io.Writer
	formatter Formatter
	hooks     []Hook
	config    *Config

	// 异步写入
	async      bool
	buffer     chan *Entry
	flushTimer *time.Timer
	wg         sync.WaitGroup
	closed     bool

	// 采样器
	sampler *Sampler

	// 上下文字段
	fields Fields
}

// NewLogger 创建新的日志器
func NewLogger(config *Config) (*StandardLogger, error) {
	logger := &StandardLogger{
		level:  ParseLevel(config.Level),
		config: config,
		fields: make(Fields),
	}

	// 设置输出
	if err := logger.setOutput(config.Output, config.File); err != nil {
		return nil, fmt.Errorf("failed to set output: %w", err)
	}

	// 设置格式化器
	logger.setFormatter(config.Format)

	// 设置采样器
	if config.Sampling.Enabled {
		logger.sampler = NewSampler(&config.Sampling)
	}

	// 设置异步写入
	if config.Async {
		logger.setupAsync(config.BufferSize, config.FlushTime)
	}

	// 设置钩子
	logger.setupHooks(config.Hooks)

	return logger, nil
}

// setOutput 设置输出
func (l *StandardLogger) setOutput(output string, fileConfig FileConfig) error {
	switch output {
	case "stdout":
		l.output = os.Stdout
	case "stderr":
		l.output = os.Stderr
	case "file":
		writer, err := NewRotatingFileWriter(&fileConfig)
		if err != nil {
			return fmt.Errorf("failed to create file writer: %w", err)
		}
		l.output = writer
	default:
		return fmt.Errorf("unsupported output type: %s", output)
	}
	return nil
}

// setFormatter 设置格式化器
func (l *StandardLogger) setFormatter(format string) {
	switch format {
	case "json":
		l.formatter = &JSONFormatter{
			TimeFormat: l.config.TimeFormat,
		}
	case "text":
		l.formatter = &TextFormatter{
			TimeFormat:    l.config.TimeFormat,
			EnableColors:  l.output == os.Stdout || l.output == os.Stderr,
			FullTimestamp: true,
		}
	default:
		l.formatter = &JSONFormatter{}
	}
}

// setupAsync 设置异步写入
func (l *StandardLogger) setupAsync(bufferSize int, flushTime time.Duration) {
	l.async = true
	l.buffer = make(chan *Entry, bufferSize)
	l.flushTimer = time.NewTimer(flushTime)

	// 启动异步写入协程
	l.wg.Add(1)
	go l.asyncWriter(flushTime)
}

// setupHooks 设置钩子
func (l *StandardLogger) setupHooks(config HooksConfig) {
	// Prometheus钩子
	if config.Prometheus.Enabled {
		hook := NewPrometheusHook(&config.Prometheus)
		l.AddHook(hook)
	}

	// Slack钩子
	if config.Slack.Enabled {
		hook := NewSlackHook(&config.Slack)
		l.AddHook(hook)
	}

	// Webhook钩子
	if config.Webhook.Enabled {
		hook := NewWebhookHook(&config.Webhook)
		l.AddHook(hook)
	}
}

// asyncWriter 异步写入协程
func (l *StandardLogger) asyncWriter(flushTime time.Duration) {
	defer l.wg.Done()

	batch := make([]*Entry, 0, 100)
	ticker := time.NewTicker(flushTime)
	defer ticker.Stop()

	for {
		select {
		case entry, ok := <-l.buffer:
			if !ok {
				// 通道关闭，写入剩余日志
				l.writeBatch(batch)
				return
			}
			batch = append(batch, entry)
			
			// 批量写入
			if len(batch) >= 100 {
				l.writeBatch(batch)
				batch = batch[:0]
			}

		case <-ticker.C:
			// 定时写入
			if len(batch) > 0 {
				l.writeBatch(batch)
				batch = batch[:0]
			}
		}
	}
}

// writeBatch 批量写入日志
func (l *StandardLogger) writeBatch(entries []*Entry) {
	for _, entry := range entries {
		l.writeEntry(entry)
	}
}

// writeEntry 写入单条日志
func (l *StandardLogger) writeEntry(entry *Entry) {
	// 格式化日志
	data, err := l.formatter.Format(entry)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to format log entry: %v\n", err)
		return
	}

	// 写入输出
	l.mu.RLock()
	output := l.output
	l.mu.RUnlock()

	if _, err := output.Write(data); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to write log entry: %v\n", err)
	}

	// 执行钩子
	for _, hook := range l.hooks {
		if l.shouldFireHook(hook, entry.Level) {
			if err := hook.Fire(entry); err != nil {
				fmt.Fprintf(os.Stderr, "Hook failed: %v\n", err)
			}
		}
	}
}

// shouldFireHook 判断是否应该触发钩子
func (l *StandardLogger) shouldFireHook(hook Hook, level Level) bool {
	levels := hook.Levels()
	for _, l := range levels {
		if l == level {
			return true
		}
	}
	return false
}

// log 记录日志
func (l *StandardLogger) log(level Level, msg string) {
	// 检查日志级别
	if level < l.level {
		return
	}

	// 采样检查
	if l.sampler != nil && !l.sampler.Sample(level) {
		return
	}

	// 创建日志条目
	entry := &Entry{
		Level:   level,
		Time:    time.Now().UnixNano(),
		Message: msg,
		Fields:  make(map[string]interface{}),
	}

	// 复制字段
	for k, v := range l.fields {
		entry.Fields[k] = v
	}

	// 添加调用者信息
	if l.config.EnableCaller {
		entry.Caller = l.getCaller()
	}

	// 添加追踪信息
	if l.config.EnableTrace {
		l.addTraceInfo(entry)
	}

	// 写入日志
	if l.async {
		select {
		case l.buffer <- entry:
		default:
			// 缓冲区满，直接写入
			l.writeEntry(entry)
		}
	} else {
		l.writeEntry(entry)
	}
}

// getCaller 获取调用者信息
func (l *StandardLogger) getCaller() *Caller {
	// 跳过日志库的调用栈
	pc, file, line, ok := runtime.Caller(4)
	if !ok {
		return nil
	}

	// 获取函数名
	func_name := "unknown"
	if fn := runtime.FuncForPC(pc); fn != nil {
		func_name = fn.Name()
		// 简化函数名
		if idx := strings.LastIndex(func_name, "/"); idx != -1 {
			func_name = func_name[idx+1:]
		}
	}

	// 简化文件路径
	if idx := strings.LastIndex(file, "/"); idx != -1 {
		file = file[idx+1:]
	}

	return &Caller{
		File:     file,
		Line:     line,
		Function: func_name,
	}
}

// addTraceInfo 添加追踪信息
func (l *StandardLogger) addTraceInfo(entry *Entry) {
	// 这里可以集成 OpenTelemetry 或其他追踪系统
	// 暂时留空，后续实现
}

// 实现Logger接口的方法
func (l *StandardLogger) Trace(msg string) { l.log(TraceLevel, msg) }
func (l *StandardLogger) Debug(msg string) { l.log(DebugLevel, msg) }
func (l *StandardLogger) Info(msg string)  { l.log(InfoLevel, msg) }
func (l *StandardLogger) Warn(msg string)  { l.log(WarnLevel, msg) }
func (l *StandardLogger) Error(msg string) { l.log(ErrorLevel, msg) }
func (l *StandardLogger) Fatal(msg string) {
	l.log(FatalLevel, msg)
	l.Flush()
	os.Exit(1)
}

func (l *StandardLogger) Tracef(format string, args ...interface{}) {
	l.log(TraceLevel, fmt.Sprintf(format, args...))
}
func (l *StandardLogger) Debugf(format string, args ...interface{}) {
	l.log(DebugLevel, fmt.Sprintf(format, args...))
}
func (l *StandardLogger) Infof(format string, args ...interface{}) {
	l.log(InfoLevel, fmt.Sprintf(format, args...))
}
func (l *StandardLogger) Warnf(format string, args ...interface{}) {
	l.log(WarnLevel, fmt.Sprintf(format, args...))
}
func (l *StandardLogger) Errorf(format string, args ...interface{}) {
	l.log(ErrorLevel, fmt.Sprintf(format, args...))
}
func (l *StandardLogger) Fatalf(format string, args ...interface{}) {
	l.log(FatalLevel, fmt.Sprintf(format, args...))
	l.Flush()
	os.Exit(1)
}

// WithFields 添加字段
func (l *StandardLogger) WithFields(fields Fields) Logger {
	newLogger := l.clone()
	for k, v := range fields {
		newLogger.fields[k] = v
	}
	return newLogger
}

// WithField 添加单个字段
func (l *StandardLogger) WithField(key string, value interface{}) Logger {
	newLogger := l.clone()
	newLogger.fields[key] = value
	return newLogger
}

// WithError 添加错误字段
func (l *StandardLogger) WithError(err error) Logger {
	return l.WithField("error", err.Error())
}

// WithContext 从上下文添加字段
func (l *StandardLogger) WithContext(ctx context.Context) Logger {
	newLogger := l.clone()

	// 添加请求ID
	if l.config.EnableRequestID {
		if requestID := GetRequestIDFromContext(ctx); requestID != "" {
			newLogger.fields["request_id"] = requestID
		}
	}

	// 添加追踪信息
	if l.config.EnableTrace {
		if span := trace.SpanFromContext(ctx); span.SpanContext().IsValid() {
			newLogger.fields["trace_id"] = span.SpanContext().TraceID().String()
			newLogger.fields["span_id"] = span.SpanContext().SpanID().String()
		}
	}

	return newLogger
}

// clone 克隆日志器
func (l *StandardLogger) clone() *StandardLogger {
	newLogger := &StandardLogger{
		level:     l.level,
		output:    l.output,
		formatter: l.formatter,
		hooks:     l.hooks,
		config:    l.config,
		async:     l.async,
		buffer:    l.buffer,
		sampler:   l.sampler,
		fields:    make(Fields),
	}

	// 复制字段
	for k, v := range l.fields {
		newLogger.fields[k] = v
	}

	return newLogger
}

// SetLevel 设置日志级别
func (l *StandardLogger) SetLevel(level Level) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.level = level
}

// GetLevel 获取日志级别
func (l *StandardLogger) GetLevel() Level {
	l.mu.RLock()
	defer l.mu.RUnlock()
	return l.level
}

// SetOutput 设置输出
func (l *StandardLogger) SetOutput(output io.Writer) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.output = output
}

// SetFormatter 设置格式化器
func (l *StandardLogger) SetFormatter(formatter Formatter) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.formatter = formatter
}

// AddHook 添加钩子
func (l *StandardLogger) AddHook(hook Hook) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.hooks = append(l.hooks, hook)
}

// Flush 刷新缓冲区
func (l *StandardLogger) Flush() error {
	if !l.async {
		return nil
	}

	// 等待异步写入完成
	if l.flushTimer != nil {
		l.flushTimer.Reset(0)
	}

	return nil
}

// Close 关闭日志器
func (l *StandardLogger) Close() error {
	if l.closed {
		return nil
	}

	l.closed = true

	if l.async {
		close(l.buffer)
		l.wg.Wait()
	}

	if closer, ok := l.output.(io.Closer); ok {
		return closer.Close()
	}

	return nil
}
```

### 步骤4：实现日志轮转和采样

#### 4.1 创建文件轮转器

```go
// pkg/logger/rotating_writer.go
package logger

import (
	"fmt"
	"io"
	"os"
	"path/filepath"

	"gopkg.in/natefinch/lumberjack.v2"
)

// RotatingFileWriter 轮转文件写入器
type RotatingFileWriter struct {
	*lumberjack.Logger
}

// NewRotatingFileWriter 创建轮转文件写入器
func NewRotatingFileWriter(config *FileConfig) (*RotatingFileWriter, error) {
	// 确保目录存在
	dir := filepath.Dir(config.Path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create log directory: %w", err)
	}

	lumberjackLogger := &lumberjack.Logger{
		Filename:   config.Path,
		MaxSize:    config.MaxSize,
		MaxBackups: config.MaxBackups,
		MaxAge:     config.MaxAge,
		Compress:   config.Compress,
		LocalTime:  config.LocalTime,
	}

	return &RotatingFileWriter{
		Logger: lumberjackLogger,
	}, nil
}

// Write 写入数据
func (w *RotatingFileWriter) Write(p []byte) (n int, err error) {
	return w.Logger.Write(p)
}

// Close 关闭写入器
func (w *RotatingFileWriter) Close() error {
	return w.Logger.Close()
}
```

#### 4.2 创建采样器

```go
// pkg/logger/sampler.go
package logger

import (
	"sync"
	"time"
)

// Sampler 日志采样器
type Sampler struct {
	config    *SamplingConfig
	mu        sync.Mutex
	counter   map[Level]int
	lastReset time.Time
}

// NewSampler 创建采样器
func NewSampler(config *SamplingConfig) *Sampler {
	return &Sampler{
		config:    config,
		counter:   make(map[Level]int),
		lastReset: time.Now(),
	}
}

// Sample 判断是否应该记录日志
func (s *Sampler) Sample(level Level) bool {
	if !s.config.Enabled {
		return true
	}

	s.mu.Lock()
	defer s.mu.Unlock()

	// 检查是否需要重置计数器
	now := time.Now()
	if now.Sub(s.lastReset) >= time.Duration(s.config.Tick)*time.Second {
		s.counter = make(map[Level]int)
		s.lastReset = now
	}

	// 增加计数
	s.counter[level]++
	count := s.counter[level]

	// 前N条必须记录
	if count <= s.config.First {
		return true
	}

	// 之后按照配置的间隔记录
	if s.config.Thereafter > 0 && (count-s.config.First)%s.config.Thereafter == 0 {
		return true
	}

	// 按照采样率记录
	if s.config.Rate > 0 && count%int(1.0/s.config.Rate) == 0 {
		return true
	}

	return false
}
```

### 步骤5：实现日志钩子

#### 5.1 创建Prometheus钩子

```go
// pkg/logger/hooks.go
package logger

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
)

// PrometheusHook Prometheus指标钩子
type PrometheusHook struct {
	config   *PrometheusHookConfig
	counter  *prometheus.CounterVec
	histogram *prometheus.HistogramVec
	levels   []Level
}

// NewPrometheusHook 创建Prometheus钩子
func NewPrometheusHook(config *PrometheusHookConfig) *PrometheusHook {
	// 解析级别
	levels := make([]Level, 0, len(config.Levels))
	for _, levelStr := range config.Levels {
		levels = append(levels, ParseLevel(levelStr))
	}

	// 创建指标
	counter := promauto.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: config.Namespace,
			Subsystem: config.Subsystem,
			Name:      "log_entries_total",
			Help:      "Total number of log entries",
		},
		[]string{"level"},
	)

	histogram := promauto.NewHistogramVec(
		prometheus.HistogramOpts{
			Namespace: config.Namespace,
			Subsystem: config.Subsystem,
			Name:      "log_entry_duration_seconds",
			Help:      "Time spent processing log entries",
		},
		[]string{"level"},
	)

	return &PrometheusHook{
		config:    config,
		counter:   counter,
		histogram: histogram,
		levels:    levels,
	}
}

// Levels 返回钩子关注的日志级别
func (h *PrometheusHook) Levels() []Level {
	return h.levels
}

// Fire 触发钩子
func (h *PrometheusHook) Fire(entry *Entry) error {
	start := time.Now()
	defer func() {
		duration := time.Since(start).Seconds()
		h.histogram.WithLabelValues(entry.Level.String()).Observe(duration)
	}()

	h.counter.WithLabelValues(entry.Level.String()).Inc()
	return nil
}

// SlackHook Slack通知钩子
type SlackHook struct {
	config *SlackHookConfig
	levels []Level
	client *http.Client
}

// NewSlackHook 创建Slack钩子
func NewSlackHook(config *SlackHookConfig) *SlackHook {
	// 解析级别
	levels := make([]Level, 0, len(config.Levels))
	for _, levelStr := range config.Levels {
		levels = append(levels, ParseLevel(levelStr))
	}

	return &SlackHook{
		config: config,
		levels: levels,
		client: &http.Client{
			Timeout: 10 * time.Second,
		},
	}
}

// Levels 返回钩子关注的日志级别
func (h *SlackHook) Levels() []Level {
	return h.levels
}

// Fire 触发钩子
func (h *SlackHook) Fire(entry *Entry) error {
	// 构建Slack消息
	message := map[string]interface{}{
		"channel":  h.config.Channel,
		"username": h.config.Username,
		"text":     fmt.Sprintf("[%s] %s", entry.Level.String(), entry.Message),
	}

	// 添加附件
	if len(entry.Fields) > 0 {
		fields := make([]map[string]interface{}, 0, len(entry.Fields))
		for k, v := range entry.Fields {
			fields = append(fields, map[string]interface{}{
				"title": k,
				"value": fmt.Sprintf("%v", v),
				"short": true,
			})
		}

		message["attachments"] = []map[string]interface{}{
			{
				"color":  h.getLevelColor(entry.Level),
				"fields": fields,
			},
		}
	}

	// 发送消息
	return h.sendMessage(message)
}

// getLevelColor 获取级别对应的颜色
func (h *SlackHook) getLevelColor(level Level) string {
	switch level {
	case ErrorLevel, FatalLevel:
		return "danger"
	case WarnLevel:
		return "warning"
	case InfoLevel:
		return "good"
	default:
		return "#36a64f"
	}
}

// sendMessage 发送消息到Slack
func (h *SlackHook) sendMessage(message map[string]interface{}) error {
	data, err := json.Marshal(message)
	if err != nil {
		return fmt.Errorf("failed to marshal slack message: %w", err)
	}

	resp, err := h.client.Post(h.config.WebhookURL, "application/json", bytes.NewBuffer(data))
	if err != nil {
		return fmt.Errorf("failed to send slack message: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("slack webhook returned status %d", resp.StatusCode)
	}

	return nil
}

// WebhookHook 通用Webhook钩子
type WebhookHook struct {
	config *WebhookHookConfig
	levels []Level
	client *http.Client
}

// NewWebhookHook 创建Webhook钩子
func NewWebhookHook(config *WebhookHookConfig) *WebhookHook {
	// 解析级别
	levels := make([]Level, 0, len(config.Levels))
	for _, levelStr := range config.Levels {
		levels = append(levels, ParseLevel(levelStr))
	}

	timeout := time.Duration(config.Timeout) * time.Second
	if timeout == 0 {
		timeout = 10 * time.Second
	}

	return &WebhookHook{
		config: config,
		levels: levels,
		client: &http.Client{
			Timeout: timeout,
		},
	}
}

// Levels 返回钩子关注的日志级别
func (h *WebhookHook) Levels() []Level {
	return h.levels
}

// Fire 触发钩子
func (h *WebhookHook) Fire(entry *Entry) error {
	// 构建请求数据
	data := map[string]interface{}{
		"level":     entry.Level.String(),
		"message":   entry.Message,
		"timestamp": time.Unix(0, entry.Time).Format(time.RFC3339),
		"fields":    entry.Fields,
	}

	if entry.Caller != nil {
		data["caller"] = entry.Caller
	}

	if entry.TraceID != "" {
		data["trace_id"] = entry.TraceID
	}

	if entry.RequestID != "" {
		data["request_id"] = entry.RequestID
	}

	// 序列化数据
	jsonData, err := json.Marshal(data)
	if err != nil {
		return fmt.Errorf("failed to marshal webhook data: %w", err)
	}

	// 发送请求
	resp, err := h.client.Post(h.config.URL, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return fmt.Errorf("failed to send webhook: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("webhook returned status %d", resp.StatusCode)
	}

	return nil
}
```

### 步骤6：实现上下文支持

#### 6.1 创建上下文工具

```go
// pkg/logger/context.go
package logger

import (
	"context"
	"crypto/rand"
	"encoding/hex"
)

type contextKey string

const (
	RequestIDKey contextKey = "request_id"
	LoggerKey    contextKey = "logger"
)

// WithRequestID 在上下文中设置请求ID
func WithRequestID(ctx context.Context, requestID string) context.Context {
	return context.WithValue(ctx, RequestIDKey, requestID)
}

// GetRequestIDFromContext 从上下文中获取请求ID
func GetRequestIDFromContext(ctx context.Context) string {
	if requestID, ok := ctx.Value(RequestIDKey).(string); ok {
		return requestID
	}
	return ""
}

// GenerateRequestID 生成请求ID
func GenerateRequestID() string {
	bytes := make([]byte, 8)
	rand.Read(bytes)
	return hex.EncodeToString(bytes)
}

// WithLogger 在上下文中设置日志器
func WithLogger(ctx context.Context, logger Logger) context.Context {
	return context.WithValue(ctx, LoggerKey, logger)
}

// GetLoggerFromContext 从上下文中获取日志器
func GetLoggerFromContext(ctx context.Context) Logger {
	if logger, ok := ctx.Value(LoggerKey).(Logger); ok {
		return logger
	}
	return nil
}

// FromContext 从上下文创建带有上下文信息的日志器
func FromContext(ctx context.Context, baseLogger Logger) Logger {
	if baseLogger == nil {
		return nil
	}

	logger := baseLogger.WithContext(ctx)

	// 如果上下文中有现有的日志器，合并其字段
	if existingLogger := GetLoggerFromContext(ctx); existingLogger != nil {
		if sl, ok := existingLogger.(*StandardLogger); ok {
			logger = logger.WithFields(sl.fields)
		}
	}

	return logger
}
```

### 步骤7：创建全局日志器和工厂

#### 7.1 创建全局日志器

```go
// pkg/logger/global.go
package logger

import (
	"sync"
)

var (
	globalLogger Logger
	globalMu     sync.RWMutex
)

// SetGlobalLogger 设置全局日志器
func SetGlobalLogger(logger Logger) {
	globalMu.Lock()
	defer globalMu.Unlock()
	globalLogger = logger
}

// GetGlobalLogger 获取全局日志器
func GetGlobalLogger() Logger {
	globalMu.RLock()
	defer globalMu.RUnlock()
	return globalLogger
}

// 全局日志方法
func Trace(msg string)                                 { getLogger().Trace(msg) }
func Debug(msg string)                                 { getLogger().Debug(msg) }
func Info(msg string)                                  { getLogger().Info(msg) }
func Warn(msg string)                                  { getLogger().Warn(msg) }
func Error(msg string)                                 { getLogger().Error(msg) }
func Fatal(msg string)                                 { getLogger().Fatal(msg) }
func Tracef(format string, args ...interface{})       { getLogger().Tracef(format, args...) }
func Debugf(format string, args ...interface{})       { getLogger().Debugf(format, args...) }
func Infof(format string, args ...interface{})        { getLogger().Infof(format, args...) }
func Warnf(format string, args ...interface{})        { getLogger().Warnf(format, args...) }
func Errorf(format string, args ...interface{})       { getLogger().Errorf(format, args...) }
func Fatalf(format string, args ...interface{})       { getLogger().Fatalf(format, args...) }
func WithFields(fields Fields) Logger                 { return getLogger().WithFields(fields) }
func WithField(key string, value interface{}) Logger  { return getLogger().WithField(key, value) }
func WithError(err error) Logger                      { return getLogger().WithError(err) }

// getLogger 获取日志器，如果没有设置则创建默认日志器
func getLogger() Logger {
	globalMu.RLock()
	logger := globalLogger
	globalMu.RUnlock()

	if logger == nil {
		// 创建默认日志器
		defaultLogger, _ := NewLogger(DefaultConfig())
		SetGlobalLogger(defaultLogger)
		return defaultLogger
	}

	return logger
}
```

#### 7.2 创建日志器工厂

```go
// pkg/logger/factory.go
package logger

import (
	"fmt"
	"sync"

	"movieinfo/pkg/config"
)

// Factory 日志器工厂
type Factory struct {
	mu      sync.RWMutex
	loggers map[string]Logger
	config  *config.Config
}

// NewFactory 创建日志器工厂
func NewFactory(config *config.Config) *Factory {
	return &Factory{
		loggers: make(map[string]Logger),
		config:  config,
	}
}

// GetLogger 获取指定名称的日志器
func (f *Factory) GetLogger(name string) (Logger, error) {
	f.mu.RLock()
	logger, exists := f.loggers[name]
	f.mu.RUnlock()

	if exists {
		return logger, nil
	}

	f.mu.Lock()
	defer f.mu.Unlock()

	// 双重检查
	if logger, exists := f.loggers[name]; exists {
		return logger, nil
	}

	// 创建新的日志器
	loggerConfig := f.createLoggerConfig(name)
	logger, err := NewLogger(loggerConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to create logger %s: %w", name, err)
	}

	f.loggers[name] = logger
	return logger, nil
}

// createLoggerConfig 为指定名称创建日志器配置
func (f *Factory) createLoggerConfig(name string) *Config {
	// 基于全局配置创建
	loggerConfig := *f.config.Logger

	// 根据名称自定义配置
	switch name {
	case "access":
		// 访问日志配置
		loggerConfig.File.Path = "logs/access.log"
		loggerConfig.Level = "info"
	case "error":
		// 错误日志配置
		loggerConfig.File.Path = "logs/error.log"
		loggerConfig.Level = "error"
		loggerConfig.Hooks.Slack.Enabled = true
	case "audit":
		// 审计日志配置
		loggerConfig.File.Path = "logs/audit.log"
		loggerConfig.Level = "info"
		loggerConfig.Format = "json"
	default:
		// 默认应用日志配置
		loggerConfig.File.Path = fmt.Sprintf("logs/%s.log", name)
	}

	return &loggerConfig
}

// Close 关闭所有日志器
func (f *Factory) Close() error {
	f.mu.Lock()
	defer f.mu.Unlock()

	for name, logger := range f.loggers {
		if err := logger.Close(); err != nil {
			fmt.Printf("Failed to close logger %s: %v\n", name, err)
		}
	}

	f.loggers = make(map[string]Logger)
	return nil
}
```

### 步骤8：创建配置文件

#### 8.1 创建日志配置文件

```yaml
# configs/logger.yaml
logger:
  # 基础配置
  level: "info"              # 日志级别: trace, debug, info, warn, error, fatal
  format: "json"             # 日志格式: json, text
  output: "file"             # 输出方式: stdout, stderr, file
  time_format: "2006-01-02T15:04:05.000Z07:00"

  # 文件输出配置
  file:
    path: "logs/app.log"     # 日志文件路径
    max_size: 100            # 单个文件最大大小(MB)
    max_backups: 10          # 保留的备份文件数量
    max_age: 30              # 文件保留天数
    compress: true           # 是否压缩旧文件
    local_time: true         # 使用本地时间

  # 性能配置
  async: true                # 启用异步写入
  buffer_size: 1000          # 缓冲区大小
  flush_time: "1s"           # 刷新间隔

  # 功能配置
  enable_caller: true        # 启用调用者信息
  enable_trace: true         # 启用链路追踪
  enable_request_id: true    # 启用请求ID

  # 采样配置
  sampling:
    enabled: false           # 启用采样
    rate: 1.0               # 采样率 (0.0-1.0)
    threshold: 100          # 阈值
    tick: 1                 # 时间窗口(秒)
    first: 10               # 窗口内前N条必记录
    thereafter: 100         # 之后每N条记录1条

  # 钩子配置
  hooks:
    # Slack通知
    slack:
      enabled: false
      webhook_url: "https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK"
      channel: "#alerts"
      username: "MovieInfo Bot"
      levels: ["error", "fatal"]

    # Webhook通知
    webhook:
      enabled: false
      url: "https://your-webhook-endpoint.com/logs"
      timeout: 10
      levels: ["error", "fatal"]

    # Prometheus指标
    prometheus:
      enabled: true
      namespace: "movieinfo"
      subsystem: "logger"
      levels: ["info", "warn", "error", "fatal"]

# 环境特定配置
development:
  logger:
    level: "debug"
    format: "text"
    output: "stdout"
    enable_caller: true
    async: false

production:
  logger:
    level: "info"
    format: "json"
    output: "file"
    enable_caller: false
    async: true
    hooks:
      slack:
        enabled: true
      prometheus:
        enabled: true

testing:
  logger:
    level: "warn"
    format: "text"
    output: "stderr"
    async: false
```

#### 8.2 创建日志初始化脚本

```go
// pkg/logger/init.go
package logger

import (
	"fmt"
	"os"
	"path/filepath"

	"movieinfo/pkg/config"
)

// InitLogger 初始化日志系统
func InitLogger(cfg *config.Config) error {
	// 创建日志目录
	logDir := filepath.Dir(cfg.Logger.File.Path)
	if err := os.MkdirAll(logDir, 0755); err != nil {
		return fmt.Errorf("failed to create log directory: %w", err)
	}

	// 创建主日志器
	mainLogger, err := NewLogger(cfg.Logger)
	if err != nil {
		return fmt.Errorf("failed to create main logger: %w", err)
	}

	// 设置全局日志器
	SetGlobalLogger(mainLogger)

	// 记录初始化信息
	mainLogger.Info("Logger system initialized successfully")
	mainLogger.WithFields(Fields{
		"level":  cfg.Logger.Level,
		"format": cfg.Logger.Format,
		"output": cfg.Logger.Output,
		"async":  cfg.Logger.Async,
	}).Debug("Logger configuration")

	return nil
}

// InitLoggerFactory 初始化日志器工厂
func InitLoggerFactory(cfg *config.Config) (*Factory, error) {
	factory := NewFactory(cfg)

	// 预创建常用日志器
	loggerNames := []string{"app", "access", "error", "audit"}
	for _, name := range loggerNames {
		if _, err := factory.GetLogger(name); err != nil {
			return nil, fmt.Errorf("failed to create logger %s: %w", name, err)
		}
	}

	return factory, nil
}
```

## 测试验证

### 单元测试

#### 创建日志器测试

```go
// pkg/logger/logger_test.go
package logger

import (
	"bytes"
	"encoding/json"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNewLogger(t *testing.T) {
	config := DefaultConfig()
	config.Output = "stdout"
	config.Format = "json"
	config.Level = "debug"

	logger, err := NewLogger(config)
	require.NoError(t, err)
	require.NotNil(t, logger)

	assert.Equal(t, DebugLevel, logger.GetLevel())
}

func TestLoggerLevels(t *testing.T) {
	var buf bytes.Buffer
	config := DefaultConfig()
	config.Output = "stdout"
	config.Format = "json"
	config.Level = "info"
	config.Async = false

	logger, err := NewLogger(config)
	require.NoError(t, err)

	logger.SetOutput(&buf)

	// 测试不同级别的日志
	logger.Debug("debug message")  // 不应该输出
	logger.Info("info message")    // 应该输出
	logger.Warn("warn message")    // 应该输出
	logger.Error("error message")  // 应该输出

	output := buf.String()
	lines := strings.Split(strings.TrimSpace(output), "\n")

	// 应该有3行输出（info, warn, error）
	assert.Len(t, lines, 3)

	// 验证JSON格式
	for _, line := range lines {
		var entry map[string]interface{}
		err := json.Unmarshal([]byte(line), &entry)
		assert.NoError(t, err)
		assert.Contains(t, entry, "level")
		assert.Contains(t, entry, "message")
		assert.Contains(t, entry, "timestamp")
	}
}

func TestLoggerWithFields(t *testing.T) {
	var buf bytes.Buffer
	config := DefaultConfig()
	config.Output = "stdout"
	config.Format = "json"
	config.Async = false

	logger, err := NewLogger(config)
	require.NoError(t, err)
	logger.SetOutput(&buf)

	// 测试带字段的日志
	logger.WithFields(Fields{
		"user_id": 123,
		"action":  "login",
	}).Info("User logged in")

	output := buf.String()
	var entry map[string]interface{}
	err = json.Unmarshal([]byte(strings.TrimSpace(output)), &entry)
	require.NoError(t, err)

	assert.Equal(t, "User logged in", entry["message"])
	assert.Equal(t, float64(123), entry["user_id"])
	assert.Equal(t, "login", entry["action"])
}

func TestLoggerFormatters(t *testing.T) {
	tests := []struct {
		name   string
		format string
		check  func(string) bool
	}{
		{
			name:   "JSON format",
			format: "json",
			check: func(output string) bool {
				var entry map[string]interface{}
				return json.Unmarshal([]byte(strings.TrimSpace(output)), &entry) == nil
			},
		},
		{
			name:   "Text format",
			format: "text",
			check: func(output string) bool {
				return strings.Contains(output, "[INFO]") && strings.Contains(output, "test message")
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var buf bytes.Buffer
			config := DefaultConfig()
			config.Output = "stdout"
			config.Format = tt.format
			config.Async = false

			logger, err := NewLogger(config)
			require.NoError(t, err)
			logger.SetOutput(&buf)

			logger.Info("test message")

			output := buf.String()
			assert.True(t, tt.check(output), "Format check failed for %s", tt.format)
		})
	}
}

func TestAsyncLogger(t *testing.T) {
	var buf bytes.Buffer
	config := DefaultConfig()
	config.Output = "stdout"
	config.Format = "json"
	config.Async = true
	config.BufferSize = 10
	config.FlushTime = 100 * time.Millisecond

	logger, err := NewLogger(config)
	require.NoError(t, err)
	logger.SetOutput(&buf)

	// 写入多条日志
	for i := 0; i < 5; i++ {
		logger.Infof("message %d", i)
	}

	// 等待异步写入完成
	time.Sleep(200 * time.Millisecond)
	logger.Flush()
	time.Sleep(100 * time.Millisecond)

	output := buf.String()
	lines := strings.Split(strings.TrimSpace(output), "\n")
	assert.Len(t, lines, 5)

	// 清理
	logger.Close()
}
```

### 集成测试

#### 创建完整的日志系统测试

```go
// test/logger_integration_test.go
package test

import (
	"context"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"movieinfo/pkg/config"
	"movieinfo/pkg/logger"
)

func TestLoggerIntegration(t *testing.T) {
	// 创建临时目录
	tempDir := t.TempDir()
	logFile := filepath.Join(tempDir, "test.log")

	// 创建配置
	cfg := &config.Config{
		Logger: &logger.Config{
			Level:  "debug",
			Format: "json",
			Output: "file",
			File: logger.FileConfig{
				Path:       logFile,
				MaxSize:    1,
				MaxBackups: 3,
				MaxAge:     1,
				Compress:   false,
				LocalTime:  true,
			},
			Async:           false,
			EnableCaller:    true,
			EnableTrace:     true,
			EnableRequestID: true,
		},
	}

	// 初始化日志系统
	err := logger.InitLogger(cfg)
	require.NoError(t, err)

	// 测试全局日志器
	logger.Info("Test global logger")
	logger.WithField("test", true).Debug("Test with field")

	// 测试上下文日志器
	ctx := context.Background()
	ctx = logger.WithRequestID(ctx, "test-request-123")

	contextLogger := logger.FromContext(ctx, logger.GetGlobalLogger())
	contextLogger.Info("Test context logger")

	// 验证日志文件存在
	assert.FileExists(t, logFile)

	// 读取并验证日志内容
	content, err := os.ReadFile(logFile)
	require.NoError(t, err)
	assert.Contains(t, string(content), "Test global logger")
	assert.Contains(t, string(content), "test-request-123")

	// 清理
	logger.GetGlobalLogger().Close()
}

func TestLoggerFactory(t *testing.T) {
	// 创建临时目录
	tempDir := t.TempDir()

	// 创建配置
	cfg := &config.Config{
		Logger: &logger.Config{
			Level:  "info",
			Format: "json",
			Output: "file",
			File: logger.FileConfig{
				Path:       filepath.Join(tempDir, "app.log"),
				MaxSize:    10,
				MaxBackups: 5,
				MaxAge:     7,
				Compress:   true,
				LocalTime:  true,
			},
			Async: false,
		},
	}

	// 创建工厂
	factory, err := logger.InitLoggerFactory(cfg)
	require.NoError(t, err)
	defer factory.Close()

	// 测试获取不同的日志器
	appLogger, err := factory.GetLogger("app")
	require.NoError(t, err)
	assert.NotNil(t, appLogger)

	accessLogger, err := factory.GetLogger("access")
	require.NoError(t, err)
	assert.NotNil(t, accessLogger)

	errorLogger, err := factory.GetLogger("error")
	require.NoError(t, err)
	assert.NotNil(t, errorLogger)

	// 测试日志器是否可以正常工作
	appLogger.Info("App logger test")
	accessLogger.Info("Access logger test")
	errorLogger.Error("Error logger test")

	// 验证不同的日志文件
	assert.FileExists(t, filepath.Join(tempDir, "app.log"))
	assert.FileExists(t, filepath.Join(tempDir, "access.log"))
	assert.FileExists(t, filepath.Join(tempDir, "error.log"))
}
```

## 预期结果

完成本步骤后，你将拥有：

1. **完整的日志接口定义**：支持多种日志级别和格式化方式
2. **高性能的日志实现**：支持异步写入和批量处理
3. **灵活的配置系统**：支持多环境配置和动态调整
4. **强大的扩展能力**：支持自定义格式化器和钩子
5. **完善的监控集成**：集成Prometheus指标和外部通知
6. **分布式追踪支持**：集成OpenTelemetry链路追踪
7. **生产级特性**：日志轮转、采样、压缩等

## 注意事项

### 安全性
- **敏感信息过滤**：确保不记录密码、密钥等敏感信息
- **日志注入防护**：对用户输入进行适当的转义和过滤
- **访问控制**：限制日志文件的访问权限

### 性能
- **异步写入**：在高并发场景下使用异步写入避免阻塞
- **批量处理**：批量写入日志以提高性能
- **采样机制**：在高流量场景下使用采样减少日志量
- **缓冲区管理**：合理设置缓冲区大小避免内存溢出

### 维护性
- **日志轮转**：定期轮转日志文件避免单个文件过大
- **清理策略**：定期清理过期的日志文件
- **监控告警**：监控日志系统的健康状态
- **文档更新**：及时更新日志格式和字段的文档

## 下一步骤

完成日志系统后，下一步将进行：
- **05-gRPC协议定义**：定义服务间通信的gRPC接口
- 集成日志系统到gRPC服务中
- 实现分布式链路追踪
- 添加性能监控和指标收集

## 检查清单

- [ ] 日志接口和结构定义完成
- [ ] 核心日志器实现完成
- [ ] 格式化器实现完成（JSON和文本）
- [ ] 日志轮转功能实现
- [ ] 采样机制实现
- [ ] 钩子系统实现（Prometheus、Slack、Webhook）
- [ ] 上下文支持实现
- [ ] 全局日志器和工厂实现
- [ ] 配置文件创建
- [ ] 初始化脚本创建
- [ ] 单元测试编写
- [ ] 集成测试编写
- [ ] 性能测试通过
- [ ] 文档更新完成