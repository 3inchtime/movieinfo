# 09-评分服务开发

## 目标

本文档将指导您完成 MovieInfo 项目的评分服务开发，包括：

1. **评分数据访问层**：实现评分的CRUD操作
2. **评分业务逻辑层**：实现评分计算、统计和验证
3. **评分gRPC服务层**：提供标准化的API接口
4. **评分聚合功能**：实现电影评分统计和排名
5. **评分缓存策略**：优化评分查询性能

## 前置条件

在开始本文档之前，请确保已完成：

- [x] 项目基础架构搭建
- [x] 配置管理系统
- [x] 日志系统
- [x] gRPC协议定义
- [x] 数据模型层
- [x] 用户服务开发
- [x] 电影服务开发

## 技术要点

### 设计原则

1. **数据一致性**：确保评分数据的准确性和一致性
2. **性能优化**：实现高效的评分查询和统计
3. **防刷机制**：防止恶意刷分和重复评分
4. **实时更新**：支持评分的实时计算和更新
5. **可扩展性**：支持不同类型的评分系统

### 技术选型

- **数据库**：PostgreSQL（主数据存储）
- **缓存**：Redis（评分统计缓存）
- **消息队列**：用于异步评分统计更新
- **算法**：加权平均算法、贝叶斯平均算法

### 架构设计

```
评分服务架构
├── gRPC Handler（API层）
├── Service Layer（业务逻辑层）
│   ├── 评分服务
│   ├── 统计服务
│   └── 排名服务
├── Repository Layer（数据访问层）
│   ├── 评分仓储
│   └── 统计仓储
└── Cache Layer（缓存层）
    ├── 评分缓存
    └── 统计缓存
```

## 实现步骤

### 步骤1：实现评分仓储层

#### 1.1 创建评分仓储

```go
// internal/repository/rating_repository.go
package repository

import (
	"context"
	"fmt"
	"time"

	"gorm.io/gorm"

	"movieinfo/internal/models"
	"movieinfo/pkg/logger"
)

// ratingRepository 评分仓储实现
type ratingRepository struct {
	db     *gorm.DB
	logger logger.Logger
}

// NewRatingRepository 创建评分仓储
func NewRatingRepository(db *gorm.DB, logger logger.Logger) models.RatingRepository {
	return &ratingRepository{
		db:     db,
		logger: logger,
	}
}

// Create 创建评分
func (r *ratingRepository) Create(ctx context.Context, rating *models.Rating) error {
	if err := r.db.WithContext(ctx).Create(rating).Error; err != nil {
		r.logger.Error("Failed to create rating", "error", err)
		return err
	}

	r.logger.Info("Rating created successfully", "rating_id", rating.ID)
	return nil
}

// GetByID 根据ID获取评分
func (r *ratingRepository) GetByID(ctx context.Context, id uint64) (*models.Rating, error) {
	var rating models.Rating
	if err := r.db.WithContext(ctx).Preload("User").Preload("Movie").First(&rating, id).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, models.ErrRatingNotFound
		}
		r.logger.Error("Failed to get rating by ID", "rating_id", id, "error", err)
		return nil, err
	}

	return &rating, nil
}

// GetByUserAndMovie 根据用户和电影获取评分
func (r *ratingRepository) GetByUserAndMovie(ctx context.Context, userID, movieID uint64) (*models.Rating, error) {
	var rating models.Rating
	if err := r.db.WithContext(ctx).Where("user_id = ? AND movie_id = ?", userID, movieID).First(&rating).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, models.ErrRatingNotFound
		}
		r.logger.Error("Failed to get rating by user and movie", "user_id", userID, "movie_id", movieID, "error", err)
		return nil, err
	}

	return &rating, nil
}

// Update 更新评分
func (r *ratingRepository) Update(ctx context.Context, rating *models.Rating) error {
	if err := r.db.WithContext(ctx).Save(rating).Error; err != nil {
		r.logger.Error("Failed to update rating", "rating_id", rating.ID, "error", err)
		return err
	}

	r.logger.Info("Rating updated successfully", "rating_id", rating.ID)
	return nil
}

// Delete 删除评分
func (r *ratingRepository) Delete(ctx context.Context, id uint64) error {
	result := r.db.WithContext(ctx).Delete(&models.Rating{}, id)
	if result.Error != nil {
		r.logger.Error("Failed to delete rating", "rating_id", id, "error", result.Error)
		return result.Error
	}

	if result.RowsAffected == 0 {
		return models.ErrRatingNotFound
	}

	r.logger.Info("Rating deleted successfully", "rating_id", id)
	return nil
}

// List 获取评分列表
func (r *ratingRepository) List(ctx context.Context, params *models.RatingQueryParams) ([]*models.Rating, error) {
	query := r.db.WithContext(ctx).Model(&models.Rating{})

	// 应用过滤条件
	if params.UserID != nil {
		query = query.Where("user_id = ?", *params.UserID)
	}
	if params.MovieID != nil {
		query = query.Where("movie_id = ?", *params.MovieID)
	}
	if params.MinRating != nil {
		query = query.Where("rating >= ?", *params.MinRating)
	}
	if params.MaxRating != nil {
		query = query.Where("rating <= ?", *params.MaxRating)
	}
	if !params.StartDate.IsZero() {
		query = query.Where("created_at >= ?", params.StartDate)
	}
	if !params.EndDate.IsZero() {
		query = query.Where("created_at <= ?", params.EndDate)
	}

	// 应用排序
	if params.OrderBy != "" {
		order := params.OrderBy
		if params.OrderDesc {
			order += " DESC"
		}
		query = query.Order(order)
	} else {
		query = query.Order("created_at DESC")
	}

	// 应用分页
	if params.Limit > 0 {
		query = query.Limit(params.Limit)
	}
	if params.Offset > 0 {
		query = query.Offset(params.Offset)
	}

	// 预加载关联数据
	query = query.Preload("User").Preload("Movie")

	var ratings []*models.Rating
	if err := query.Find(&ratings).Error; err != nil {
		r.logger.Error("Failed to list ratings", "error", err)
		return nil, err
	}

	return ratings, nil
}

// Count 统计评分数量
func (r *ratingRepository) Count(ctx context.Context, params *models.RatingQueryParams) (int64, error) {
	query := r.db.WithContext(ctx).Model(&models.Rating{})

	// 应用过滤条件
	if params.UserID != nil {
		query = query.Where("user_id = ?", *params.UserID)
	}
	if params.MovieID != nil {
		query = query.Where("movie_id = ?", *params.MovieID)
	}
	if params.MinRating != nil {
		query = query.Where("rating >= ?", *params.MinRating)
	}
	if params.MaxRating != nil {
		query = query.Where("rating <= ?", *params.MaxRating)
	}
	if !params.StartDate.IsZero() {
		query = query.Where("created_at >= ?", params.StartDate)
	}
	if !params.EndDate.IsZero() {
		query = query.Where("created_at <= ?", params.EndDate)
	}

	var count int64
	if err := query.Count(&count).Error; err != nil {
		r.logger.Error("Failed to count ratings", "error", err)
		return 0, err
	}

	return count, nil
}

// GetMovieRatingStats 获取电影评分统计
func (r *ratingRepository) GetMovieRatingStats(ctx context.Context, movieID uint64) (*models.MovieRatingStats, error) {
	var stats models.MovieRatingStats

	// 查询评分统计
	query := `
		SELECT 
			COUNT(*) as total_ratings,
			AVG(score) as average_rating,
			COUNT(CASE WHEN score = 5 THEN 1 END) as rating_5,
			COUNT(CASE WHEN score = 4 THEN 1 END) as rating_4,
			COUNT(CASE WHEN score = 3 THEN 1 END) as rating_3,
			COUNT(CASE WHEN score = 2 THEN 1 END) as rating_2,
			COUNT(CASE WHEN score = 1 THEN 1 END) as rating_1
		FROM user_ratings 
		WHERE movie_id = ? AND deleted_at IS NULL
	`

	if err := r.db.WithContext(ctx).Raw(query, movieID).Scan(&stats).Error; err != nil {
		r.logger.Error("Failed to get movie rating stats", "movie_id", movieID, "error", err)
		return nil, err
	}

	stats.MovieID = movieID
	return &stats, nil
}

// GetUserRatingStats 获取用户评分统计
func (r *ratingRepository) GetUserRatingStats(ctx context.Context, userID uint64) (*models.UserRatingStats, error) {
	var stats models.UserRatingStats

	// 查询用户评分统计
	query := `
		SELECT 
			COUNT(*) as total_ratings,
			AVG(score) as average_rating,
			MAX(score) as highest_rating,
			MIN(score) as lowest_rating
		FROM user_ratings 
		WHERE user_id = ? AND deleted_at IS NULL
	`

	if err := r.db.WithContext(ctx).Raw(query, userID).Scan(&stats).Error; err != nil {
		r.logger.Error("Failed to get user rating stats", "user_id", userID, "error", err)
		return nil, err
	}

	stats.UserID = userID
	return &stats, nil
}

// GetTopRatedMovies 获取评分最高的电影
func (r *ratingRepository) GetTopRatedMovies(ctx context.Context, limit int, minRatings int) ([]*models.MovieRatingStats, error) {
	query := `
		SELECT 
			movie_id,
			COUNT(*) as total_ratings,
			AVG(score) as average_rating
		FROM user_ratings 
		WHERE deleted_at IS NULL
		GROUP BY movie_id 
		HAVING COUNT(*) >= ?
		ORDER BY average_rating DESC, total_ratings DESC
		LIMIT ?
	`

	var stats []*models.MovieRatingStats
	if err := r.db.WithContext(ctx).Raw(query, minRatings, limit).Scan(&stats).Error; err != nil {
		r.logger.Error("Failed to get top rated movies", "error", err)
		return nil, err
	}

	return stats, nil
}

// GetRecentRatings 获取最近的评分
func (r *ratingRepository) GetRecentRatings(ctx context.Context, limit int) ([]*models.Rating, error) {
	var ratings []*models.Rating
	if err := r.db.WithContext(ctx).
		Preload("User").
		Preload("Movie").
		Order("created_at DESC").
		Limit(limit).
		Find(&ratings).Error; err != nil {
		r.logger.Error("Failed to get recent ratings", "error", err)
		return nil, err
	}

	return ratings, nil
}

// ExistsByUserAndMovie 检查用户是否已评分电影
func (r *ratingRepository) ExistsByUserAndMovie(ctx context.Context, userID, movieID uint64) (bool, error) {
	var count int64
	if err := r.db.WithContext(ctx).Model(&models.Rating{}).Where("user_id = ? AND movie_id = ?", userID, movieID).Count(&count).Error; err != nil {
		r.logger.Error("Failed to check rating existence", "user_id", userID, "movie_id", movieID, "error", err)
		return false, err
	}

	return count > 0, nil
}

// BatchUpdateMovieRatings 批量更新电影评分统计
func (r *ratingRepository) BatchUpdateMovieRatings(ctx context.Context, movieIDs []uint64) error {
	// 使用事务批量更新
	tx := r.db.WithContext(ctx).Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	for _, movieID := range movieIDs {
		// 计算电影评分统计
		stats, err := r.GetMovieRatingStats(ctx, movieID)
		if err != nil {
			tx.Rollback()
			return err
		}

		// 更新电影表中的评分信息
		if err := tx.Model(&models.Movie{}).Where("id = ?", movieID).Updates(map[string]interface{}{
			"average_rating": stats.AverageRating,
			"total_ratings":  stats.TotalRatings,
			"updated_at":     time.Now(),
		}).Error; err != nil {
			tx.Rollback()
			r.logger.Error("Failed to update movie rating stats", "movie_id", movieID, "error", err)
			return err
		}
	}

	if err := tx.Commit().Error; err != nil {
		r.logger.Error("Failed to commit batch update", "error", err)
		return err
	}

	r.logger.Info("Batch updated movie ratings", "count", len(movieIDs))
	return nil
}

// HealthCheck 健康检查
func (r *ratingRepository) HealthCheck(ctx context.Context) error {
	var count int64
	if err := r.db.WithContext(ctx).Model(&models.Rating{}).Count(&count).Error; err != nil {
		r.logger.Error("Rating repository health check failed", "error", err)
		return err
	}

	r.logger.Debug("Rating repository health check passed", "total_ratings", count)
	return nil
}
```

### 步骤2：实现评分服务层

#### 2.1 创建评分服务

```go
// internal/service/rating_service.go
package service

import (
	"context"
	"fmt"
	"time"

	"movieinfo/internal/models"
	"movieinfo/pkg/cache"
	"movieinfo/pkg/logger"
)

// RatingService 评分服务接口
type RatingService interface {
	// 评分管理
	CreateRating(ctx context.Context, req *CreateRatingRequest) (*RatingResponse, error)
	GetRating(ctx context.Context, id uint64) (*RatingResponse, error)
	UpdateRating(ctx context.Context, id uint64, req *UpdateRatingRequest) (*RatingResponse, error)
	DeleteRating(ctx context.Context, id uint64) error

	// 评分查询
	GetRatingList(ctx context.Context, req *GetRatingListRequest) (*RatingListResponse, error)
	GetUserRating(ctx context.Context, userID, movieID uint64) (*RatingResponse, error)
	GetMovieRatings(ctx context.Context, req *GetMovieRatingsRequest) (*RatingListResponse, error)
	GetUserRatings(ctx context.Context, req *GetUserRatingsRequest) (*RatingListResponse, error)

	// 评分统计
	GetMovieRatingStats(ctx context.Context, movieID uint64) (*MovieRatingStatsResponse, error)
	GetUserRatingStats(ctx context.Context, userID uint64) (*UserRatingStatsResponse, error)
	GetTopRatedMovies(ctx context.Context, req *GetTopRatedMoviesRequest) (*TopRatedMoviesResponse, error)
	GetRecentRatings(ctx context.Context, limit int) (*RatingListResponse, error)

	// 评分计算
	CalculateMovieRating(ctx context.Context, movieID uint64) (*MovieRatingCalculation, error)
	UpdateMovieRatingCache(ctx context.Context, movieID uint64) error
	BatchUpdateMovieRatings(ctx context.Context, movieIDs []uint64) error
}

// ratingService 评分服务实现
type ratingService struct {
	ratingRepo models.RatingRepository
	movieRepo  models.MovieRepository
	userRepo   models.UserRepository
	cache      cache.Manager
	logger     logger.Logger
}

// NewRatingService 创建评分服务
func NewRatingService(
	ratingRepo models.RatingRepository,
	movieRepo models.MovieRepository,
	userRepo models.UserRepository,
	cache cache.Manager,
	logger logger.Logger,
) RatingService {
	return &ratingService{
		ratingRepo: ratingRepo,
		movieRepo:  movieRepo,
		userRepo:   userRepo,
		cache:      cache,
		logger:     logger,
	}
}

// CreateRating 创建评分
func (s *ratingService) CreateRating(ctx context.Context, req *CreateRatingRequest) (*RatingResponse, error) {
	// 验证请求参数
	if err := s.validateCreateRatingRequest(req); err != nil {
		s.logger.Error("Invalid create rating request", "error", err)
		return nil, err
	}

	// 检查用户是否存在
	user, err := s.userRepo.GetByID(ctx, req.UserID)
	if err != nil {
		s.logger.Error("User not found", "user_id", req.UserID, "error", err)
		return nil, models.ErrUserNotFound
	}

	// 检查电影是否存在
	movie, err := s.movieRepo.GetByID(ctx, req.MovieID)
	if err != nil {
		s.logger.Error("Movie not found", "movie_id", req.MovieID, "error", err)
		return nil, models.ErrMovieNotFound
	}

	// 检查用户是否已经评分
	exists, err := s.ratingRepo.ExistsByUserAndMovie(ctx, req.UserID, req.MovieID)
	if err != nil {
		s.logger.Error("Failed to check rating existence", "error", err)
		return nil, err
	}
	if exists {
		return nil, models.ErrRatingAlreadyExists
	}

	// 创建评分
	rating := &models.Rating{
		UserID:  req.UserID,
		MovieID: req.MovieID,
		Score:   req.Score,
		Comment: req.Comment,
	}

	if err := s.ratingRepo.Create(ctx, rating); err != nil {
		s.logger.Error("Failed to create rating", "error", err)
		return nil, err
	}

	// 异步更新电影评分统计
	go func() {
		if err := s.UpdateMovieRatingCache(context.Background(), req.MovieID); err != nil {
			s.logger.Error("Failed to update movie rating cache", "movie_id", req.MovieID, "error", err)
		}
	}()

	// 获取完整的评分信息
	createdRating, err := s.ratingRepo.GetByID(ctx, rating.ID)
	if err != nil {
		s.logger.Error("Failed to get created rating", "rating_id", rating.ID, "error", err)
		return nil, err
	}

	s.logger.Info("Rating created successfully", "rating_id", rating.ID, "user_id", req.UserID, "movie_id", req.MovieID)
	return s.convertRatingToResponse(createdRating), nil
}

// GetRating 获取评分
func (s *ratingService) GetRating(ctx context.Context, id uint64) (*RatingResponse, error) {
	rating, err := s.ratingRepo.GetByID(ctx, id)
	if err != nil {
		s.logger.Error("Failed to get rating", "rating_id", id, "error", err)
		return nil, err
	}

	return s.convertRatingToResponse(rating), nil
}

// UpdateRating 更新评分
func (s *ratingService) UpdateRating(ctx context.Context, id uint64, req *UpdateRatingRequest) (*RatingResponse, error) {
	// 获取现有评分
	rating, err := s.ratingRepo.GetByID(ctx, id)
	if err != nil {
		s.logger.Error("Failed to get rating for update", "rating_id", id, "error", err)
		return nil, err
	}

	// 验证请求参数
	if err := s.validateUpdateRatingRequest(req); err != nil {
		s.logger.Error("Invalid update rating request", "error", err)
		return nil, err
	}

	// 更新字段
	oldScore := rating.Score
	if req.Score != nil {
		rating.Score = *req.Score
	}
	if req.Comment != nil {
		rating.Comment = *req.Comment
	}
	rating.UpdatedAt = time.Now()

	// 保存更新
	if err := s.ratingRepo.Update(ctx, rating); err != nil {
		s.logger.Error("Failed to update rating", "rating_id", id, "error", err)
		return nil, err
	}

	// 如果评分发生变化，异步更新电影评分统计
	if req.Score != nil && *req.Score != oldScore {
		go func() {
			if err := s.UpdateMovieRatingCache(context.Background(), rating.MovieID); err != nil {
				s.logger.Error("Failed to update movie rating cache", "movie_id", rating.MovieID, "error", err)
			}
		}()
	}

	s.logger.Info("Rating updated successfully", "rating_id", id)
	return s.convertRatingToResponse(rating), nil
}

// DeleteRating 删除评分
func (s *ratingService) DeleteRating(ctx context.Context, id uint64) error {
	// 获取评分信息（用于后续更新统计）
	rating, err := s.ratingRepo.GetByID(ctx, id)
	if err != nil {
		s.logger.Error("Failed to get rating for deletion", "rating_id", id, "error", err)
		return err
	}

	// 删除评分
	if err := s.ratingRepo.Delete(ctx, id); err != nil {
		s.logger.Error("Failed to delete rating", "rating_id", id, "error", err)
		return err
	}

	// 异步更新电影评分统计
	go func() {
		if err := s.UpdateMovieRatingCache(context.Background(), rating.MovieID); err != nil {
			s.logger.Error("Failed to update movie rating cache", "movie_id", rating.MovieID, "error", err)
		}
	}()

	s.logger.Info("Rating deleted successfully", "rating_id", id)
	return nil
}

// GetRatingList 获取评分列表
func (s *ratingService) GetRatingList(ctx context.Context, req *GetRatingListRequest) (*RatingListResponse, error) {
	// 构建查询参数
	params := &models.RatingQueryParams{
		Limit:     req.PageSize,
		Offset:    (req.Page - 1) * req.PageSize,
		OrderBy:   req.OrderBy,
		OrderDesc: req.OrderDesc,
	}

	if req.UserID != nil {
		params.UserID = req.UserID
	}
	if req.MovieID != nil {
		params.MovieID = req.MovieID
	}
	if req.MinScore != nil {
		params.MinScore = req.MinScore
	}
	if req.MaxScore != nil {
		params.MaxScore = req.MaxScore
	}
	if req.StartDate != nil {
		params.StartDate = *req.StartDate
	}
	if req.EndDate != nil {
		params.EndDate = *req.EndDate
	}

	// 获取评分列表
	ratings, err := s.ratingRepo.List(ctx, params)
	if err != nil {
		s.logger.Error("Failed to get rating list", "error", err)
		return nil, err
	}

	// 获取总数
	total, err := s.ratingRepo.Count(ctx, params)
	if err != nil {
		s.logger.Error("Failed to count ratings", "error", err)
		return nil, err
	}

	// 转换响应
	ratingResponses := make([]*RatingResponse, len(ratings))
	for i, rating := range ratings {
		ratingResponses[i] = s.convertRatingToResponse(rating)
	}

	return &RatingListResponse{
		Ratings:    ratingResponses,
		Total:      total,
		Page:       req.Page,
		PageSize:   req.PageSize,
		TotalPages: (total + int64(req.PageSize) - 1) / int64(req.PageSize),
	}, nil
}

// GetUserRating 获取用户对电影的评分
func (s *ratingService) GetUserRating(ctx context.Context, userID, movieID uint64) (*RatingResponse, error) {
	rating, err := s.ratingRepo.GetByUserAndMovie(ctx, userID, movieID)
	if err != nil {
		s.logger.Error("Failed to get user rating", "user_id", userID, "movie_id", movieID, "error", err)
		return nil, err
	}

	return s.convertRatingToResponse(rating), nil
}

// GetMovieRatings 获取电影的评分列表
func (s *ratingService) GetMovieRatings(ctx context.Context, req *GetMovieRatingsRequest) (*RatingListResponse, error) {
	listReq := &GetRatingListRequest{
		MovieID:   &req.MovieID,
		Page:      req.Page,
		PageSize:  req.PageSize,
		OrderBy:   req.OrderBy,
		OrderDesc: req.OrderDesc,
	}

	return s.GetRatingList(ctx, listReq)
}

// GetUserRatings 获取用户的评分列表
func (s *ratingService) GetUserRatings(ctx context.Context, req *GetUserRatingsRequest) (*RatingListResponse, error) {
	listReq := &GetRatingListRequest{
		UserID:    &req.UserID,
		Page:      req.Page,
		PageSize:  req.PageSize,
		OrderBy:   req.OrderBy,
		OrderDesc: req.OrderDesc,
	}

	return s.GetRatingList(ctx, listReq)
}

// GetMovieRatingStats 获取电影评分统计
func (s *ratingService) GetMovieRatingStats(ctx context.Context, movieID uint64) (*MovieRatingStatsResponse, error) {
	// 尝试从缓存获取
	cacheKey := fmt.Sprintf("movie_rating_stats:%d", movieID)
	if s.cache.IsEnabled() {
		var cachedStats MovieRatingStatsResponse
		if err := s.cache.Get(ctx, cacheKey, &cachedStats); err == nil {
			s.logger.Debug("Movie rating stats cache hit", "movie_id", movieID)
			return &cachedStats, nil
		}
	}

	// 从数据库获取
	stats, err := s.ratingRepo.GetMovieRatingStats(ctx, movieID)
	if err != nil {
		s.logger.Error("Failed to get movie rating stats", "movie_id", movieID, "error", err)
		return nil, err
	}

	// 转换响应
	response := &MovieRatingStatsResponse{
		MovieID:       stats.MovieID,
		TotalRatings:  stats.TotalRatings,
		AverageRating: stats.AverageRating,
		Rating5:       stats.Rating5,
		Rating4:       stats.Rating4,
		Rating3:       stats.Rating3,
		Rating2:       stats.Rating2,
		Rating1:       stats.Rating1,
	}

	// 缓存结果
	if s.cache.IsEnabled() {
		if err := s.cache.Set(ctx, cacheKey, response, 30*time.Minute); err != nil {
			s.logger.Error("Failed to cache movie rating stats", "movie_id", movieID, "error", err)
		}
	}

	return response, nil
}

// GetUserRatingStats 获取用户评分统计
func (s *ratingService) GetUserRatingStats(ctx context.Context, userID uint64) (*UserRatingStatsResponse, error) {
	// 尝试从缓存获取
	cacheKey := fmt.Sprintf("user_rating_stats:%d", userID)
	if s.cache.IsEnabled() {
		var cachedStats UserRatingStatsResponse
		if err := s.cache.Get(ctx, cacheKey, &cachedStats); err == nil {
			s.logger.Debug("User rating stats cache hit", "user_id", userID)
			return &cachedStats, nil
		}
	}

	// 从数据库获取
	stats, err := s.ratingRepo.GetUserRatingStats(ctx, userID)
	if err != nil {
		s.logger.Error("Failed to get user rating stats", "user_id", userID, "error", err)
		return nil, err
	}

	// 转换响应
	response := &UserRatingStatsResponse{
		UserID:        stats.UserID,
		TotalRatings:  stats.TotalRatings,
		AverageRating: stats.AverageRating,
		HighestRating: stats.HighestRating,
		LowestRating:  stats.LowestRating,
	}

	// 缓存结果
	if s.cache.IsEnabled() {
		if err := s.cache.Set(ctx, cacheKey, response, 1*time.Hour); err != nil {
			s.logger.Error("Failed to cache user rating stats", "user_id", userID, "error", err)
		}
	}

	return response, nil
}

// GetTopRatedMovies 获取评分最高的电影
func (s *ratingService) GetTopRatedMovies(ctx context.Context, req *GetTopRatedMoviesRequest) (*TopRatedMoviesResponse, error) {
	// 尝试从缓存获取
	cacheKey := fmt.Sprintf("top_rated_movies:%d:%d", req.Limit, req.MinRatings)
	if s.cache.IsEnabled() {
		var cachedResponse TopRatedMoviesResponse
		if err := s.cache.Get(ctx, cacheKey, &cachedResponse); err == nil {
			s.logger.Debug("Top rated movies cache hit", "limit", req.Limit)
			return &cachedResponse, nil
		}
	}

	// 从数据库获取
	stats, err := s.ratingRepo.GetTopRatedMovies(ctx, req.Limit, req.MinRatings)
	if err != nil {
		s.logger.Error("Failed to get top rated movies", "error", err)
		return nil, err
	}

	// 获取电影详细信息
	movieIDs := make([]uint64, len(stats))
	for i, stat := range stats {
		movieIDs[i] = stat.MovieID
	}

	movies, err := s.movieRepo.GetByIDs(ctx, movieIDs)
	if err != nil {
		s.logger.Error("Failed to get movies for top rated", "error", err)
		return nil, err
	}

	// 创建电影映射
	movieMap := make(map[uint64]*models.Movie)
	for _, movie := range movies {
		movieMap[movie.ID] = movie
	}

	// 构建响应
	topMovies := make([]*TopRatedMovieResponse, len(stats))
	for i, stat := range stats {
		movie := movieMap[stat.MovieID]
		topMovies[i] = &TopRatedMovieResponse{
			MovieID:       stat.MovieID,
			Title:         movie.Title,
			PosterURL:     movie.PosterURL,
			Year:          movie.Year,
			TotalRatings:  stat.TotalRatings,
			AverageRating: stat.AverageRating,
		}
	}

	response := &TopRatedMoviesResponse{
		Movies: topMovies,
		Total:  int64(len(topMovies)),
	}

	// 缓存结果
	if s.cache.IsEnabled() {
		if err := s.cache.Set(ctx, cacheKey, response, 1*time.Hour); err != nil {
			s.logger.Error("Failed to cache top rated movies", "error", err)
		}
	}

	return response, nil
}

// GetRecentRatings 获取最近的评分
func (s *ratingService) GetRecentRatings(ctx context.Context, limit int) (*RatingListResponse, error) {
	// 尝试从缓存获取
	cacheKey := fmt.Sprintf("recent_ratings:%d", limit)
	if s.cache.IsEnabled() {
		var cachedResponse RatingListResponse
		if err := s.cache.Get(ctx, cacheKey, &cachedResponse); err == nil {
			s.logger.Debug("Recent ratings cache hit", "limit", limit)
			return &cachedResponse, nil
		}
	}

	// 从数据库获取
	ratings, err := s.ratingRepo.GetRecentRatings(ctx, limit)
	if err != nil {
		s.logger.Error("Failed to get recent ratings", "error", err)
		return nil, err
	}

	// 转换响应
	ratingResponses := make([]*RatingResponse, len(ratings))
	for i, rating := range ratings {
		ratingResponses[i] = s.convertRatingToResponse(rating)
	}

	response := &RatingListResponse{
		Ratings:    ratingResponses,
		Total:      int64(len(ratingResponses)),
		Page:       1,
		PageSize:   limit,
		TotalPages: 1,
	}

	// 缓存结果
	if s.cache.IsEnabled() {
		if err := s.cache.Set(ctx, cacheKey, response, 5*time.Minute); err != nil {
			s.logger.Error("Failed to cache recent ratings", "error", err)
		}
	}

	return response, nil
}

// CalculateMovieRating 计算电影评分
func (s *ratingService) CalculateMovieRating(ctx context.Context, movieID uint64) (*MovieRatingCalculation, error) {
	stats, err := s.ratingRepo.GetMovieRatingStats(ctx, movieID)
	if err != nil {
		s.logger.Error("Failed to get movie rating stats for calculation", "movie_id", movieID, "error", err)
		return nil, err
	}

	// 计算加权平均分（考虑评分数量）
	weightedRating := s.calculateWeightedRating(stats.AverageRating, stats.TotalRatings)

	// 计算贝叶斯平均分
	bayesianRating := s.calculateBayesianRating(stats.AverageRating, stats.TotalRatings)

	return &MovieRatingCalculation{
		MovieID:         movieID,
		AverageRating:   stats.AverageRating,
		TotalRatings:    stats.TotalRatings,
		WeightedRating:  weightedRating,
		BayesianRating:  bayesianRating,
		CalculatedAt:    time.Now(),
	}, nil
}

// UpdateMovieRatingCache 更新电影评分缓存
func (s *ratingService) UpdateMovieRatingCache(ctx context.Context, movieID uint64) error {
	if !s.cache.IsEnabled() {
		return nil
	}

	// 删除相关缓存
	cacheKeys := []string{
		fmt.Sprintf("movie_rating_stats:%d", movieID),
		"top_rated_movies:*",
		"recent_ratings:*",
	}

	for _, key := range cacheKeys {
		if err := s.cache.Delete(ctx, key); err != nil {
			s.logger.Error("Failed to delete cache", "key", key, "error", err)
		}
	}

	// 预热缓存
	if _, err := s.GetMovieRatingStats(ctx, movieID); err != nil {
		s.logger.Error("Failed to warm up movie rating stats cache", "movie_id", movieID, "error", err)
		return err
	}

	s.logger.Debug("Movie rating cache updated", "movie_id", movieID)
	return nil
}

// BatchUpdateMovieRatings 批量更新电影评分
func (s *ratingService) BatchUpdateMovieRatings(ctx context.Context, movieIDs []uint64) error {
	if err := s.ratingRepo.BatchUpdateMovieRatings(ctx, movieIDs); err != nil {
		s.logger.Error("Failed to batch update movie ratings", "error", err)
		return err
	}

	// 批量更新缓存
	for _, movieID := range movieIDs {
		if err := s.UpdateMovieRatingCache(ctx, movieID); err != nil {
			s.logger.Error("Failed to update movie rating cache in batch", "movie_id", movieID, "error", err)
		}
	}

	s.logger.Info("Batch updated movie ratings", "count", len(movieIDs))
	return nil
}

// 辅助方法

// validateCreateRatingRequest 验证创建评分请求
func (s *ratingService) validateCreateRatingRequest(req *CreateRatingRequest) error {
	if req.UserID == 0 {
		return models.ErrInvalidUserID
	}
	if req.MovieID == 0 {
		return models.ErrInvalidMovieID
	}
	if req.Score < 1 || req.Score > 5 {
		return models.ErrInvalidRating
	}
	return nil
}

// validateUpdateRatingRequest 验证更新评分请求
func (s *ratingService) validateUpdateRatingRequest(req *UpdateRatingRequest) error {
	if req.Score != nil && (*req.Score < 1 || *req.Score > 5) {
		return models.ErrInvalidRating
	}
	return nil
}

// convertRatingToResponse 转换评分为响应格式
func (s *ratingService) convertRatingToResponse(rating *models.Rating) *RatingResponse {
	response := &RatingResponse{
		ID:        rating.ID,
		UserID:    rating.UserID,
		MovieID:   rating.MovieID,
		Score:     rating.Score,
		Comment:   rating.Comment,
		CreatedAt: rating.CreatedAt,
		UpdatedAt: rating.UpdatedAt,
	}

	if rating.User != nil {
		response.User = &UserInfo{
			ID:       rating.User.ID,
			Username: rating.User.Username,
			Nickname: rating.User.Nickname,
			Avatar:   rating.User.Avatar,
		}
	}

	if rating.Movie != nil {
		response.Movie = &MovieInfo{
			ID:        rating.Movie.ID,
			Title:     rating.Movie.Title,
			PosterURL: rating.Movie.PosterURL,
			Year:      rating.Movie.Year,
		}
	}

	return response
}

// calculateWeightedRating 计算加权平均评分
func (s *ratingService) calculateWeightedRating(averageRating float64, totalRatings int64) float64 {
	// 使用简单的加权算法，评分数量越多权重越高
	const minRatings = 10
	weight := float64(totalRatings) / (float64(totalRatings) + minRatings)
	globalAverage := 6.0 // 全局平均分
	return weight*averageRating + (1-weight)*globalAverage
}

// calculateBayesianRating 计算贝叶斯平均评分
func (s *ratingService) calculateBayesianRating(averageRating float64, totalRatings int64) float64 {
	// 贝叶斯平均算法参数
	const (
		priorRatings = 25.0 // 先验评分数量
		priorMean    = 6.0  // 先验平均分
	)

	return (priorRatings*priorMean + float64(totalRatings)*averageRating) / (priorRatings + float64(totalRatings))
}
```

#### 2.2 创建评分服务请求响应结构体

```go
// internal/service/rating_types.go
package service

import (
	"time"

	"movieinfo/internal/models"
)

// 评分请求结构体

// CreateRatingRequest 创建评分请求
type CreateRatingRequest struct {
	UserID  uint64 `json:"user_id" validate:"required"`
	MovieID uint64 `json:"movie_id" validate:"required"`
	Score   int32  `json:"score" validate:"required,min=1,max=5"`
	Comment string `json:"comment" validate:"max=500"`
}

// UpdateRatingRequest 更新评分请求
type UpdateRatingRequest struct {
	Score   *int32  `json:"score,omitempty" validate:"omitempty,min=1,max=5"`
	Comment *string `json:"comment,omitempty" validate:"omitempty,max=500"`
}

// GetRatingListRequest 获取评分列表请求
type GetRatingListRequest struct {
	Page      int        `json:"page" validate:"min=1"`
	PageSize  int        `json:"page_size" validate:"min=1,max=100"`
	UserID    *uint64    `json:"user_id,omitempty"`
	MovieID   *uint64    `json:"movie_id,omitempty"`
	MinScore *int32   `json:"min_score,omitempty" validate:"omitempty,min=1,max=5"`
	MaxScore *int32   `json:"max_score,omitempty" validate:"omitempty,min=1,max=5"`
	StartDate *time.Time `json:"start_date,omitempty"`
	EndDate   *time.Time `json:"end_date,omitempty"`
	OrderBy   string     `json:"order_by,omitempty"`
	OrderDesc bool       `json:"order_desc,omitempty"`
}

// GetMovieRatingsRequest 获取电影评分请求
type GetMovieRatingsRequest struct {
	MovieID   uint64 `json:"movie_id" validate:"required"`
	Page      int    `json:"page" validate:"min=1"`
	PageSize  int    `json:"page_size" validate:"min=1,max=100"`
	OrderBy   string `json:"order_by,omitempty"`
	OrderDesc bool   `json:"order_desc,omitempty"`
}

// GetUserRatingsRequest 获取用户评分请求
type GetUserRatingsRequest struct {
	UserID    uint64 `json:"user_id" validate:"required"`
	Page      int    `json:"page" validate:"min=1"`
	PageSize  int    `json:"page_size" validate:"min=1,max=100"`
	OrderBy   string `json:"order_by,omitempty"`
	OrderDesc bool   `json:"order_desc,omitempty"`
}

// GetTopRatedMoviesRequest 获取评分最高电影请求
type GetTopRatedMoviesRequest struct {
	Limit      int `json:"limit" validate:"min=1,max=100"`
	MinRatings int `json:"min_ratings" validate:"min=1"`
}

// 评分响应结构体

// RatingResponse 评分响应
type RatingResponse struct {
	ID        uint64     `json:"id"`
	UserID    uint64     `json:"user_id"`
	MovieID   uint64     `json:"movie_id"`
	Score     int32      `json:"score"`
	Comment   string     `json:"comment"`
	User      *UserInfo  `json:"user,omitempty"`
	Movie     *MovieInfo `json:"movie,omitempty"`
	CreatedAt time.Time  `json:"created_at"`
	UpdatedAt time.Time  `json:"updated_at"`
}

// RatingListResponse 评分列表响应
type RatingListResponse struct {
	Ratings    []*RatingResponse `json:"ratings"`
	Total      int64             `json:"total"`
	Page       int               `json:"page"`
	PageSize   int               `json:"page_size"`
	TotalPages int64             `json:"total_pages"`
}

// MovieRatingStatsResponse 电影评分统计响应
type MovieRatingStatsResponse struct {
	MovieID       uint64  `json:"movie_id"`
	TotalRatings  int64   `json:"total_ratings"`
	AverageRating float64 `json:"average_rating"`
	Rating5       int64   `json:"rating_5"`
	Rating4       int64   `json:"rating_4"`
	Rating3       int64   `json:"rating_3"`
	Rating2       int64   `json:"rating_2"`
	Rating1       int64   `json:"rating_1"`
}

// UserRatingStatsResponse 用户评分统计响应
type UserRatingStatsResponse struct {
	UserID        uint64  `json:"user_id"`
	TotalRatings  int64   `json:"total_ratings"`
	AverageRating float64 `json:"average_rating"`
	HighestRating int32   `json:"highest_rating"`
	LowestRating  int32   `json:"lowest_rating"`
}

// TopRatedMovieResponse 评分最高电影响应
type TopRatedMovieResponse struct {
	MovieID       uint64  `json:"movie_id"`
	Title         string  `json:"title"`
	PosterURL     string  `json:"poster_url"`
	Year          int     `json:"year"`
	TotalRatings  int64   `json:"total_ratings"`
	AverageRating float64 `json:"average_rating"`
}

// TopRatedMoviesResponse 评分最高电影列表响应
type TopRatedMoviesResponse struct {
	Movies []*TopRatedMovieResponse `json:"movies"`
	Total  int64                    `json:"total"`
}

// MovieRatingCalculation 电影评分计算结果
type MovieRatingCalculation struct {
	MovieID        uint64    `json:"movie_id"`
	AverageRating  float64   `json:"average_rating"`
	TotalRatings   int64     `json:"total_ratings"`
	WeightedRating float64   `json:"weighted_rating"`
	BayesianRating float64   `json:"bayesian_rating"`
	CalculatedAt   time.Time `json:"calculated_at"`
}

// 辅助结构体

// UserInfo 用户信息
type UserInfo struct {
	ID       uint64 `json:"id"`
	Username string `json:"username"`
	Nickname string `json:"nickname"`
	Avatar   string `json:"avatar"`
}

// MovieInfo 电影信息
type MovieInfo struct {
	ID        uint64 `json:"id"`
	Title     string `json:"title"`
	PosterURL string `json:"poster_url"`
	Year      int    `json:"year"`
}
```

### 步骤3：实现评分gRPC处理器

#### 3.1 创建评分gRPC处理器

```go
// internal/handler/grpc/rating_handler.go
package grpc

import (
	"context"
	"time"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/timestamppb"
	"google.golang.org/protobuf/types/known/wrapperspb"

	movieinfopb "movieinfo/api/proto/movieinfo/v1"
	"movieinfo/internal/service"
	"movieinfo/pkg/logger"
	"movieinfo/pkg/validator"
)

// RatingHandler 评分gRPC处理器
type RatingHandler struct {
	movieinfopb.UnimplementedRatingServiceServer
	ratingService service.RatingService
	validator     validator.Validator
	logger        logger.Logger
}

// NewRatingHandler 创建评分处理器
func NewRatingHandler(
	ratingService service.RatingService,
	validator validator.Validator,
	logger logger.Logger,
) *RatingHandler {
	return &RatingHandler{
		ratingService: ratingService,
		validator:     validator,
		logger:        logger,
	}
}

// CreateRating 创建评分
func (h *RatingHandler) CreateRating(ctx context.Context, req *movieinfopb.CreateRatingRequest) (*movieinfopb.CreateRatingResponse, error) {
	// 参数验证
	if err := h.validator.ValidateStruct(req); err != nil {
		h.logger.Error("Invalid create rating request", "error", err)
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	// 转换请求
	serviceReq := &service.CreateRatingRequest{
		UserID:  req.UserId,
		MovieID: req.MovieId,
		Score:   req.Score,
		Comment: req.Comment,
	}

	// 调用服务
	rating, err := h.ratingService.CreateRating(ctx, serviceReq)
	if err != nil {
		h.logger.Error("Failed to create rating", "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	return &movieinfopb.CreateRatingResponse{
		Rating: h.convertRatingToProto(rating),
	}, nil
}

// GetRating 获取评分
func (h *RatingHandler) GetRating(ctx context.Context, req *movieinfopb.GetRatingRequest) (*movieinfopb.GetRatingResponse, error) {
	// 参数验证
	if req.Id == 0 {
		return nil, status.Error(codes.InvalidArgument, "rating id is required")
	}

	// 调用服务
	rating, err := h.ratingService.GetRating(ctx, req.Id)
	if err != nil {
		h.logger.Error("Failed to get rating", "rating_id", req.Id, "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	return &movieinfopb.GetRatingResponse{
		Rating: h.convertRatingToProto(rating),
	}, nil
}

// UpdateRating 更新评分
func (h *RatingHandler) UpdateRating(ctx context.Context, req *movieinfopb.UpdateRatingRequest) (*movieinfopb.UpdateRatingResponse, error) {
	// 参数验证
	if req.Id == 0 {
		return nil, status.Error(codes.InvalidArgument, "rating id is required")
	}

	if err := h.validator.ValidateStruct(req); err != nil {
		h.logger.Error("Invalid update rating request", "error", err)
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	// 转换请求
	serviceReq := &service.UpdateRatingRequest{}
	if req.Score != nil {
		score := req.Score.Value
		serviceReq.Score = &score
	}
	if req.Comment != nil {
		comment := req.Comment.Value
		serviceReq.Comment = &comment
	}

	// 调用服务
	rating, err := h.ratingService.UpdateRating(ctx, req.Id, serviceReq)
	if err != nil {
		h.logger.Error("Failed to update rating", "rating_id", req.Id, "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	return &movieinfopb.UpdateRatingResponse{
		Rating: h.convertRatingToProto(rating),
	}, nil
}

// DeleteRating 删除评分
func (h *RatingHandler) DeleteRating(ctx context.Context, req *movieinfopb.DeleteRatingRequest) (*movieinfopb.DeleteRatingResponse, error) {
	// 参数验证
	if req.Id == 0 {
		return nil, status.Error(codes.InvalidArgument, "rating id is required")
	}

	// 调用服务
	if err := h.ratingService.DeleteRating(ctx, req.Id); err != nil {
		h.logger.Error("Failed to delete rating", "rating_id", req.Id, "error", err)
		return nil, h.handleServiceError(err)
	}

	return &movieinfopb.DeleteRatingResponse{}, nil
}

// GetRatingList 获取评分列表
func (h *RatingHandler) GetRatingList(ctx context.Context, req *movieinfopb.GetRatingListRequest) (*movieinfopb.GetRatingListResponse, error) {
	// 参数验证
	if req.Page <= 0 {
		req.Page = 1
	}
	if req.PageSize <= 0 || req.PageSize > 100 {
		req.PageSize = 20
	}

	// 转换请求
	serviceReq := &service.GetRatingListRequest{
		Page:      int(req.Page),
		PageSize:  int(req.PageSize),
		OrderBy:   req.OrderBy,
		OrderDesc: req.OrderDesc,
	}

	if req.UserId != nil {
		userID := *req.UserId
		serviceReq.UserID = &userID
	}
	if req.MovieId != nil {
		movieID := *req.MovieId
		serviceReq.MovieID = &movieID
	}
	if req.MinScore != nil {
		minScore := *req.MinScore
		serviceReq.MinScore = &minScore
	}
	if req.MaxScore != nil {
		maxScore := *req.MaxScore
		serviceReq.MaxScore = &maxScore
	}
	if req.StartDate != nil {
		startDate := req.StartDate.AsTime()
		serviceReq.StartDate = &startDate
	}
	if req.EndDate != nil {
		endDate := req.EndDate.AsTime()
		serviceReq.EndDate = &endDate
	}

	// 调用服务
	ratingList, err := h.ratingService.GetRatingList(ctx, serviceReq)
	if err != nil {
		h.logger.Error("Failed to get rating list", "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	ratings := make([]*movieinfopb.Rating, len(ratingList.Ratings))
	for i, rating := range ratingList.Ratings {
		ratings[i] = h.convertRatingToProto(rating)
	}

	return &movieinfopb.GetRatingListResponse{
		Ratings:    ratings,
		Total:      ratingList.Total,
		Page:       int32(ratingList.Page),
		PageSize:   int32(ratingList.PageSize),
		TotalPages: int32(ratingList.TotalPages),
	}, nil
}

// GetUserRating 获取用户评分
func (h *RatingHandler) GetUserRating(ctx context.Context, req *movieinfopb.GetUserRatingRequest) (*movieinfopb.GetUserRatingResponse, error) {
	// 参数验证
	if req.UserId == 0 {
		return nil, status.Error(codes.InvalidArgument, "user id is required")
	}
	if req.MovieId == 0 {
		return nil, status.Error(codes.InvalidArgument, "movie id is required")
	}

	// 调用服务
	rating, err := h.ratingService.GetUserRating(ctx, req.UserId, req.MovieId)
	if err != nil {
		h.logger.Error("Failed to get user rating", "user_id", req.UserId, "movie_id", req.MovieId, "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	return &movieinfopb.GetUserRatingResponse{
		Rating: h.convertRatingToProto(rating),
	}, nil
}

// GetMovieRatings 获取电影评分列表
func (h *RatingHandler) GetMovieRatings(ctx context.Context, req *movieinfopb.GetMovieRatingsRequest) (*movieinfopb.GetMovieRatingsResponse, error) {
	// 参数验证
	if req.MovieId == 0 {
		return nil, status.Error(codes.InvalidArgument, "movie id is required")
	}
	if req.Page <= 0 {
		req.Page = 1
	}
	if req.PageSize <= 0 || req.PageSize > 100 {
		req.PageSize = 20
	}

	// 转换请求
	serviceReq := &service.GetMovieRatingsRequest{
		MovieID:   req.MovieId,
		Page:      int(req.Page),
		PageSize:  int(req.PageSize),
		OrderBy:   req.OrderBy,
		OrderDesc: req.OrderDesc,
	}

	// 调用服务
	ratingList, err := h.ratingService.GetMovieRatings(ctx, serviceReq)
	if err != nil {
		h.logger.Error("Failed to get movie ratings", "movie_id", req.MovieId, "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	ratings := make([]*movieinfopb.Rating, len(ratingList.Ratings))
	for i, rating := range ratingList.Ratings {
		ratings[i] = h.convertRatingToProto(rating)
	}

	return &movieinfopb.GetMovieRatingsResponse{
		Ratings:    ratings,
		Total:      ratingList.Total,
		Page:       int32(ratingList.Page),
		PageSize:   int32(ratingList.PageSize),
		TotalPages: int32(ratingList.TotalPages),
	}, nil
}

// GetUserRatings 获取用户评分列表
func (h *RatingHandler) GetUserRatings(ctx context.Context, req *movieinfopb.GetUserRatingsRequest) (*movieinfopb.GetUserRatingsResponse, error) {
	// 参数验证
	if req.UserId == 0 {
		return nil, status.Error(codes.InvalidArgument, "user id is required")
	}
	if req.Page <= 0 {
		req.Page = 1
	}
	if req.PageSize <= 0 || req.PageSize > 100 {
		req.PageSize = 20
	}

	// 转换请求
	serviceReq := &service.GetUserRatingsRequest{
		UserID:    req.UserId,
		Page:      int(req.Page),
		PageSize:  int(req.PageSize),
		OrderBy:   req.OrderBy,
		OrderDesc: req.OrderDesc,
	}

	// 调用服务
	ratingList, err := h.ratingService.GetUserRatings(ctx, serviceReq)
	if err != nil {
		h.logger.Error("Failed to get user ratings", "user_id", req.UserId, "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	ratings := make([]*movieinfopb.Rating, len(ratingList.Ratings))
	for i, rating := range ratingList.Ratings {
		ratings[i] = h.convertRatingToProto(rating)
	}

	return &movieinfopb.GetUserRatingsResponse{
		Ratings:    ratings,
		Total:      ratingList.Total,
		Page:       int32(ratingList.Page),
		PageSize:   int32(ratingList.PageSize),
		TotalPages: int32(ratingList.TotalPages),
	}, nil
}

// GetMovieRatingStats 获取电影评分统计
func (h *RatingHandler) GetMovieRatingStats(ctx context.Context, req *movieinfopb.GetMovieRatingStatsRequest) (*movieinfopb.GetMovieRatingStatsResponse, error) {
	// 参数验证
	if req.MovieId == 0 {
		return nil, status.Error(codes.InvalidArgument, "movie id is required")
	}

	// 调用服务
	stats, err := h.ratingService.GetMovieRatingStats(ctx, req.MovieId)
	if err != nil {
		h.logger.Error("Failed to get movie rating stats", "movie_id", req.MovieId, "error", err)
		return nil, h.handleServiceError(err)
	}

	return &movieinfopb.GetMovieRatingStatsResponse{
		MovieId:       stats.MovieID,
		TotalRatings:  stats.TotalRatings,
		AverageRating: stats.AverageRating,
		Rating_9To10:  stats.Rating9To10,
		Rating_7To8:   stats.Rating7To8,
		Rating_5To6:   stats.Rating5To6,
		Rating_3To4:   stats.Rating3To4,
		Rating_1To2:   stats.Rating1To2,
	}, nil
}

// GetUserRatingStats 获取用户评分统计
func (h *RatingHandler) GetUserRatingStats(ctx context.Context, req *movieinfopb.GetUserRatingStatsRequest) (*movieinfopb.GetUserRatingStatsResponse, error) {
	// 参数验证
	if req.UserId == 0 {
		return nil, status.Error(codes.InvalidArgument, "user id is required")
	}

	// 调用服务
	stats, err := h.ratingService.GetUserRatingStats(ctx, req.UserId)
	if err != nil {
		h.logger.Error("Failed to get user rating stats", "user_id", req.UserId, "error", err)
		return nil, h.handleServiceError(err)
	}

	return &movieinfopb.GetUserRatingStatsResponse{
		UserId:        stats.UserID,
		TotalRatings:  stats.TotalRatings,
		AverageRating: stats.AverageRating,
		HighestRating: stats.HighestRating,
		LowestRating:  stats.LowestRating,
	}, nil
}

// GetTopRatedMovies 获取评分最高的电影
func (h *RatingHandler) GetTopRatedMovies(ctx context.Context, req *movieinfopb.GetTopRatedMoviesRequest) (*movieinfopb.GetTopRatedMoviesResponse, error) {
	// 参数验证
	if req.Limit <= 0 || req.Limit > 100 {
		req.Limit = 20
	}
	if req.MinRatings <= 0 {
		req.MinRatings = 10
	}

	// 转换请求
	serviceReq := &service.GetTopRatedMoviesRequest{
		Limit:      int(req.Limit),
		MinRatings: int(req.MinRatings),
	}

	// 调用服务
	topMovies, err := h.ratingService.GetTopRatedMovies(ctx, serviceReq)
	if err != nil {
		h.logger.Error("Failed to get top rated movies", "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	movies := make([]*movieinfopb.TopRatedMovie, len(topMovies.Movies))
	for i, movie := range topMovies.Movies {
		movies[i] = &movieinfopb.TopRatedMovie{
			MovieId:       movie.MovieID,
			Title:         movie.Title,
			PosterUrl:     movie.PosterURL,
			Year:          int32(movie.Year),
			TotalRatings:  movie.TotalRatings,
			AverageRating: movie.AverageRating,
		}
	}

	return &movieinfopb.GetTopRatedMoviesResponse{
		Movies: movies,
		Total:  topMovies.Total,
	}, nil
}

// GetRecentRatings 获取最近评分
func (h *RatingHandler) GetRecentRatings(ctx context.Context, req *movieinfopb.GetRecentRatingsRequest) (*movieinfopb.GetRecentRatingsResponse, error) {
	// 参数验证
	if req.Limit <= 0 || req.Limit > 100 {
		req.Limit = 20
	}

	// 调用服务
	ratingList, err := h.ratingService.GetRecentRatings(ctx, int(req.Limit))
	if err != nil {
		h.logger.Error("Failed to get recent ratings", "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	ratings := make([]*movieinfopb.Rating, len(ratingList.Ratings))
	for i, rating := range ratingList.Ratings {
		ratings[i] = h.convertRatingToProto(rating)
	}

	return &movieinfopb.GetRecentRatingsResponse{
		Ratings: ratings,
		Total:   ratingList.Total,
	}, nil
}

// convertRatingToProto 转换评分为Proto格式
func (h *RatingHandler) convertRatingToProto(rating *service.RatingResponse) *movieinfopb.Rating {
	protoRating := &movieinfopb.Rating{
		Id:        rating.ID,
		UserId:    rating.UserID,
		MovieId:   rating.MovieID,
		Rating:    rating.Rating,
		Comment:   rating.Comment,
		CreatedAt: timestamppb.New(rating.CreatedAt),
		UpdatedAt: timestamppb.New(rating.UpdatedAt),
	}

	if rating.User != nil {
		protoRating.User = &movieinfopb.UserInfo{
			Id:       rating.User.ID,
			Username: rating.User.Username,
			Nickname: rating.User.Nickname,
			Avatar:   rating.User.Avatar,
		}
	}

	if rating.Movie != nil {
		protoRating.Movie = &movieinfopb.MovieInfo{
			Id:        rating.Movie.ID,
			Title:     rating.Movie.Title,
			PosterUrl: rating.Movie.PosterURL,
			Year:      int32(rating.Movie.Year),
		}
	}

	return protoRating
}

// handleServiceError 处理服务错误
func (h *RatingHandler) handleServiceError(err error) error {
	// 根据错误类型返回相应的gRPC状态码
	switch err {
	case models.ErrRatingNotFound:
		return status.Error(codes.NotFound, "rating not found")
	case models.ErrRatingAlreadyExists:
		return status.Error(codes.AlreadyExists, "rating already exists")
	case models.ErrUserNotFound:
		return status.Error(codes.NotFound, "user not found")
	case models.ErrMovieNotFound:
		return status.Error(codes.NotFound, "movie not found")
	case models.ErrInvalidRating:
		return status.Error(codes.InvalidArgument, "invalid rating value")
	default:
		return status.Error(codes.Internal, "internal server error")
	}
}
```

### 步骤4：配置文件

#### 4.1 评分服务配置

```yaml
# configs/rating.yaml
rating:
  # 评分范围
  min_rating: 1.0
  max_rating: 10.0
  
  # 评分精度
  rating_precision: 1  # 小数点后位数
  
  # 评分统计
  stats:
    # 最小评分数量（用于计算平均分）
    min_ratings_for_average: 5
    # 贝叶斯平均参数
    bayesian_prior_rating: 6.0
    bayesian_prior_count: 10
    
  # 缓存配置
  cache:
    # 电影评分统计缓存时间（秒）
    movie_stats_ttl: 3600
    # 用户评分统计缓存时间（秒）
    user_stats_ttl: 1800
    # 热门电影缓存时间（秒）
    top_movies_ttl: 7200
    
  # 限制配置
  limits:
    # 每页最大评分数量
    max_page_size: 100
    # 热门电影最大数量
    max_top_movies: 100
    # 最近评分最大数量
    max_recent_ratings: 100
    
  # 评分验证
  validation:
    # 评论最大长度
    max_comment_length: 1000
    # 是否允许重复评分
    allow_duplicate_rating: false
```

### 步骤5：模块初始化

#### 5.1 评分模块初始化

```go
// internal/rating/init.go
package rating

import (
	"context"
	"database/sql"
	"time"

	"github.com/go-redis/redis/v8"
	"go.uber.org/zap"

	"movieinfo/internal/handler/grpc"
	"movieinfo/internal/repository"
	"movieinfo/internal/service"
	"movieinfo/pkg/cache"
	"movieinfo/pkg/config"
	"movieinfo/pkg/logger"
	"movieinfo/pkg/validator"
)

// RatingModule 评分模块
type RatingModule struct {
	Repo    repository.RatingRepository
	Service service.RatingService
	Handler *grpc.RatingHandler
}

// InitRatingModule 初始化评分模块
func InitRatingModule(
	ctx context.Context,
	db *sql.DB,
	rdb *redis.Client,
	cfg *config.Config,
	logger logger.Logger,
	validator validator.Validator,
) (*RatingModule, error) {
	// 创建缓存
	cacheClient := cache.NewRedisCache(rdb, logger)

	// 创建仓储
	ratingRepo := repository.NewRatingRepository(db, cacheClient, logger)

	// 创建服务
	ratingService := service.NewRatingService(
		ratingRepo,
		cacheClient,
		logger,
		cfg,
	)

	// 创建处理器
	ratingHandler := grpc.NewRatingHandler(
		ratingService,
		validator,
		logger,
	)

	return &RatingModule{
		Repo:    ratingRepo,
		Service: ratingService,
		Handler: ratingHandler,
	}, nil
}

// Start 启动评分模块
func (m *RatingModule) Start(ctx context.Context) error {
	// 启动后台任务
	go m.startBackgroundTasks(ctx)

	return nil
}

// Stop 停止评分模块
func (m *RatingModule) Stop(ctx context.Context) error {
	// 清理资源
	return nil
}

// startBackgroundTasks 启动后台任务
func (m *RatingModule) startBackgroundTasks(ctx context.Context) {
	// 定期更新评分统计
	ticker := time.NewTicker(time.Hour)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			m.updateRatingStats(ctx)
		}
	}
}

// updateRatingStats 更新评分统计
func (m *RatingModule) updateRatingStats(ctx context.Context) {
	// 更新电影评分统计
	if err := m.Service.UpdateMovieRatingStats(ctx); err != nil {
		// 记录错误日志
	}

	// 更新用户评分统计
	if err := m.Service.UpdateUserRatingStats(ctx); err != nil {
		// 记录错误日志
	}
}
```

## 测试验证

### 1. 评分仓储测试

```go
// internal/repository/rating_repository_test.go
package repository

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"movieinfo/internal/models"
	"movieinfo/pkg/testutil"
)

func TestRatingRepository_CreateRating(t *testing.T) {
	// 设置测试环境
	db, cleanup := testutil.SetupTestDB(t)
	defer cleanup()

	cache := testutil.SetupTestCache(t)
	logger := testutil.SetupTestLogger(t)

	repo := NewRatingRepository(db, cache, logger)

	// 测试数据
	rating := &models.Rating{
		UserID:  1,
		MovieID: 1,
		Rating:  8.5,
		Comment: "Great movie!",
	}

	// 执行测试
	ctx := context.Background()
	createdRating, err := repo.CreateRating(ctx, rating)

	// 验证结果
	require.NoError(t, err)
	assert.NotZero(t, createdRating.ID)
	assert.Equal(t, rating.UserID, createdRating.UserID)
	assert.Equal(t, rating.MovieID, createdRating.MovieID)
	assert.Equal(t, rating.Rating, createdRating.Rating)
	assert.Equal(t, rating.Comment, createdRating.Comment)
	assert.NotZero(t, createdRating.CreatedAt)
	assert.NotZero(t, createdRating.UpdatedAt)
}

func TestRatingRepository_GetRating(t *testing.T) {
	// 设置测试环境
	db, cleanup := testutil.SetupTestDB(t)
	defer cleanup()

	cache := testutil.SetupTestCache(t)
	logger := testutil.SetupTestLogger(t)

	repo := NewRatingRepository(db, cache, logger)

	// 创建测试数据
	rating := &models.Rating{
		UserID:  1,
		MovieID: 1,
		Rating:  8.5,
		Comment: "Great movie!",
	}

	ctx := context.Background()
	createdRating, err := repo.CreateRating(ctx, rating)
	require.NoError(t, err)

	// 执行测试
	foundRating, err := repo.GetRating(ctx, createdRating.ID)

	// 验证结果
	require.NoError(t, err)
	assert.Equal(t, createdRating.ID, foundRating.ID)
	assert.Equal(t, createdRating.UserID, foundRating.UserID)
	assert.Equal(t, createdRating.MovieID, foundRating.MovieID)
	assert.Equal(t, createdRating.Rating, foundRating.Rating)
	assert.Equal(t, createdRating.Comment, foundRating.Comment)
}

func TestRatingRepository_GetMovieRatingStats(t *testing.T) {
	// 设置测试环境
	db, cleanup := testutil.SetupTestDB(t)
	defer cleanup()

	cache := testutil.SetupTestCache(t)
	logger := testutil.SetupTestLogger(t)

	repo := NewRatingRepository(db, cache, logger)

	// 创建测试数据
	movieID := uint64(1)
	ratings := []*models.Rating{
		{UserID: 1, MovieID: movieID, Rating: 8.0},
		{UserID: 2, MovieID: movieID, Rating: 9.0},
		{UserID: 3, MovieID: movieID, Rating: 7.5},
		{UserID: 4, MovieID: movieID, Rating: 8.5},
		{UserID: 5, MovieID: movieID, Rating: 9.5},
	}

	ctx := context.Background()
	for _, rating := range ratings {
		_, err := repo.CreateRating(ctx, rating)
		require.NoError(t, err)
	}

	// 执行测试
	stats, err := repo.GetMovieRatingStats(ctx, movieID)

	// 验证结果
	require.NoError(t, err)
	assert.Equal(t, movieID, stats.MovieID)
	assert.Equal(t, int64(5), stats.TotalRatings)
	assert.InDelta(t, 8.5, stats.AverageRating, 0.1)
	assert.Equal(t, int64(1), stats.Rating9To10)
	assert.Equal(t, int64(3), stats.Rating7To8)
}
```

### 2. 评分服务测试

```go
// internal/service/rating_service_test.go
package service

import (
	"context"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"movieinfo/internal/models"
	"movieinfo/internal/repository/mocks"
	"movieinfo/pkg/testutil"
)

func TestRatingService_CreateRating(t *testing.T) {
	// 设置测试环境
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockRepo := mocks.NewMockRatingRepository(ctrl)
	mockCache := testutil.SetupTestCache(t)
	logger := testutil.SetupTestLogger(t)
	cfg := testutil.SetupTestConfig(t)

	service := NewRatingService(mockRepo, mockCache, logger, cfg)

	// 设置期望
	req := &CreateRatingRequest{
		UserID:  1,
		MovieID: 1,
		Rating:  8.5,
		Comment: "Great movie!",
	}

	expectedRating := &models.Rating{
		ID:      1,
		UserID:  req.UserID,
		MovieID: req.MovieID,
		Rating:  req.Rating,
		Comment: req.Comment,
	}

	mockRepo.EXPECT().
		GetUserRating(gomock.Any(), req.UserID, req.MovieID).
		Return(nil, models.ErrRatingNotFound)

	mockRepo.EXPECT().
		CreateRating(gomock.Any(), gomock.Any()).
		Return(expectedRating, nil)

	// 执行测试
	ctx := context.Background()
	result, err := service.CreateRating(ctx, req)

	// 验证结果
	require.NoError(t, err)
	assert.Equal(t, expectedRating.ID, result.ID)
	assert.Equal(t, expectedRating.UserID, result.UserID)
	assert.Equal(t, expectedRating.MovieID, result.MovieID)
	assert.Equal(t, expectedRating.Rating, result.Rating)
	assert.Equal(t, expectedRating.Comment, result.Comment)
}

func TestRatingService_CalculateWeightedAverage(t *testing.T) {
	// 设置测试环境
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockRepo := mocks.NewMockRatingRepository(ctrl)
	mockCache := testutil.SetupTestCache(t)
	logger := testutil.SetupTestLogger(t)
	cfg := testutil.SetupTestConfig(t)

	service := NewRatingService(mockRepo, mockCache, logger, cfg)

	// 测试数据
	tests := []struct {
		name           string
		totalRatings   int64
		averageRating  float64
		expectedResult float64
	}{
		{
			name:           "少量评分",
			totalRatings:   5,
			averageRating:  8.0,
			expectedResult: 6.67, // 近似值
		},
		{
			name:           "大量评分",
			totalRatings:   100,
			averageRating:  8.0,
			expectedResult: 7.91, // 近似值
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := service.CalculateWeightedAverage(tt.totalRatings, tt.averageRating)
			assert.InDelta(t, tt.expectedResult, result, 0.1)
		})
	}
}
```

### 3. 集成测试

```go
// test/integration/rating_test.go
package integration

import (
	"context"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc"

	movieinfopb "movieinfo/api/proto/movieinfo/v1"
	"movieinfo/pkg/testutil"
)

func TestRatingIntegration(t *testing.T) {
	// 设置测试环境
	server, cleanup := testutil.SetupTestServer(t)
	defer cleanup()

	conn, err := grpc.Dial(server.Address(), grpc.WithInsecure())
	require.NoError(t, err)
	defer conn.Close()

	client := movieinfopb.NewRatingServiceClient(conn)

	// 测试创建评分
	t.Run("CreateRating", func(t *testing.T) {
		req := &movieinfopb.CreateRatingRequest{
			UserId:  1,
			MovieId: 1,
			Rating:  8.5,
			Comment: "Great movie!",
		}

		resp, err := client.CreateRating(context.Background(), req)
		require.NoError(t, err)
		assert.NotNil(t, resp.Rating)
		assert.NotZero(t, resp.Rating.Id)
		assert.Equal(t, req.UserId, resp.Rating.UserId)
		assert.Equal(t, req.MovieId, resp.Rating.MovieId)
		assert.Equal(t, req.Rating, resp.Rating.Rating)
		assert.Equal(t, req.Comment, resp.Rating.Comment)
	})

	// 测试获取评分
	t.Run("GetRating", func(t *testing.T) {
		// 先创建评分
		createReq := &movieinfopb.CreateRatingRequest{
			UserId:  2,
			MovieId: 2,
			Rating:  9.0,
			Comment: "Excellent!",
		}

		createResp, err := client.CreateRating(context.Background(), createReq)
		require.NoError(t, err)

		// 获取评分
		getReq := &movieinfopb.GetRatingRequest{
			Id: createResp.Rating.Id,
		}

		getResp, err := client.GetRating(context.Background(), getReq)
		require.NoError(t, err)
		assert.Equal(t, createResp.Rating.Id, getResp.Rating.Id)
		assert.Equal(t, createResp.Rating.UserId, getResp.Rating.UserId)
		assert.Equal(t, createResp.Rating.MovieId, getResp.Rating.MovieId)
		assert.Equal(t, createResp.Rating.Rating, getResp.Rating.Rating)
		assert.Equal(t, createResp.Rating.Comment, getResp.Rating.Comment)
	})

	// 测试获取电影评分统计
	t.Run("GetMovieRatingStats", func(t *testing.T) {
		movieID := uint64(3)

		// 创建多个评分
		ratings := []float64{8.0, 9.0, 7.5, 8.5, 9.5}
		for i, rating := range ratings {
			createReq := &movieinfopb.CreateRatingRequest{
				UserId:  uint64(i + 10),
				MovieId: movieID,
				Rating:  rating,
				Comment: "Test comment",
			}

			_, err := client.CreateRating(context.Background(), createReq)
			require.NoError(t, err)
		}

		// 获取统计
		statsReq := &movieinfopb.GetMovieRatingStatsRequest{
			MovieId: movieID,
		}

		statsResp, err := client.GetMovieRatingStats(context.Background(), statsReq)
		require.NoError(t, err)
		assert.Equal(t, movieID, statsResp.MovieId)
		assert.Equal(t, int64(5), statsResp.TotalRatings)
		assert.InDelta(t, 8.5, statsResp.AverageRating, 0.1)
	})
}
```

## 预期结果

### 1. 功能完整性
- ✅ 评分CRUD操作
- ✅ 评分列表查询和过滤
- ✅ 评分统计和分析
- ✅ 缓存优化
- ✅ 错误处理

### 2. 性能指标
- 评分创建响应时间 < 100ms
- 评分查询响应时间 < 50ms
- 统计查询响应时间 < 200ms
- 缓存命中率 > 80%

### 3. 数据一致性
- 评分数据准确性
- 统计数据实时性
- 缓存数据一致性

## 注意事项

### 1. 安全性
- 用户权限验证
- 评分数据验证
- SQL注入防护
- 敏感信息保护

### 2. 性能优化
- 数据库索引优化
- 查询语句优化
- 缓存策略优化
- 分页查询优化

### 3. 维护性
- 代码结构清晰
- 错误处理完善
- 日志记录详细
- 测试覆盖全面

## 下一步骤

完成评分服务开发后，下一步将进行：

1. **推荐服务开发** - 实现个性化推荐功能
2. **网关服务开发** - 统一API入口和路由
3. **部署与运维** - 容器化部署和监控
4. **性能测试** - 压力测试和性能调优
5. **文档完善** - API文档和用户手册