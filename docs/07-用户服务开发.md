# 07-用户服务开发

## 目标说明

本步骤将实现 MovieInfo 项目的用户服务，包括用户数据访问层（Repository）、业务逻辑层（Service）、gRPC 服务层以及用户认证授权功能。用户服务是整个系统的核心模块之一，负责处理用户注册、登录、个人信息管理、权限控制等功能。

## 前置条件

在开始本步骤之前，请确保已完成：

1. ✅ 项目初始化（01-项目初始化.md）
2. ✅ 数据库设计（02-数据库设计.md）
3. ✅ 配置管理系统（03-配置管理系统.md）
4. ✅ 日志系统（04-日志系统.md）
5. ✅ gRPC协议定义（05-gRPC协议定义.md）
6. ✅ 数据模型层（06-数据模型层.md）

## 技术要点

### 设计原则

1. **分层架构**：Repository -> Service -> gRPC Handler
2. **依赖注入**：通过接口实现松耦合
3. **错误处理**：统一的错误处理和返回
4. **安全性**：密码加密、JWT认证、权限控制
5. **缓存策略**：合理使用缓存提升性能
6. **事务管理**：确保数据一致性

### 技术选型

1. **数据访问层**：GORM + MySQL
2. **缓存层**：Redis
3. **认证授权**：JWT + bcrypt
4. **参数验证**：validator
5. **测试框架**：testify
6. **Mock工具**：gomock

### 架构设计

```
┌─────────────────┐
│   gRPC Handler  │  ← 处理gRPC请求
└─────────────────┘
         │
┌─────────────────┐
│   Service Layer │  ← 业务逻辑处理
└─────────────────┘
         │
┌─────────────────┐
│Repository Layer │  ← 数据访问层
└─────────────────┘
         │
┌─────────────────┐
│   Data Layer    │  ← 数据库+缓存
└─────────────────┘
```

## 实现步骤

### 步骤1：实现用户仓储层（Repository）

#### 1.1 创建用户仓储实现

```go
// internal/repository/user_repository.go
package repository

import (
	"context"
	"fmt"
	"time"

	"gorm.io/gorm"

	"movieinfo/internal/models"
	"movieinfo/pkg/logger"
)

// userRepository 用户仓储实现
type userRepository struct {
	db     *gorm.DB
	cache  models.CacheManager
	logger logger.Logger
}

// NewUserRepository 创建用户仓储
func NewUserRepository(db *gorm.DB, cache models.CacheManager, logger logger.Logger) models.UserRepository {
	return &userRepository{
		db:     db,
		cache:  cache,
		logger: logger,
	}
}

// Create 创建用户
func (r *userRepository) Create(ctx context.Context, user *models.User) error {
	if err := r.db.WithContext(ctx).Create(user).Error; err != nil {
		r.logger.Error("Failed to create user", "error", err, "username", user.Username)
		return fmt.Errorf("failed to create user: %w", err)
	}

	// 清除相关缓存
	r.invalidateUserCache(ctx, user.ID, user.Username, user.Email)

	r.logger.Info("User created successfully", "user_id", user.ID, "username", user.Username)
	return nil
}

// GetByID 根据ID获取用户
func (r *userRepository) GetByID(ctx context.Context, id uint64) (*models.User, error) {
	// 尝试从缓存获取
	cacheKey := fmt.Sprintf("user:id:%d", id)
	var user models.User
	if r.cache.IsEnabled() {
		if err := r.cache.Get(ctx, cacheKey, &user); err == nil {
			return &user, nil
		}
	}

	// 从数据库获取
	if err := r.db.WithContext(ctx).First(&user, id).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, models.ErrUserNotFound
		}
		r.logger.Error("Failed to get user by ID", "error", err, "user_id", id)
		return nil, fmt.Errorf("failed to get user by ID: %w", err)
	}

	// 缓存结果
	if r.cache.IsEnabled() {
		r.cache.Set(ctx, cacheKey, &user, time.Hour)
	}

	return &user, nil
}

// GetByUsername 根据用户名获取用户
func (r *userRepository) GetByUsername(ctx context.Context, username string) (*models.User, error) {
	// 尝试从缓存获取
	cacheKey := fmt.Sprintf("user:username:%s", username)
	var user models.User
	if r.cache.IsEnabled() {
		if err := r.cache.Get(ctx, cacheKey, &user); err == nil {
			return &user, nil
		}
	}

	// 从数据库获取
	if err := r.db.WithContext(ctx).Where("username = ?", username).First(&user).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, models.ErrUserNotFound
		}
		r.logger.Error("Failed to get user by username", "error", err, "username", username)
		return nil, fmt.Errorf("failed to get user by username: %w", err)
	}

	// 缓存结果
	if r.cache.IsEnabled() {
		r.cache.Set(ctx, cacheKey, &user, time.Hour)
	}

	return &user, nil
}

// GetByEmail 根据邮箱获取用户
func (r *userRepository) GetByEmail(ctx context.Context, email string) (*models.User, error) {
	// 尝试从缓存获取
	cacheKey := fmt.Sprintf("user:email:%s", email)
	var user models.User
	if r.cache.IsEnabled() {
		if err := r.cache.Get(ctx, cacheKey, &user); err == nil {
			return &user, nil
		}
	}

	// 从数据库获取
	if err := r.db.WithContext(ctx).Where("email = ?", email).First(&user).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, models.ErrUserNotFound
		}
		r.logger.Error("Failed to get user by email", "error", err, "email", email)
		return nil, fmt.Errorf("failed to get user by email: %w", err)
	}

	// 缓存结果
	if r.cache.IsEnabled() {
		r.cache.Set(ctx, cacheKey, &user, time.Hour)
	}

	return &user, nil
}

// Update 更新用户
func (r *userRepository) Update(ctx context.Context, user *models.User) error {
	if err := r.db.WithContext(ctx).Save(user).Error; err != nil {
		r.logger.Error("Failed to update user", "error", err, "user_id", user.ID)
		return fmt.Errorf("failed to update user: %w", err)
	}

	// 清除相关缓存
	r.invalidateUserCache(ctx, user.ID, user.Username, user.Email)

	r.logger.Info("User updated successfully", "user_id", user.ID)
	return nil
}

// Delete 删除用户（软删除）
func (r *userRepository) Delete(ctx context.Context, id uint64) error {
	// 获取用户信息用于清除缓存
	user, err := r.GetByID(ctx, id)
	if err != nil {
		return err
	}

	if err := r.db.WithContext(ctx).Delete(&models.User{}, id).Error; err != nil {
		r.logger.Error("Failed to delete user", "error", err, "user_id", id)
		return fmt.Errorf("failed to delete user: %w", err)
	}

	// 清除相关缓存
	r.invalidateUserCache(ctx, user.ID, user.Username, user.Email)

	r.logger.Info("User deleted successfully", "user_id", id)
	return nil
}

// List 获取用户列表
func (r *userRepository) List(ctx context.Context, params *models.UserQueryParams) ([]*models.User, error) {
	query := r.db.WithContext(ctx).Model(&models.User{})

	// 应用过滤条件
	if params.Status != nil {
		query = query.Where("status = ?", *params.Status)
	}
	if params.IsVerified != nil {
		query = query.Where("is_verified = ?", *params.IsVerified)
	}
	if params.CreatedAfter != nil {
		query = query.Where("created_at >= ?", *params.CreatedAfter)
	}
	if params.CreatedBefore != nil {
		query = query.Where("created_at <= ?", *params.CreatedBefore)
	}
	if params.Search != "" {
		query = query.Where("username LIKE ? OR email LIKE ? OR nickname LIKE ?",
			"%"+params.Search+"%", "%"+params.Search+"%", "%"+params.Search+"%")
	}

	// 应用排序
	if params.OrderBy != "" {
		order := params.OrderBy
		if params.OrderDesc {
			order += " DESC"
		}
		query = query.Order(order)
	} else {
		query = query.Order("created_at DESC")
	}

	// 应用分页
	if params.Limit > 0 {
		query = query.Limit(params.Limit)
	}
	if params.Offset > 0 {
		query = query.Offset(params.Offset)
	}

	var users []*models.User
	if err := query.Find(&users).Error; err != nil {
		r.logger.Error("Failed to list users", "error", err)
		return nil, fmt.Errorf("failed to list users: %w", err)
	}

	return users, nil
}

// Count 统计用户数量
func (r *userRepository) Count(ctx context.Context, params *models.UserQueryParams) (int64, error) {
	query := r.db.WithContext(ctx).Model(&models.User{})

	// 应用过滤条件（与List方法相同）
	if params.Status != nil {
		query = query.Where("status = ?", *params.Status)
	}
	if params.IsVerified != nil {
		query = query.Where("is_verified = ?", *params.IsVerified)
	}
	if params.CreatedAfter != nil {
		query = query.Where("created_at >= ?", *params.CreatedAfter)
	}
	if params.CreatedBefore != nil {
		query = query.Where("created_at <= ?", *params.CreatedBefore)
	}
	if params.Search != "" {
		query = query.Where("username LIKE ? OR email LIKE ? OR nickname LIKE ?",
			"%"+params.Search+"%", "%"+params.Search+"%", "%"+params.Search+"%")
	}

	var count int64
	if err := query.Count(&count).Error; err != nil {
		r.logger.Error("Failed to count users", "error", err)
		return 0, fmt.Errorf("failed to count users: %w", err)
	}

	return count, nil
}

// ExistsByUsername 检查用户名是否存在
func (r *userRepository) ExistsByUsername(ctx context.Context, username string) (bool, error) {
	var count int64
	if err := r.db.WithContext(ctx).Model(&models.User{}).Where("username = ?", username).Count(&count).Error; err != nil {
		r.logger.Error("Failed to check username existence", "error", err, "username", username)
		return false, fmt.Errorf("failed to check username existence: %w", err)
	}
	return count > 0, nil
}

// ExistsByEmail 检查邮箱是否存在
func (r *userRepository) ExistsByEmail(ctx context.Context, email string) (bool, error) {
	var count int64
	if err := r.db.WithContext(ctx).Model(&models.User{}).Where("email = ?", email).Count(&count).Error; err != nil {
		r.logger.Error("Failed to check email existence", "error", err, "email", email)
		return false, fmt.Errorf("failed to check email existence: %w", err)
	}
	return count > 0, nil
}

// UpdateLoginInfo 更新登录信息
func (r *userRepository) UpdateLoginInfo(ctx context.Context, userID uint64, loginIP string) error {
	now := time.Now()
	if err := r.db.WithContext(ctx).Model(&models.User{}).Where("id = ?", userID).Updates(map[string]interface{}{
		"login_count":   gorm.Expr("login_count + 1"),
		"last_login_at": &now,
		"last_login_ip": loginIP,
	}).Error; err != nil {
		r.logger.Error("Failed to update login info", "error", err, "user_id", userID)
		return fmt.Errorf("failed to update login info: %w", err)
	}

	// 清除用户缓存
	r.invalidateUserCacheByID(ctx, userID)

	return nil
}

// UpdatePassword 更新密码
func (r *userRepository) UpdatePassword(ctx context.Context, userID uint64, hashedPassword string) error {
	if err := r.db.WithContext(ctx).Model(&models.User{}).Where("id = ?", userID).Update("password", hashedPassword).Error; err != nil {
		r.logger.Error("Failed to update password", "error", err, "user_id", userID)
		return fmt.Errorf("failed to update password: %w", err)
	}

	// 清除用户缓存
	r.invalidateUserCacheByID(ctx, userID)

	r.logger.Info("Password updated successfully", "user_id", userID)
	return nil
}

// UpdateStatus 更新用户状态
func (r *userRepository) UpdateStatus(ctx context.Context, userID uint64, status models.UserStatus) error {
	if err := r.db.WithContext(ctx).Model(&models.User{}).Where("id = ?", userID).Update("status", status).Error; err != nil {
		r.logger.Error("Failed to update user status", "error", err, "user_id", userID, "status", status)
		return fmt.Errorf("failed to update user status: %w", err)
	}

	// 清除用户缓存
	r.invalidateUserCacheByID(ctx, userID)

	r.logger.Info("User status updated successfully", "user_id", userID, "status", status)
	return nil
}

// VerifyUser 验证用户
func (r *userRepository) VerifyUser(ctx context.Context, userID uint64) error {
	now := time.Now()
	if err := r.db.WithContext(ctx).Model(&models.User{}).Where("id = ?", userID).Updates(map[string]interface{}{
		"is_verified": true,
		"verified_at": &now,
		"status":      models.UserStatusActive,
	}).Error; err != nil {
		r.logger.Error("Failed to verify user", "error", err, "user_id", userID)
		return fmt.Errorf("failed to verify user: %w", err)
	}

	// 清除用户缓存
	r.invalidateUserCacheByID(ctx, userID)

	r.logger.Info("User verified successfully", "user_id", userID)
	return nil
}

// GetStats 获取用户统计信息
func (r *userRepository) GetStats(ctx context.Context) (*models.UserStats, error) {
	stats := &models.UserStats{}

	// 总用户数
	if err := r.db.WithContext(ctx).Model(&models.User{}).Count(&stats.TotalUsers).Error; err != nil {
		return nil, fmt.Errorf("failed to count total users: %w", err)
	}

	// 活跃用户数
	if err := r.db.WithContext(ctx).Model(&models.User{}).Where("status = ?", models.UserStatusActive).Count(&stats.ActiveUsers).Error; err != nil {
		return nil, fmt.Errorf("failed to count active users: %w", err)
	}

	// 已验证用户数
	if err := r.db.WithContext(ctx).Model(&models.User{}).Where("is_verified = ?", true).Count(&stats.VerifiedUsers).Error; err != nil {
		return nil, fmt.Errorf("failed to count verified users: %w", err)
	}

	// 今日新增用户数
	today := time.Now().Truncate(24 * time.Hour)
	if err := r.db.WithContext(ctx).Model(&models.User{}).Where("created_at >= ?", today).Count(&stats.NewUsersToday).Error; err != nil {
		return nil, fmt.Errorf("failed to count new users today: %w", err)
	}

	// 本月新增用户数
	thisMonth := time.Date(time.Now().Year(), time.Now().Month(), 1, 0, 0, 0, 0, time.Now().Location())
	if err := r.db.WithContext(ctx).Model(&models.User{}).Where("created_at >= ?", thisMonth).Count(&stats.NewUsersThisMonth).Error; err != nil {
		return nil, fmt.Errorf("failed to count new users this month: %w", err)
	}

	return stats, nil
}

// BatchCreate 批量创建用户
func (r *userRepository) BatchCreate(ctx context.Context, users []*models.User) error {
	if len(users) == 0 {
		return nil
	}

	if err := r.db.WithContext(ctx).CreateInBatches(users, 100).Error; err != nil {
		r.logger.Error("Failed to batch create users", "error", err, "count", len(users))
		return fmt.Errorf("failed to batch create users: %w", err)
	}

	r.logger.Info("Users batch created successfully", "count", len(users))
	return nil
}

// BatchUpdate 批量更新用户
func (r *userRepository) BatchUpdate(ctx context.Context, userIDs []uint64, updates map[string]interface{}) error {
	if len(userIDs) == 0 {
		return nil
	}

	if err := r.db.WithContext(ctx).Model(&models.User{}).Where("id IN ?", userIDs).Updates(updates).Error; err != nil {
		r.logger.Error("Failed to batch update users", "error", err, "count", len(userIDs))
		return fmt.Errorf("failed to batch update users: %w", err)
	}

	// 清除相关缓存
	for _, userID := range userIDs {
		r.invalidateUserCacheByID(ctx, userID)
	}

	r.logger.Info("Users batch updated successfully", "count", len(userIDs))
	return nil
}

// BatchDelete 批量删除用户
func (r *userRepository) BatchDelete(ctx context.Context, userIDs []uint64) error {
	if len(userIDs) == 0 {
		return nil
	}

	if err := r.db.WithContext(ctx).Delete(&models.User{}, userIDs).Error; err != nil {
		r.logger.Error("Failed to batch delete users", "error", err, "count", len(userIDs))
		return fmt.Errorf("failed to batch delete users: %w", err)
	}

	// 清除相关缓存
	for _, userID := range userIDs {
		r.invalidateUserCacheByID(ctx, userID)
	}

	r.logger.Info("Users batch deleted successfully", "count", len(userIDs))
	return nil
}

// 辅助方法：清除用户缓存
func (r *userRepository) invalidateUserCache(ctx context.Context, userID uint64, username, email string) {
	if !r.cache.IsEnabled() {
		return
	}

	cacheKeys := []string{
		fmt.Sprintf("user:id:%d", userID),
		fmt.Sprintf("user:username:%s", username),
		fmt.Sprintf("user:email:%s", email),
	}

	for _, key := range cacheKeys {
		r.cache.Delete(ctx, key)
	}
}

// 辅助方法：根据ID清除用户缓存
func (r *userRepository) invalidateUserCacheByID(ctx context.Context, userID uint64) {
	if !r.cache.IsEnabled() {
		return
	}

	// 先获取用户信息
	user, err := r.GetByID(ctx, userID)
	if err != nil {
		return
	}

	r.invalidateUserCache(ctx, userID, user.Username, user.Email)
}
```

### 步骤2：实现用户业务逻辑层（Service）

#### 2.1 创建认证服务

```go
// internal/service/auth_service.go
package service

import (
	"context"
	"fmt"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"golang.org/x/crypto/bcrypt"

	"movieinfo/internal/models"
	"movieinfo/pkg/config"
	"movieinfo/pkg/logger"
)

// AuthService 认证服务接口
type AuthService interface {
	Register(ctx context.Context, req *RegisterRequest) (*AuthResponse, error)
	Login(ctx context.Context, req *LoginRequest) (*AuthResponse, error)
	RefreshToken(ctx context.Context, refreshToken string) (*AuthResponse, error)
	Logout(ctx context.Context, userID uint64, token string) error
	VerifyToken(ctx context.Context, token string) (*TokenClaims, error)
	ChangePassword(ctx context.Context, userID uint64, req *ChangePasswordRequest) error
	ResetPassword(ctx context.Context, req *ResetPasswordRequest) error
	VerifyEmail(ctx context.Context, token string) error
	ResendVerificationEmail(ctx context.Context, email string) error
}

// authService 认证服务实现
type authService struct {
	userRepo models.UserRepository
	cache    models.CacheManager
	config   *config.Config
	logger   logger.Logger
}

// NewAuthService 创建认证服务
func NewAuthService(
	userRepo models.UserRepository,
	cache models.CacheManager,
	config *config.Config,
	logger logger.Logger,
) AuthService {
	return &authService{
		userRepo: userRepo,
		cache:    cache,
		config:   config,
		logger:   logger,
	}
}

// RegisterRequest 注册请求
type RegisterRequest struct {
	Username string `json:"username" validate:"required,min=3,max=50,alphanum"`
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required,min=8,max=128"`
	Nickname string `json:"nickname" validate:"required,min=1,max=100"`
}

// LoginRequest 登录请求
type LoginRequest struct {
	Username string `json:"username" validate:"required"`
	Password string `json:"password" validate:"required"`
	LoginIP  string `json:"login_ip,omitempty"`
}

// ChangePasswordRequest 修改密码请求
type ChangePasswordRequest struct {
	OldPassword string `json:"old_password" validate:"required"`
	NewPassword string `json:"new_password" validate:"required,min=8,max=128"`
}

// ResetPasswordRequest 重置密码请求
type ResetPasswordRequest struct {
	Token       string `json:"token" validate:"required"`
	NewPassword string `json:"new_password" validate:"required,min=8,max=128"`
}

// AuthResponse 认证响应
type AuthResponse struct {
	User         *UserInfo `json:"user"`
	AccessToken  string    `json:"access_token"`
	RefreshToken string    `json:"refresh_token"`
	ExpiresIn    int64     `json:"expires_in"`
}

// UserInfo 用户信息
type UserInfo struct {
	ID         uint64           `json:"id"`
	Username   string           `json:"username"`
	Email      string           `json:"email"`
	Nickname   string           `json:"nickname"`
	Avatar     string           `json:"avatar"`
	Status     models.UserStatus `json:"status"`
	IsVerified bool             `json:"is_verified"`
	CreatedAt  time.Time        `json:"created_at"`
}

// TokenClaims JWT声明
type TokenClaims struct {
	UserID   uint64 `json:"user_id"`
	Username string `json:"username"`
	Email    string `json:"email"`
	jwt.RegisteredClaims
}

// Register 用户注册
func (s *authService) Register(ctx context.Context, req *RegisterRequest) (*AuthResponse, error) {
	// 检查用户名是否已存在
	exists, err := s.userRepo.ExistsByUsername(ctx, req.Username)
	if err != nil {
		return nil, fmt.Errorf("failed to check username existence: %w", err)
	}
	if exists {
		return nil, models.ErrUsernameExists
	}

	// 检查邮箱是否已存在
	exists, err = s.userRepo.ExistsByEmail(ctx, req.Email)
	if err != nil {
		return nil, fmt.Errorf("failed to check email existence: %w", err)
	}
	if exists {
		return nil, models.ErrEmailExists
	}

	// 创建用户
	user := &models.User{
		Username: req.Username,
		Email:    req.Email,
		Password: req.Password,
		Nickname: req.Nickname,
		Status:   models.UserStatusInactive, // 需要邮箱验证
	}

	// 加密密码
	if err := user.HashPassword(); err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	// 保存用户
	if err := s.userRepo.Create(ctx, user); err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	// 发送验证邮件
	if err := s.sendVerificationEmail(ctx, user); err != nil {
		s.logger.Error("Failed to send verification email", "error", err, "user_id", user.ID)
		// 不返回错误，允许用户稍后重新发送
	}

	// 生成令牌
	accessToken, refreshToken, expiresIn, err := s.generateTokens(user)
	if err != nil {
		return nil, fmt.Errorf("failed to generate tokens: %w", err)
	}

	s.logger.Info("User registered successfully", "user_id", user.ID, "username", user.Username)

	return &AuthResponse{
		User:         s.toUserInfo(user),
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
		ExpiresIn:    expiresIn,
	}, nil
}

// Login 用户登录
func (s *authService) Login(ctx context.Context, req *LoginRequest) (*AuthResponse, error) {
	// 获取用户（支持用户名或邮箱登录）
	var user *models.User
	var err error

	if isEmail(req.Username) {
		user, err = s.userRepo.GetByEmail(ctx, req.Username)
	} else {
		user, err = s.userRepo.GetByUsername(ctx, req.Username)
	}

	if err != nil {
		if err == models.ErrUserNotFound {
			return nil, models.ErrInvalidCredentials
		}
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	// 检查密码
	if !user.CheckPassword(req.Password) {
		s.logger.Warn("Invalid login attempt", "username", req.Username, "ip", req.LoginIP)
		return nil, models.ErrInvalidCredentials
	}

	// 检查用户状态
	if user.Status == models.UserStatusBanned {
		return nil, models.ErrUserBanned
	}
	if user.Status == models.UserStatusSuspended {
		return nil, models.ErrUserSuspended
	}

	// 更新登录信息
	if err := s.userRepo.UpdateLoginInfo(ctx, user.ID, req.LoginIP); err != nil {
		s.logger.Error("Failed to update login info", "error", err, "user_id", user.ID)
		// 不返回错误，不影响登录流程
	}

	// 生成令牌
	accessToken, refreshToken, expiresIn, err := s.generateTokens(user)
	if err != nil {
		return nil, fmt.Errorf("failed to generate tokens: %w", err)
	}

	s.logger.Info("User logged in successfully", "user_id", user.ID, "username", user.Username, "ip", req.LoginIP)

	return &AuthResponse{
		User:         s.toUserInfo(user),
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
		ExpiresIn:    expiresIn,
	}, nil
}

// RefreshToken 刷新令牌
func (s *authService) RefreshToken(ctx context.Context, refreshToken string) (*AuthResponse, error) {
	// 验证刷新令牌
	claims, err := s.verifyRefreshToken(refreshToken)
	if err != nil {
		return nil, fmt.Errorf("invalid refresh token: %w", err)
	}

	// 检查令牌是否在黑名单中
	if s.isTokenBlacklisted(ctx, refreshToken) {
		return nil, models.ErrTokenBlacklisted
	}

	// 获取用户信息
	user, err := s.userRepo.GetByID(ctx, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	// 检查用户状态
	if !user.IsActive() {
		return nil, models.ErrUserInactive
	}

	// 生成新令牌
	accessToken, newRefreshToken, expiresIn, err := s.generateTokens(user)
	if err != nil {
		return nil, fmt.Errorf("failed to generate tokens: %w", err)
	}

	// 将旧的刷新令牌加入黑名单
	s.blacklistToken(ctx, refreshToken)

	return &AuthResponse{
		User:         s.toUserInfo(user),
		AccessToken:  accessToken,
		RefreshToken: newRefreshToken,
		ExpiresIn:    expiresIn,
	}, nil
}

// Logout 用户登出
func (s *authService) Logout(ctx context.Context, userID uint64, token string) error {
	// 将令牌加入黑名单
	s.blacklistToken(ctx, token)

	s.logger.Info("User logged out successfully", "user_id", userID)
	return nil
}

// VerifyToken 验证访问令牌
func (s *authService) VerifyToken(ctx context.Context, token string) (*TokenClaims, error) {
	// 检查令牌是否在黑名单中
	if s.isTokenBlacklisted(ctx, token) {
		return nil, models.ErrTokenBlacklisted
	}

	// 解析令牌
	claims := &TokenClaims{}
	jwtToken, err := jwt.ParseWithClaims(token, claims, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return []byte(s.config.JWT.Secret), nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to parse token: %w", err)
	}

	if !jwtToken.Valid {
		return nil, models.ErrInvalidToken
	}

	return claims, nil
}

// ChangePassword 修改密码
func (s *authService) ChangePassword(ctx context.Context, userID uint64, req *ChangePasswordRequest) error {
	// 获取用户
	user, err := s.userRepo.GetByID(ctx, userID)
	if err != nil {
		return fmt.Errorf("failed to get user: %w", err)
	}

	// 验证旧密码
	if !user.CheckPassword(req.OldPassword) {
		return models.ErrInvalidCredentials
	}

	// 加密新密码
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.NewPassword), bcrypt.DefaultCost)
	if err != nil {
		return fmt.Errorf("failed to hash password: %w", err)
	}

	// 更新密码
	if err := s.userRepo.UpdatePassword(ctx, userID, string(hashedPassword)); err != nil {
		return fmt.Errorf("failed to update password: %w", err)
	}

	s.logger.Info("Password changed successfully", "user_id", userID)
	return nil
}

// ResetPassword 重置密码
func (s *authService) ResetPassword(ctx context.Context, req *ResetPasswordRequest) error {
	// 验证重置令牌
	claims, err := s.verifyResetToken(req.Token)
	if err != nil {
		return fmt.Errorf("invalid reset token: %w", err)
	}

	// 加密新密码
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.NewPassword), bcrypt.DefaultCost)
	if err != nil {
		return fmt.Errorf("failed to hash password: %w", err)
	}

	// 更新密码
	if err := s.userRepo.UpdatePassword(ctx, claims.UserID, string(hashedPassword)); err != nil {
		return fmt.Errorf("failed to update password: %w", err)
	}

	// 将重置令牌加入黑名单
	s.blacklistToken(ctx, req.Token)

	s.logger.Info("Password reset successfully", "user_id", claims.UserID)
	return nil
}

// VerifyEmail 验证邮箱
func (s *authService) VerifyEmail(ctx context.Context, token string) error {
	// 验证邮箱验证令牌
	claims, err := s.verifyEmailToken(token)
	if err != nil {
		return fmt.Errorf("invalid verification token: %w", err)
	}

	// 验证用户
	if err := s.userRepo.VerifyUser(ctx, claims.UserID); err != nil {
		return fmt.Errorf("failed to verify user: %w", err)
	}

	// 将验证令牌加入黑名单
	s.blacklistToken(ctx, token)

	s.logger.Info("Email verified successfully", "user_id", claims.UserID)
	return nil
}

// ResendVerificationEmail 重新发送验证邮件
func (s *authService) ResendVerificationEmail(ctx context.Context, email string) error {
	// 获取用户
	user, err := s.userRepo.GetByEmail(ctx, email)
	if err != nil {
		if err == models.ErrUserNotFound {
			return models.ErrUserNotFound
		}
		return fmt.Errorf("failed to get user: %w", err)
	}

	// 检查是否已验证
	if user.IsVerified {
		return models.ErrEmailAlreadyVerified
	}

	// 发送验证邮件
	if err := s.sendVerificationEmail(ctx, user); err != nil {
		return fmt.Errorf("failed to send verification email: %w", err)
	}

	s.logger.Info("Verification email resent successfully", "user_id", user.ID, "email", email)
	return nil
}

// 生成访问令牌和刷新令牌
func (s *authService) generateTokens(user *models.User) (accessToken, refreshToken string, expiresIn int64, err error) {
	now := time.Now()
	accessTokenExpiry := now.Add(time.Duration(s.config.JWT.AccessTokenExpiry) * time.Minute)
	refreshTokenExpiry := now.Add(time.Duration(s.config.JWT.RefreshTokenExpiry) * time.Hour)

	// 生成访问令牌
	accessClaims := &TokenClaims{
		UserID:   user.ID,
		Username: user.Username,
		Email:    user.Email,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(accessTokenExpiry),
			IssuedAt:  jwt.NewNumericDate(now),
			NotBefore: jwt.NewNumericDate(now),
			Issuer:    s.config.JWT.Issuer,
			Subject:   fmt.Sprintf("%d", user.ID),
		},
	}

	accessTokenObj := jwt.NewWithClaims(jwt.SigningMethodHS256, accessClaims)
	accessToken, err = accessTokenObj.SignedString([]byte(s.config.JWT.Secret))
	if err != nil {
		return "", "", 0, fmt.Errorf("failed to sign access token: %w", err)
	}

	// 生成刷新令牌
	refreshClaims := &TokenClaims{
		UserID:   user.ID,
		Username: user.Username,
		Email:    user.Email,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(refreshTokenExpiry),
			IssuedAt:  jwt.NewNumericDate(now),
			NotBefore: jwt.NewNumericDate(now),
			Issuer:    s.config.JWT.Issuer,
			Subject:   fmt.Sprintf("%d", user.ID),
		},
	}

	refreshTokenObj := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
	refreshToken, err = refreshTokenObj.SignedString([]byte(s.config.JWT.Secret))
	if err != nil {
		return "", "", 0, fmt.Errorf("failed to sign refresh token: %w", err)
	}

	return accessToken, refreshToken, int64(s.config.JWT.AccessTokenExpiry * 60), nil
}

// 验证刷新令牌
func (s *authService) verifyRefreshToken(token string) (*TokenClaims, error) {
	claims := &TokenClaims{}
	jwtToken, err := jwt.ParseWithClaims(token, claims, func(token *jwt.Token) (interface{}, error) {
		return []byte(s.config.JWT.Secret), nil
	})

	if err != nil || !jwtToken.Valid {
		return nil, models.ErrInvalidToken
	}

	return claims, nil
}

// 验证重置令牌
func (s *authService) verifyResetToken(token string) (*TokenClaims, error) {
	// 实现重置令牌验证逻辑
	return s.verifyRefreshToken(token)
}

// 验证邮箱令牌
func (s *authService) verifyEmailToken(token string) (*TokenClaims, error) {
	// 实现邮箱验证令牌验证逻辑
	return s.verifyRefreshToken(token)
}

// 将令牌加入黑名单
func (s *authService) blacklistToken(ctx context.Context, token string) {
	if !s.cache.IsEnabled() {
		return
	}

	cacheKey := fmt.Sprintf("blacklist:token:%s", token)
	s.cache.Set(ctx, cacheKey, true, 24*time.Hour)
}

// 检查令牌是否在黑名单中
func (s *authService) isTokenBlacklisted(ctx context.Context, token string) bool {
	if !s.cache.IsEnabled() {
		return false
	}

	cacheKey := fmt.Sprintf("blacklist:token:%s", token)
	var blacklisted bool
	err := s.cache.Get(ctx, cacheKey, &blacklisted)
	return err == nil && blacklisted
}

// 发送验证邮件
func (s *authService) sendVerificationEmail(ctx context.Context, user *models.User) error {
	// TODO: 实现邮件发送逻辑
	s.logger.Info("Verification email would be sent", "user_id", user.ID, "email", user.Email)
	return nil
}

// 转换为用户信息
func (s *authService) toUserInfo(user *models.User) *UserInfo {
	return &UserInfo{
		ID:         user.ID,
		Username:   user.Username,
		Email:      user.Email,
		Nickname:   user.Nickname,
		Avatar:     user.Avatar,
		Status:     user.Status,
		IsVerified: user.IsVerified,
		CreatedAt:  user.CreatedAt,
	}
}

// 检查是否为邮箱格式
func isEmail(str string) bool {
	return len(str) > 0 && str[0] != '@' && len(str) > 3 && 
		(str[len(str)-4:] == ".com" || str[len(str)-3:] == ".cn" || 
		 str[len(str)-4:] == ".org" || str[len(str)-4:] == ".net")
}
```

#### 2.2 创建用户服务

```go
// internal/service/user_service.go
package service

import (
	"context"
	"fmt"
	"time"

	"movieinfo/internal/models"
	"movieinfo/pkg/logger"
)

// UserService 用户服务接口
type UserService interface {
	GetProfile(ctx context.Context, userID uint64) (*UserProfile, error)
	UpdateProfile(ctx context.Context, userID uint64, req *UpdateProfileRequest) error
	UploadAvatar(ctx context.Context, userID uint64, avatarURL string) error
	GetUserList(ctx context.Context, req *GetUserListRequest) (*UserListResponse, error)
	GetUserStats(ctx context.Context) (*UserStatsResponse, error)
	UpdateUserStatus(ctx context.Context, userID uint64, status models.UserStatus) error
	DeleteUser(ctx context.Context, userID uint64) error
	BatchUpdateUsers(ctx context.Context, req *BatchUpdateUsersRequest) error
}

// userService 用户服务实现
type userService struct {
	userRepo models.UserRepository
	cache    models.CacheManager
	logger   logger.Logger
}

// NewUserService 创建用户服务
func NewUserService(
	userRepo models.UserRepository,
	cache models.CacheManager,
	logger logger.Logger,
) UserService {
	return &userService{
		userRepo: userRepo,
		cache:    cache,
		logger:   logger,
	}
}

// UserProfile 用户档案
type UserProfile struct {
	ID           uint64            `json:"id"`
	Username     string            `json:"username"`
	Email        string            `json:"email"`
	Nickname     string            `json:"nickname"`
	Avatar       string            `json:"avatar"`
	Bio          string            `json:"bio"`
	Status       models.UserStatus `json:"status"`
	IsVerified   bool              `json:"is_verified"`
	LoginCount   int64             `json:"login_count"`
	LastLoginAt  *time.Time        `json:"last_login_at"`
	LastLoginIP  string            `json:"last_login_ip"`
	CreatedAt    time.Time         `json:"created_at"`
	UpdatedAt    time.Time         `json:"updated_at"`
}

// UpdateProfileRequest 更新档案请求
type UpdateProfileRequest struct {
	Nickname string `json:"nickname" validate:"required,min=1,max=100"`
	Bio      string `json:"bio" validate:"max=500"`
}

// GetUserListRequest 获取用户列表请求
type GetUserListRequest struct {
	Page         int               `json:"page" validate:"min=1"`
	PageSize     int               `json:"page_size" validate:"min=1,max=100"`
	Status       *models.UserStatus `json:"status,omitempty"`
	IsVerified   *bool             `json:"is_verified,omitempty"`
	Search       string            `json:"search,omitempty"`
	OrderBy      string            `json:"order_by,omitempty"`
	OrderDesc    bool              `json:"order_desc,omitempty"`
	CreatedAfter *time.Time        `json:"created_after,omitempty"`
	CreatedBefore *time.Time       `json:"created_before,omitempty"`
}

// UserListResponse 用户列表响应
type UserListResponse struct {
	Users      []*UserProfile `json:"users"`
	Total      int64          `json:"total"`
	Page       int            `json:"page"`
	PageSize   int            `json:"page_size"`
	TotalPages int            `json:"total_pages"`
}

// UserStatsResponse 用户统计响应
type UserStatsResponse struct {
	TotalUsers        int64 `json:"total_users"`
	ActiveUsers       int64 `json:"active_users"`
	VerifiedUsers     int64 `json:"verified_users"`
	NewUsersToday     int64 `json:"new_users_today"`
	NewUsersThisMonth int64 `json:"new_users_this_month"`
}

// BatchUpdateUsersRequest 批量更新用户请求
type BatchUpdateUsersRequest struct {
	UserIDs []uint64                 `json:"user_ids" validate:"required,min=1"`
	Updates map[string]interface{}   `json:"updates" validate:"required"`
}

// GetProfile 获取用户档案
func (s *userService) GetProfile(ctx context.Context, userID uint64) (*UserProfile, error) {
	// 尝试从缓存获取
	cacheKey := fmt.Sprintf("user:profile:%d", userID)
	var profile UserProfile
	if s.cache.IsEnabled() {
		if err := s.cache.Get(ctx, cacheKey, &profile); err == nil {
			return &profile, nil
		}
	}

	// 从数据库获取
	user, err := s.userRepo.GetByID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	profile = *s.toUserProfile(user)

	// 缓存结果
	if s.cache.IsEnabled() {
		s.cache.Set(ctx, cacheKey, &profile, time.Hour)
	}

	return &profile, nil
}

// UpdateProfile 更新用户档案
func (s *userService) UpdateProfile(ctx context.Context, userID uint64, req *UpdateProfileRequest) error {
	// 获取用户
	user, err := s.userRepo.GetByID(ctx, userID)
	if err != nil {
		return fmt.Errorf("failed to get user: %w", err)
	}

	// 更新字段
	user.Nickname = req.Nickname
	user.Bio = req.Bio
	user.UpdatedAt = time.Now()

	// 保存更新
	if err := s.userRepo.Update(ctx, user); err != nil {
		return fmt.Errorf("failed to update user: %w", err)
	}

	// 清除缓存
	s.invalidateUserProfileCache(ctx, userID)

	s.logger.Info("User profile updated successfully", "user_id", userID)
	return nil
}

// UploadAvatar 上传头像
func (s *userService) UploadAvatar(ctx context.Context, userID uint64, avatarURL string) error {
	// 获取用户
	user, err := s.userRepo.GetByID(ctx, userID)
	if err != nil {
		return fmt.Errorf("failed to get user: %w", err)
	}

	// 更新头像
	user.Avatar = avatarURL
	user.UpdatedAt = time.Now()

	// 保存更新
	if err := s.userRepo.Update(ctx, user); err != nil {
		return fmt.Errorf("failed to update user avatar: %w", err)
	}

	// 清除缓存
	s.invalidateUserProfileCache(ctx, userID)

	s.logger.Info("User avatar updated successfully", "user_id", userID, "avatar_url", avatarURL)
	return nil
}

// GetUserList 获取用户列表
func (s *userService) GetUserList(ctx context.Context, req *GetUserListRequest) (*UserListResponse, error) {
	// 构建查询参数
	params := &models.UserQueryParams{
		Status:        req.Status,
		IsVerified:    req.IsVerified,
		Search:        req.Search,
		OrderBy:       req.OrderBy,
		OrderDesc:     req.OrderDesc,
		CreatedAfter:  req.CreatedAfter,
		CreatedBefore: req.CreatedBefore,
		Limit:         req.PageSize,
		Offset:        (req.Page - 1) * req.PageSize,
	}

	// 获取用户列表
	users, err := s.userRepo.List(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to get user list: %w", err)
	}

	// 获取总数
	total, err := s.userRepo.Count(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to count users: %w", err)
	}

	// 转换为响应格式
	userProfiles := make([]*UserProfile, len(users))
	for i, user := range users {
		userProfiles[i] = s.toUserProfile(user)
	}

	// 计算总页数
	totalPages := int((total + int64(req.PageSize) - 1) / int64(req.PageSize))

	return &UserListResponse{
		Users:      userProfiles,
		Total:      total,
		Page:       req.Page,
		PageSize:   req.PageSize,
		TotalPages: totalPages,
	}, nil
}

// GetUserStats 获取用户统计
func (s *userService) GetUserStats(ctx context.Context) (*UserStatsResponse, error) {
	// 尝试从缓存获取
	cacheKey := "user:stats"
	var stats UserStatsResponse
	if s.cache.IsEnabled() {
		if err := s.cache.Get(ctx, cacheKey, &stats); err == nil {
			return &stats, nil
		}
	}

	// 从数据库获取统计信息
	userStats, err := s.userRepo.GetStats(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get user stats: %w", err)
	}

	stats = UserStatsResponse{
		TotalUsers:        userStats.TotalUsers,
		ActiveUsers:       userStats.ActiveUsers,
		VerifiedUsers:     userStats.VerifiedUsers,
		NewUsersToday:     userStats.NewUsersToday,
		NewUsersThisMonth: userStats.NewUsersThisMonth,
	}

	// 缓存结果（5分钟）
	if s.cache.IsEnabled() {
		s.cache.Set(ctx, cacheKey, &stats, 5*time.Minute)
	}

	return &stats, nil
}

// UpdateUserStatus 更新用户状态
func (s *userService) UpdateUserStatus(ctx context.Context, userID uint64, status models.UserStatus) error {
	// 更新用户状态
	if err := s.userRepo.UpdateStatus(ctx, userID, status); err != nil {
		return fmt.Errorf("failed to update user status: %w", err)
	}

	// 清除缓存
	s.invalidateUserProfileCache(ctx, userID)

	s.logger.Info("User status updated successfully", "user_id", userID, "status", status)
	return nil
}

// DeleteUser 删除用户
func (s *userService) DeleteUser(ctx context.Context, userID uint64) error {
	// 删除用户
	if err := s.userRepo.Delete(ctx, userID); err != nil {
		return fmt.Errorf("failed to delete user: %w", err)
	}

	// 清除缓存
	s.invalidateUserProfileCache(ctx, userID)

	s.logger.Info("User deleted successfully", "user_id", userID)
	return nil
}

// BatchUpdateUsers 批量更新用户
func (s *userService) BatchUpdateUsers(ctx context.Context, req *BatchUpdateUsersRequest) error {
	// 批量更新用户
	if err := s.userRepo.BatchUpdate(ctx, req.UserIDs, req.Updates); err != nil {
		return fmt.Errorf("failed to batch update users: %w", err)
	}

	// 清除相关缓存
	for _, userID := range req.UserIDs {
		s.invalidateUserProfileCache(ctx, userID)
	}

	s.logger.Info("Users batch updated successfully", "count", len(req.UserIDs))
	return nil
}

// 转换为用户档案
func (s *userService) toUserProfile(user *models.User) *UserProfile {
	return &UserProfile{
		ID:          user.ID,
		Username:    user.Username,
		Email:       user.Email,
		Nickname:    user.Nickname,
		Avatar:      user.Avatar,
		Bio:         user.Bio,
		Status:      user.Status,
		IsVerified:  user.IsVerified,
		LoginCount:  user.LoginCount,
		LastLoginAt: user.LastLoginAt,
		LastLoginIP: user.LastLoginIP,
		CreatedAt:   user.CreatedAt,
		UpdatedAt:   user.UpdatedAt,
	}
}

// 清除用户档案缓存
func (s *userService) invalidateUserProfileCache(ctx context.Context, userID uint64) {
	if !s.cache.IsEnabled() {
		return
	}

	cacheKey := fmt.Sprintf("user:profile:%d", userID)
	s.cache.Delete(ctx, cacheKey)

	// 同时清除统计缓存
	s.cache.Delete(ctx, "user:stats")
}
```

### 步骤3：实现gRPC服务层

#### 3.1 创建用户gRPC服务

```go
// internal/grpc/user_handler.go
package grpc

import (
	"context"
	"fmt"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/timestamppb"

	"movieinfo/internal/models"
	"movieinfo/internal/service"
	"movieinfo/pkg/logger"
	pb "movieinfo/proto/user"
)

// UserHandler 用户gRPC处理器
type UserHandler struct {
	pb.UnimplementedUserServiceServer
	userService service.UserService
	authService service.AuthService
	logger      logger.Logger
}

// NewUserHandler 创建用户gRPC处理器
func NewUserHandler(
	userService service.UserService,
	authService service.AuthService,
	logger logger.Logger,
) *UserHandler {
	return &UserHandler{
		userService: userService,
		authService: authService,
		logger:      logger,
	}
}

// Register 用户注册
func (h *UserHandler) Register(ctx context.Context, req *pb.RegisterRequest) (*pb.AuthResponse, error) {
	// 参数验证
	if err := h.validateRegisterRequest(req); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	// 调用认证服务
	serviceReq := &service.RegisterRequest{
		Username: req.Username,
		Email:    req.Email,
		Password: req.Password,
		Nickname: req.Nickname,
	}

	response, err := h.authService.Register(ctx, serviceReq)
	if err != nil {
		return nil, h.handleServiceError(err)
	}

	return h.toAuthResponse(response), nil
}

// Login 用户登录
func (h *UserHandler) Login(ctx context.Context, req *pb.LoginRequest) (*pb.AuthResponse, error) {
	// 参数验证
	if err := h.validateLoginRequest(req); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	// 调用认证服务
	serviceReq := &service.LoginRequest{
		Username: req.Username,
		Password: req.Password,
		LoginIP:  req.LoginIp,
	}

	response, err := h.authService.Login(ctx, serviceReq)
	if err != nil {
		return nil, h.handleServiceError(err)
	}

	return h.toAuthResponse(response), nil
}

// RefreshToken 刷新令牌
func (h *UserHandler) RefreshToken(ctx context.Context, req *pb.RefreshTokenRequest) (*pb.AuthResponse, error) {
	if req.RefreshToken == "" {
		return nil, status.Error(codes.InvalidArgument, "refresh token is required")
	}

	response, err := h.authService.RefreshToken(ctx, req.RefreshToken)
	if err != nil {
		return nil, h.handleServiceError(err)
	}

	return h.toAuthResponse(response), nil
}

// Logout 用户登出
func (h *UserHandler) Logout(ctx context.Context, req *pb.LogoutRequest) (*pb.LogoutResponse, error) {
	// 从上下文获取用户ID
	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return nil, status.Error(codes.Unauthenticated, "user not authenticated")
	}

	if err := h.authService.Logout(ctx, userID, req.Token); err != nil {
		return nil, h.handleServiceError(err)
	}

	return &pb.LogoutResponse{
		Success: true,
		Message: "Logged out successfully",
	}, nil
}

// GetProfile 获取用户档案
func (h *UserHandler) GetProfile(ctx context.Context, req *pb.GetProfileRequest) (*pb.UserProfile, error) {
	// 从上下文获取用户ID
	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return nil, status.Error(codes.Unauthenticated, "user not authenticated")
	}

	// 如果请求指定了用户ID，使用指定的ID
	if req.UserId > 0 {
		userID = req.UserId
	}

	profile, err := h.userService.GetProfile(ctx, userID)
	if err != nil {
		return nil, h.handleServiceError(err)
	}

	return h.toUserProfile(profile), nil
}

// UpdateProfile 更新用户档案
func (h *UserHandler) UpdateProfile(ctx context.Context, req *pb.UpdateProfileRequest) (*pb.UserProfile, error) {
	// 从上下文获取用户ID
	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return nil, status.Error(codes.Unauthenticated, "user not authenticated")
	}

	// 参数验证
	if err := h.validateUpdateProfileRequest(req); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	// 调用用户服务
	serviceReq := &service.UpdateProfileRequest{
		Nickname: req.Nickname,
		Bio:      req.Bio,
	}

	if err := h.userService.UpdateProfile(ctx, userID, serviceReq); err != nil {
		return nil, h.handleServiceError(err)
	}

	// 返回更新后的档案
	profile, err := h.userService.GetProfile(ctx, userID)
	if err != nil {
		return nil, h.handleServiceError(err)
	}

	return h.toUserProfile(profile), nil
}

// ChangePassword 修改密码
func (h *UserHandler) ChangePassword(ctx context.Context, req *pb.ChangePasswordRequest) (*pb.ChangePasswordResponse, error) {
	// 从上下文获取用户ID
	userID, err := h.getUserIDFromContext(ctx)
	if err != nil {
		return nil, status.Error(codes.Unauthenticated, "user not authenticated")
	}

	// 参数验证
	if err := h.validateChangePasswordRequest(req); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	// 调用认证服务
	serviceReq := &service.ChangePasswordRequest{
		OldPassword: req.OldPassword,
		NewPassword: req.NewPassword,
	}

	if err := h.authService.ChangePassword(ctx, userID, serviceReq); err != nil {
		return nil, h.handleServiceError(err)
	}

	return &pb.ChangePasswordResponse{
		Success: true,
		Message: "Password changed successfully",
	}, nil
}

// GetUserList 获取用户列表（管理员功能）
func (h *UserHandler) GetUserList(ctx context.Context, req *pb.GetUserListRequest) (*pb.UserListResponse, error) {
	// 检查管理员权限
	if err := h.checkAdminPermission(ctx); err != nil {
		return nil, err
	}

	// 构建服务请求
	serviceReq := &service.GetUserListRequest{
		Page:      int(req.Page),
		PageSize:  int(req.PageSize),
		Search:    req.Search,
		OrderBy:   req.OrderBy,
		OrderDesc: req.OrderDesc,
	}

	// 处理状态过滤
	if req.Status != nil {
		status := models.UserStatus(*req.Status)
		serviceReq.Status = &status
	}

	// 处理验证状态过滤
	if req.IsVerified != nil {
		serviceReq.IsVerified = &req.IsVerified.Value
	}

	// 处理时间过滤
	if req.CreatedAfter != nil {
		serviceReq.CreatedAfter = &req.CreatedAfter.AsTime()
	}
	if req.CreatedBefore != nil {
		serviceReq.CreatedBefore = &req.CreatedBefore.AsTime()
	}

	// 调用用户服务
	response, err := h.userService.GetUserList(ctx, serviceReq)
	if err != nil {
		return nil, h.handleServiceError(err)
	}

	return h.toUserListResponse(response), nil
}

// GetUserStats 获取用户统计（管理员功能）
func (h *UserHandler) GetUserStats(ctx context.Context, req *pb.GetUserStatsRequest) (*pb.UserStatsResponse, error) {
	// 检查管理员权限
	if err := h.checkAdminPermission(ctx); err != nil {
		return nil, err
	}

	stats, err := h.userService.GetUserStats(ctx)
	if err != nil {
		return nil, h.handleServiceError(err)
	}

	return &pb.UserStatsResponse{
		TotalUsers:        stats.TotalUsers,
		ActiveUsers:       stats.ActiveUsers,
		VerifiedUsers:     stats.VerifiedUsers,
		NewUsersToday:     stats.NewUsersToday,
		NewUsersThisMonth: stats.NewUsersThisMonth,
	}, nil
}

// 验证注册请求
func (h *UserHandler) validateRegisterRequest(req *pb.RegisterRequest) error {
	if req.Username == "" {
		return fmt.Errorf("username is required")
	}
	if req.Email == "" {
		return fmt.Errorf("email is required")
	}
	if req.Password == "" {
		return fmt.Errorf("password is required")
	}
	if req.Nickname == "" {
		return fmt.Errorf("nickname is required")
	}
	return nil
}

// 验证登录请求
func (h *UserHandler) validateLoginRequest(req *pb.LoginRequest) error {
	if req.Username == "" {
		return fmt.Errorf("username is required")
	}
	if req.Password == "" {
		return fmt.Errorf("password is required")
	}
	return nil
}

// 验证更新档案请求
func (h *UserHandler) validateUpdateProfileRequest(req *pb.UpdateProfileRequest) error {
	if req.Nickname == "" {
		return fmt.Errorf("nickname is required")
	}
	return nil
}

// 验证修改密码请求
func (h *UserHandler) validateChangePasswordRequest(req *pb.ChangePasswordRequest) error {
	if req.OldPassword == "" {
		return fmt.Errorf("old password is required")
	}
	if req.NewPassword == "" {
		return fmt.Errorf("new password is required")
	}
	return nil
}

// 从上下文获取用户ID
func (h *UserHandler) getUserIDFromContext(ctx context.Context) (uint64, error) {
	// TODO: 从JWT中间件设置的上下文中获取用户ID
	// 这里需要与JWT中间件配合实现
	return 0, fmt.Errorf("not implemented")
}

// 检查管理员权限
func (h *UserHandler) checkAdminPermission(ctx context.Context) error {
	// TODO: 实现管理员权限检查
	return nil
}

// 处理服务错误
func (h *UserHandler) handleServiceError(err error) error {
	switch err {
	case models.ErrUserNotFound:
		return status.Error(codes.NotFound, "user not found")
	case models.ErrUsernameExists:
		return status.Error(codes.AlreadyExists, "username already exists")
	case models.ErrEmailExists:
		return status.Error(codes.AlreadyExists, "email already exists")
	case models.ErrInvalidCredentials:
		return status.Error(codes.Unauthenticated, "invalid credentials")
	case models.ErrUserBanned:
		return status.Error(codes.PermissionDenied, "user is banned")
	case models.ErrUserSuspended:
		return status.Error(codes.PermissionDenied, "user is suspended")
	case models.ErrUserInactive:
		return status.Error(codes.PermissionDenied, "user is inactive")
	case models.ErrInvalidToken:
		return status.Error(codes.Unauthenticated, "invalid token")
	case models.ErrTokenBlacklisted:
		return status.Error(codes.Unauthenticated, "token is blacklisted")
	default:
		h.logger.Error("Unhandled service error", "error", err)
		return status.Error(codes.Internal, "internal server error")
	}
}

// 转换为认证响应
func (h *UserHandler) toAuthResponse(response *service.AuthResponse) *pb.AuthResponse {
	return &pb.AuthResponse{
		User: &pb.UserInfo{
			Id:         response.User.ID,
			Username:   response.User.Username,
			Email:      response.User.Email,
			Nickname:   response.User.Nickname,
			Avatar:     response.User.Avatar,
			Status:     int32(response.User.Status),
			IsVerified: response.User.IsVerified,
			CreatedAt:  timestamppb.New(response.User.CreatedAt),
		},
		AccessToken:  response.AccessToken,
		RefreshToken: response.RefreshToken,
		ExpiresIn:    response.ExpiresIn,
	}
}

// 转换为用户档案
func (h *UserHandler) toUserProfile(profile *service.UserProfile) *pb.UserProfile {
	var lastLoginAt *timestamppb.Timestamp
	if profile.LastLoginAt != nil {
		lastLoginAt = timestamppb.New(*profile.LastLoginAt)
	}

	return &pb.UserProfile{
		Id:          profile.ID,
		Username:    profile.Username,
		Email:       profile.Email,
		Nickname:    profile.Nickname,
		Avatar:      profile.Avatar,
		Bio:         profile.Bio,
		Status:      int32(profile.Status),
		IsVerified:  profile.IsVerified,
		LoginCount:  profile.LoginCount,
		LastLoginAt: lastLoginAt,
		LastLoginIp: profile.LastLoginIP,
		CreatedAt:   timestamppb.New(profile.CreatedAt),
		UpdatedAt:   timestamppb.New(profile.UpdatedAt),
	}
}

// 转换为用户列表响应
func (h *UserHandler) toUserListResponse(response *service.UserListResponse) *pb.UserListResponse {
	users := make([]*pb.UserProfile, len(response.Users))
	for i, user := range response.Users {
		users[i] = h.toUserProfile(user)
	}

	return &pb.UserListResponse{
		Users:      users,
		Total:      response.Total,
		Page:       int32(response.Page),
		PageSize:   int32(response.PageSize),
		TotalPages: int32(response.TotalPages),
	}
}
```

### 步骤4：创建JWT中间件

#### 4.1 JWT中间件实现

```go
// internal/middleware/auth.go
package middleware

import (
	"context"
	"strings"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"

	"movieinfo/internal/service"
	"movieinfo/pkg/logger"
)

// AuthMiddleware JWT认证中间件
type AuthMiddleware struct {
	authService service.AuthService
	logger      logger.Logger
	publicMethods map[string]bool
}

// NewAuthMiddleware 创建认证中间件
func NewAuthMiddleware(authService service.AuthService, logger logger.Logger) *AuthMiddleware {
	// 定义不需要认证的公开方法
	publicMethods := map[string]bool{
		"/user.UserService/Register":     true,
		"/user.UserService/Login":        true,
		"/user.UserService/RefreshToken": true,
		"/user.UserService/VerifyEmail":  true,
		"/user.UserService/ResetPassword": true,
	}

	return &AuthMiddleware{
		authService:   authService,
		logger:        logger,
		publicMethods: publicMethods,
	}
}

// UnaryInterceptor 一元RPC拦截器
func (m *AuthMiddleware) UnaryInterceptor() grpc.UnaryServerInterceptor {
	return func(
		ctx context.Context,
		req interface{},
		info *grpc.UnaryServerInfo,
		handler grpc.UnaryHandler,
	) (interface{}, error) {
		// 检查是否为公开方法
		if m.publicMethods[info.FullMethod] {
			return handler(ctx, req)
		}

		// 验证JWT令牌
		ctx, err := m.authenticateToken(ctx)
		if err != nil {
			return nil, err
		}

		return handler(ctx, req)
	}
}

// StreamInterceptor 流式RPC拦截器
func (m *AuthMiddleware) StreamInterceptor() grpc.StreamServerInterceptor {
	return func(
		srv interface{},
		ss grpc.ServerStream,
		info *grpc.StreamServerInfo,
		handler grpc.StreamHandler,
	) error {
		// 检查是否为公开方法
		if m.publicMethods[info.FullMethod] {
			return handler(srv, ss)
		}

		// 验证JWT令牌
		ctx, err := m.authenticateToken(ss.Context())
		if err != nil {
			return err
		}

		// 创建新的流包装器
		wrappedStream := &wrappedServerStream{
			ServerStream: ss,
			ctx:          ctx,
		}

		return handler(srv, wrappedStream)
	}
}

// 验证令牌
func (m *AuthMiddleware) authenticateToken(ctx context.Context) (context.Context, error) {
	// 从metadata中获取Authorization头
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, status.Error(codes.Unauthenticated, "missing metadata")
	}

	authorization := md.Get("authorization")
	if len(authorization) == 0 {
		return nil, status.Error(codes.Unauthenticated, "missing authorization header")
	}

	// 解析Bearer令牌
	token := authorization[0]
	if !strings.HasPrefix(token, "Bearer ") {
		return nil, status.Error(codes.Unauthenticated, "invalid authorization header format")
	}

	token = strings.TrimPrefix(token, "Bearer ")

	// 验证令牌
	claims, err := m.authService.VerifyToken(ctx, token)
	if err != nil {
		m.logger.Warn("Token verification failed", "error", err)
		return nil, status.Error(codes.Unauthenticated, "invalid token")
	}

	// 将用户信息添加到上下文
	ctx = context.WithValue(ctx, "user_id", claims.UserID)
	ctx = context.WithValue(ctx, "username", claims.Username)
	ctx = context.WithValue(ctx, "email", claims.Email)

	return ctx, nil
}

// wrappedServerStream 包装的服务器流
type wrappedServerStream struct {
	grpc.ServerStream
	ctx context.Context
}

func (w *wrappedServerStream) Context() context.Context {
	return w.ctx
}
```

#### 4.2 创建用户服务配置

```go
// configs/user.yaml
user:
  # JWT配置
  jwt:
    secret: "your-jwt-secret-key-change-in-production"
    issuer: "movieinfo"
    access_token_expiry: 60  # 分钟
    refresh_token_expiry: 168  # 小时（7天）

  # 密码配置
  password:
    min_length: 8
    max_length: 128
    require_uppercase: true
    require_lowercase: true
    require_numbers: true
    require_symbols: false

  # 用户名配置
  username:
    min_length: 3
    max_length: 50
    allowed_chars: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"

  # 邮箱配置
  email:
    verification_required: true
    verification_token_expiry: 24  # 小时

  # 头像配置
  avatar:
    max_size: 5242880  # 5MB
    allowed_types: ["image/jpeg", "image/png", "image/gif"]
    default_avatar: "/static/images/default-avatar.png"

  # 限流配置
  rate_limit:
    login_attempts: 5
    login_window: 300  # 秒（5分钟）
    register_attempts: 3
    register_window: 3600  # 秒（1小时）
```

### 步骤5：创建用户服务初始化

```go
// internal/user/init.go
package user

import (
	"movieinfo/internal/grpc"
	"movieinfo/internal/middleware"
	"movieinfo/internal/models"
	"movieinfo/internal/repository"
	"movieinfo/internal/service"
	"movieinfo/pkg/config"
	"movieinfo/pkg/logger"
)

// UserModule 用户模块
type UserModule struct {
	UserRepository models.UserRepository
	AuthService    service.AuthService
	UserService    service.UserService
	UserHandler    *grpc.UserHandler
	AuthMiddleware *middleware.AuthMiddleware
}

// InitUserModule 初始化用户模块
func InitUserModule(
	dataLayer *models.DataLayer,
	config *config.Config,
	logger logger.Logger,
) (*UserModule, error) {
	// 初始化仓储层
	userRepo := repository.NewUserRepository(
		dataLayer.DB.DB(),
		dataLayer.Cache,
		logger,
	)

	// 初始化服务层
	authService := service.NewAuthService(
		userRepo,
		dataLayer.Cache,
		config,
		logger,
	)

	userService := service.NewUserService(
		userRepo,
		dataLayer.Cache,
		logger,
	)

	// 初始化gRPC处理器
	userHandler := grpc.NewUserHandler(
		userService,
		authService,
		logger,
	)

	// 初始化中间件
	authMiddleware := middleware.NewAuthMiddleware(
		authService,
		logger,
	)

	return &UserModule{
		UserRepository: userRepo,
		AuthService:    authService,
		UserService:    userService,
		UserHandler:    userHandler,
		AuthMiddleware: authMiddleware,
	}, nil
}
```

## 测试验证

### 单元测试

#### 1. 用户仓储测试

```go
// internal/repository/user_repository_test.go
package repository

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
	"gorm.io/gorm"

	"movieinfo/internal/models"
	"movieinfo/pkg/logger"
	"movieinfo/tests/mocks"
)

type UserRepositoryTestSuite struct {
	suite.Suite
	db       *gorm.DB
	cache    *mocks.MockCacheManager
	logger   logger.Logger
	repo     models.UserRepository
	ctx      context.Context
}

func (suite *UserRepositoryTestSuite) SetupSuite() {
	// 初始化测试数据库
	suite.db = setupTestDB()
	suite.cache = mocks.NewMockCacheManager()
	suite.logger = logger.NewNopLogger()
	suite.repo = NewUserRepository(suite.db, suite.cache, suite.logger)
	suite.ctx = context.Background()
}

func (suite *UserRepositoryTestSuite) TearDownSuite() {
	cleanupTestDB(suite.db)
}

func (suite *UserRepositoryTestSuite) SetupTest() {
	// 清理测试数据
	suite.db.Exec("DELETE FROM users")
}

func (suite *UserRepositoryTestSuite) TestCreate() {
	user := &models.User{
		Username: "testuser",
		Email:    "test@example.com",
		Password: "hashedpassword",
		Nickname: "Test User",
		Status:   models.UserStatusActive,
	}

	err := suite.repo.Create(suite.ctx, user)
	suite.NoError(err)
	suite.NotZero(user.ID)
	suite.NotZero(user.CreatedAt)
}

func (suite *UserRepositoryTestSuite) TestGetByID() {
	// 创建测试用户
	user := &models.User{
		Username: "testuser",
		Email:    "test@example.com",
		Password: "hashedpassword",
		Nickname: "Test User",
	}
	err := suite.repo.Create(suite.ctx, user)
	suite.NoError(err)

	// 测试获取用户
	foundUser, err := suite.repo.GetByID(suite.ctx, user.ID)
	suite.NoError(err)
	suite.Equal(user.Username, foundUser.Username)
	suite.Equal(user.Email, foundUser.Email)
}

func (suite *UserRepositoryTestSuite) TestGetByUsername() {
	// 创建测试用户
	user := &models.User{
		Username: "testuser",
		Email:    "test@example.com",
		Password: "hashedpassword",
		Nickname: "Test User",
	}
	err := suite.repo.Create(suite.ctx, user)
	suite.NoError(err)

	// 测试根据用户名获取
	foundUser, err := suite.repo.GetByUsername(suite.ctx, "testuser")
	suite.NoError(err)
	suite.Equal(user.ID, foundUser.ID)
	suite.Equal(user.Email, foundUser.Email)
}

func (suite *UserRepositoryTestSuite) TestExistsByUsername() {
	// 创建测试用户
	user := &models.User{
		Username: "testuser",
		Email:    "test@example.com",
		Password: "hashedpassword",
		Nickname: "Test User",
	}
	err := suite.repo.Create(suite.ctx, user)
	suite.NoError(err)

	// 测试用户名存在
	exists, err := suite.repo.ExistsByUsername(suite.ctx, "testuser")
	suite.NoError(err)
	suite.True(exists)

	// 测试用户名不存在
	exists, err = suite.repo.ExistsByUsername(suite.ctx, "nonexistent")
	suite.NoError(err)
	suite.False(exists)
}

func TestUserRepositoryTestSuite(t *testing.T) {
	suite.Run(t, new(UserRepositoryTestSuite))
}
```

#### 2. 认证服务测试

```go
// internal/service/auth_service_test.go
package service

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"

	"movieinfo/internal/models"
	"movieinfo/pkg/config"
	"movieinfo/pkg/logger"
	"movieinfo/tests/mocks"
)

type AuthServiceTestSuite struct {
	suite.Suite
	userRepo *mocks.MockUserRepository
	cache    *mocks.MockCacheManager
	config   *config.Config
	logger   logger.Logger
	service  AuthService
	ctx      context.Context
}

func (suite *AuthServiceTestSuite) SetupSuite() {
	suite.userRepo = mocks.NewMockUserRepository()
	suite.cache = mocks.NewMockCacheManager()
	suite.config = &config.Config{
		JWT: config.JWTConfig{
			Secret:              "test-secret",
			Issuer:              "test",
			AccessTokenExpiry:   60,
			RefreshTokenExpiry:  168,
		},
	}
	suite.logger = logger.NewNopLogger()
	suite.service = NewAuthService(
		suite.userRepo,
		suite.cache,
		suite.config,
		suite.logger,
	)
	suite.ctx = context.Background()
}

func (suite *AuthServiceTestSuite) TestRegister() {
	// 设置mock期望
	suite.userRepo.On("ExistsByUsername", suite.ctx, "testuser").Return(false, nil)
	suite.userRepo.On("ExistsByEmail", suite.ctx, "test@example.com").Return(false, nil)
	suite.userRepo.On("Create", suite.ctx, mock.AnythingOfType("*models.User")).Return(nil)

	req := &RegisterRequest{
		Username: "testuser",
		Email:    "test@example.com",
		Password: "password123",
		Nickname: "Test User",
	}

	response, err := suite.service.Register(suite.ctx, req)
	suite.NoError(err)
	suite.NotNil(response)
	suite.NotEmpty(response.AccessToken)
	suite.NotEmpty(response.RefreshToken)
	suite.Equal("testuser", response.User.Username)
}

func (suite *AuthServiceTestSuite) TestLogin() {
	// 创建测试用户
	user := &models.User{
		ID:       1,
		Username: "testuser",
		Email:    "test@example.com",
		Password: "$2a$10$hashedpassword", // bcrypt哈希
		Status:   models.UserStatusActive,
	}

	// 设置mock期望
	suite.userRepo.On("GetByUsername", suite.ctx, "testuser").Return(user, nil)
	suite.userRepo.On("UpdateLoginInfo", suite.ctx, uint64(1), "127.0.0.1").Return(nil)

	req := &LoginRequest{
		Username: "testuser",
		Password: "password123",
		LoginIP:  "127.0.0.1",
	}

	response, err := suite.service.Login(suite.ctx, req)
	suite.NoError(err)
	suite.NotNil(response)
	suite.NotEmpty(response.AccessToken)
	suite.Equal("testuser", response.User.Username)
}

func TestAuthServiceTestSuite(t *testing.T) {
	suite.Run(t, new(AuthServiceTestSuite))
}
```

### 集成测试

```go
// tests/integration/user_service_test.go
package integration

import (
	"context"
	"testing"

	"github.com/stretchr/testify/suite"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"

	"movieinfo/internal/user"
	"movieinfo/pkg/config"
	"movieinfo/pkg/logger"
	pb "movieinfo/proto/user"
)

type UserServiceIntegrationTestSuite struct {
	suite.Suite
	client pb.UserServiceClient
	conn   *grpc.ClientConn
	ctx    context.Context
}

func (suite *UserServiceIntegrationTestSuite) SetupSuite() {
	// 启动测试服务器
	conn, err := grpc.Dial("localhost:9090", grpc.WithTransportCredentials(insecure.NewCredentials()))
	suite.Require().NoError(err)

	suite.conn = conn
	suite.client = pb.NewUserServiceClient(conn)
	suite.ctx = context.Background()
}

func (suite *UserServiceIntegrationTestSuite) TearDownSuite() {
	if suite.conn != nil {
		suite.conn.Close()
	}
}

func (suite *UserServiceIntegrationTestSuite) TestRegisterAndLogin() {
	// 测试注册
	registerReq := &pb.RegisterRequest{
		Username: "integrationtest",
		Email:    "integration@example.com",
		Password: "password123",
		Nickname: "Integration Test",
	}

	registerResp, err := suite.client.Register(suite.ctx, registerReq)
	suite.NoError(err)
	suite.NotNil(registerResp)
	suite.NotEmpty(registerResp.AccessToken)

	// 测试登录
	loginReq := &pb.LoginRequest{
		Username: "integrationtest",
		Password: "password123",
		LoginIp:  "127.0.0.1",
	}

	loginResp, err := suite.client.Login(suite.ctx, loginReq)
	suite.NoError(err)
	suite.NotNil(loginResp)
	suite.NotEmpty(loginResp.AccessToken)
	suite.Equal("integrationtest", loginResp.User.Username)
}

func TestUserServiceIntegrationTestSuite(t *testing.T) {
	suite.Run(t, new(UserServiceIntegrationTestSuite))
}
```

## 预期结果

完成本步骤后，您应该拥有：

1. **完整的用户仓储层**：
   - 用户CRUD操作
   - 缓存集成
   - 批量操作支持
   - 统计功能

2. **认证服务**：
   - 用户注册/登录
   - JWT令牌管理
   - 密码加密/验证
   - 令牌刷新/黑名单

3. **用户服务**：
   - 用户档案管理
   - 用户列表/统计
   - 状态管理
   - 批量操作

4. **gRPC服务层**：
   - 完整的API接口
   - 参数验证
   - 错误处理
   - 响应转换

5. **JWT中间件**：
   - 令牌验证
   - 上下文注入
   - 公开接口配置

6. **测试覆盖**：
   - 单元测试
   - 集成测试
   - Mock测试

## 注意事项

### 安全性

1. **密码安全**：
   - 使用bcrypt加密
   - 密码复杂度验证
   - 防止密码泄露

2. **JWT安全**：
   - 安全的密钥管理
   - 合理的过期时间
   - 令牌黑名单机制

3. **输入验证**：
   - 严格的参数验证
   - SQL注入防护
   - XSS防护

### 性能优化

1. **缓存策略**：
   - 用户信息缓存
   - 统计数据缓存
   - 缓存失效策略

2. **数据库优化**：
   - 索引优化
   - 查询优化
   - 连接池配置

3. **并发处理**：
   - 事务管理
   - 锁机制
   - 并发安全

### 维护性

1. **代码组织**：
   - 清晰的分层架构
   - 接口抽象
   - 依赖注入

2. **错误处理**：
   - 统一错误定义
   - 详细错误日志
   - 用户友好的错误信息

3. **监控和日志**：
   - 关键操作日志
   - 性能监控
   - 安全审计

## 下一步骤

完成用户服务开发后，接下来将进行：

1. **电影服务开发**（08-电影服务开发.md）
   - 电影仓储实现
   - 电影业务逻辑
   - 电影gRPC服务
   - 分类管理

2. **关键检查点**：
   - [ ] 用户仓储功能完整
   - [ ] 认证服务正常工作
   - [ ] JWT中间件正确拦截
   - [ ] gRPC接口测试通过
   - [ ] 单元测试覆盖率达标
   - [ ] 集成测试通过
   - [ ] 安全性验证完成
   - [ ] 性能测试满足要求

请确保所有检查点都已完成，然后继续下一个开发步骤。