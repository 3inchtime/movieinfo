# ç¬¬30æ­¥ï¼šå¯†ç é‡ç½®åŠŸèƒ½

## ğŸ“‹ æ¦‚è¿°

å¯†ç é‡ç½®åŠŸèƒ½æ˜¯ç”¨æˆ·æœåŠ¡çš„é‡è¦å®‰å…¨åŠŸèƒ½ï¼Œä¸ºå¿˜è®°å¯†ç çš„ç”¨æˆ·æä¾›å®‰å…¨çš„å¯†ç æ¢å¤æœºåˆ¶ã€‚ä¸€ä¸ªå®Œå–„çš„å¯†ç é‡ç½®ç³»ç»Ÿéœ€è¦å¹³è¡¡å®‰å…¨æ€§å’Œç”¨æˆ·ä½“éªŒï¼Œé˜²æ­¢æ¶æ„æ”»å‡»çš„åŒæ—¶æä¾›ä¾¿æ·çš„é‡ç½®æµç¨‹ã€‚

## ğŸ¯ è®¾è®¡ç›®æ ‡

### 1. **å®‰å…¨æ€§**
- é˜²æ­¢æš´åŠ›ç ´è§£
- é‡ç½®é“¾æ¥æ—¶æ•ˆæ€§
- ä¸€æ¬¡æ€§ä½¿ç”¨æœºåˆ¶
- èº«ä»½éªŒè¯ä¿æŠ¤

### 2. **ç”¨æˆ·ä½“éªŒ**
- ç®€å•çš„é‡ç½®æµç¨‹
- æ¸…æ™°çš„æ“ä½œæŒ‡å¼•
- å¿«é€Ÿçš„é‚®ä»¶å‘é€
- å‹å¥½çš„é”™è¯¯æç¤º

### 3. **å¯é æ€§**
- é‚®ä»¶å‘é€ä¿éšœ
- é‡è¯•æœºåˆ¶æ”¯æŒ
- çŠ¶æ€è·Ÿè¸ªç®¡ç†
- å¼‚å¸¸å¤„ç†å®Œå–„

## ğŸ”„ å¯†ç é‡ç½®æµç¨‹

### 1. **é‡ç½®æµç¨‹å›¾**

```
ç”¨æˆ·å¿˜è®°å¯†ç  â†’ è®¿é—®é‡ç½®é¡µé¢ â†’ è¾“å…¥é‚®ç®± â†’ æäº¤é‡ç½®è¯·æ±‚
        â†“              â†“           â†“           â†“
    ç‚¹å‡»å¿˜è®°å¯†ç     æ˜¾ç¤ºé‡ç½®è¡¨å•   å¡«å†™é‚®ç®±åœ°å€   å‘é€HTTPè¯·æ±‚
        â†“              â†“           â†“           â†“
éªŒè¯é‚®ç®±å­˜åœ¨ â†’ ç”Ÿæˆé‡ç½®Token â†’ å‘é€é‡ç½®é‚®ä»¶ â†’ è¿”å›æˆåŠŸå“åº”
        â†“              â†“             â†“           â†“
    æŸ¥è¯¢ç”¨æˆ·æ•°æ®    åˆ›å»ºé‡ç½®è®°å½•    é‚®ä»¶æœåŠ¡å‘é€   æç¤ºæŸ¥æ”¶é‚®ä»¶
        â†“              â†“             â†“           â†“
ç”¨æˆ·æ”¶åˆ°é‚®ä»¶ â†’ ç‚¹å‡»é‡ç½®é“¾æ¥ â†’ è®¿é—®é‡ç½®é¡µé¢ â†’ è¾“å…¥æ–°å¯†ç 
        â†“              â†“             â†“           â†“
    æŸ¥çœ‹é‚®ä»¶å†…å®¹    éªŒè¯Tokenæœ‰æ•ˆæ€§  æ˜¾ç¤ºå¯†ç è¡¨å•   æäº¤æ–°å¯†ç 
        â†“              â†“             â†“           â†“
éªŒè¯æ–°å¯†ç  â†’ æ›´æ–°ç”¨æˆ·å¯†ç  â†’ æ¸…ç†é‡ç½®è®°å½• â†’ é‡ç½®å®Œæˆ
        â†“          â†“             â†“           â†“
    å¯†ç å¼ºåº¦æ£€æŸ¥   åŠ å¯†å­˜å‚¨æ–°å¯†ç    åˆ é™¤Tokenè®°å½•   è·³è½¬ç™»å½•é¡µé¢
```

### 2. **å®‰å…¨æœºåˆ¶**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å¯†ç é‡ç½®å®‰å…¨æœºåˆ¶                          â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  é¢‘ç‡é™åˆ¶    â”‚  â”‚  TokenéªŒè¯   â”‚  â”‚  æ—¶æ•ˆæ§åˆ¶    â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ â€¢ IPé™åˆ¶    â”‚  â”‚ â€¢ å”¯ä¸€æ€§    â”‚  â”‚ â€¢ è¿‡æœŸæ—¶é—´   â”‚          â”‚
â”‚  â”‚ â€¢ é‚®ç®±é™åˆ¶   â”‚  â”‚ â€¢ ä¸€æ¬¡æ€§    â”‚  â”‚ â€¢ è‡ªåŠ¨æ¸…ç†   â”‚          â”‚
â”‚  â”‚ â€¢ æ—¶é—´çª—å£   â”‚  â”‚ â€¢ ç­¾åéªŒè¯   â”‚  â”‚ â€¢ çŠ¶æ€è·Ÿè¸ª   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                              â”‚                              â”‚
â”‚                              â–¼                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                  å®¡è®¡æ—¥å¿—è®°å½•                            â”‚ â”‚
â”‚  â”‚                                                         â”‚ â”‚
â”‚  â”‚ â€¢ é‡ç½®è¯·æ±‚è®°å½•  â€¢ é‚®ä»¶å‘é€è®°å½•  â€¢ Tokenä½¿ç”¨è®°å½•          â”‚ â”‚
â”‚  â”‚ â€¢ æˆåŠŸé‡ç½®è®°å½•  â€¢ å¤±è´¥å°è¯•è®°å½•  â€¢ å¼‚å¸¸è¡Œä¸ºè®°å½•          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”§ æ ¸å¿ƒç»„ä»¶å®ç°

### 1. **å¯†ç é‡ç½®æœåŠ¡**

```go
type PasswordResetService struct {
    userRepo       UserRepository
    resetRepo      PasswordResetRepository
    emailSender    EmailSender
    validator      *PasswordValidator
    rateLimiter    *ResetRateLimiter
    tokenGenerator TokenGenerator
    logger         *logrus.Logger
    metrics        *PasswordResetMetrics
}

func NewPasswordResetService(
    userRepo UserRepository,
    resetRepo PasswordResetRepository,
    emailSender EmailSender,
    validator *PasswordValidator,
    rateLimiter *ResetRateLimiter,
) *PasswordResetService {
    return &PasswordResetService{
        userRepo:       userRepo,
        resetRepo:      resetRepo,
        emailSender:    emailSender,
        validator:      validator,
        rateLimiter:    rateLimiter,
        tokenGenerator: NewSecureTokenGenerator(),
        logger:         logrus.New(),
        metrics:        NewPasswordResetMetrics(),
    }
}

// è¯·æ±‚å¯†ç é‡ç½®
func (prs *PasswordResetService) RequestReset(ctx context.Context, email, clientIP string) error {
    start := time.Now()
    defer func() {
        prs.metrics.ObserveResetRequestDuration(time.Since(start))
    }()

    // æ£€æŸ¥é¢‘ç‡é™åˆ¶
    if blocked, remaining := prs.rateLimiter.IsBlocked(email, clientIP); blocked {
        prs.metrics.IncBlockedResetRequests()
        return fmt.Errorf("è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·%dåˆ†é’Ÿåé‡è¯•", remaining/60)
    }

    // éªŒè¯é‚®ç®±æ ¼å¼
    if err := prs.validator.ValidateEmail(email); err != nil {
        prs.metrics.IncInvalidResetRequests("invalid_email")
        return err
    }

    // æŸ¥æ‰¾ç”¨æˆ·
    user, err := prs.userRepo.FindByEmail(ctx, email)
    if err != nil {
        // ä¸ºäº†å®‰å…¨ï¼Œå³ä½¿ç”¨æˆ·ä¸å­˜åœ¨ä¹Ÿè¿”å›æˆåŠŸ
        prs.logger.Warnf("Password reset requested for non-existent email: %s", email)
        prs.metrics.IncInvalidResetRequests("user_not_found")
        return nil
    }

    // æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
    if user.Status != UserStatusActive {
        prs.logger.Warnf("Password reset requested for inactive user: %s", email)
        prs.metrics.IncInvalidResetRequests("user_inactive")
        return nil
    }

    // ç”Ÿæˆé‡ç½®Token
    resetToken := prs.tokenGenerator.Generate()
    expiresAt := time.Now().Add(1 * time.Hour) // 1å°æ—¶æœ‰æ•ˆæœŸ

    // åˆ›å»ºé‡ç½®è®°å½•
    resetRecord := &PasswordReset{
        ID:        uuid.New().String(),
        UserID:    user.ID,
        Email:     email,
        Token:     resetToken,
        ClientIP:  clientIP,
        ExpiresAt: expiresAt,
        CreatedAt: time.Now(),
        Used:      false,
    }

    // æ¸…ç†æ—§çš„é‡ç½®è®°å½•
    if err := prs.resetRepo.DeleteByUserID(ctx, user.ID); err != nil {
        prs.logger.Errorf("Failed to clean old reset records: %v", err)
    }

    // ä¿å­˜é‡ç½®è®°å½•
    if err := prs.resetRepo.Create(ctx, resetRecord); err != nil {
        prs.logger.Errorf("Failed to create reset record: %v", err)
        prs.metrics.IncResetRequestErrors("database_error")
        return errors.New("å¯†ç é‡ç½®è¯·æ±‚å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•")
    }

    // å‘é€é‡ç½®é‚®ä»¶
    if err := prs.sendResetEmail(user, resetToken); err != nil {
        prs.logger.Errorf("Failed to send reset email: %v", err)
        prs.metrics.IncResetRequestErrors("email_error")
        // é‚®ä»¶å‘é€å¤±è´¥ä¸å½±å“é‡ç½®è®°å½•çš„åˆ›å»º
    }

    // è®°å½•é¢‘ç‡é™åˆ¶
    prs.rateLimiter.RecordRequest(email, clientIP)

    prs.metrics.IncSuccessfulResetRequests()
    prs.logger.Infof("Password reset requested for user: %s", email)

    return nil
}

// éªŒè¯é‡ç½®Token
func (prs *PasswordResetService) ValidateResetToken(ctx context.Context, token string) (*PasswordReset, error) {
    if token == "" {
        prs.metrics.IncInvalidTokenValidations("empty_token")
        return nil, errors.New("é‡ç½®ä»¤ç‰Œä¸èƒ½ä¸ºç©º")
    }

    // æŸ¥æ‰¾é‡ç½®è®°å½•
    resetRecord, err := prs.resetRepo.FindByToken(ctx, token)
    if err != nil {
        prs.metrics.IncInvalidTokenValidations("token_not_found")
        return nil, errors.New("æ— æ•ˆçš„é‡ç½®ä»¤ç‰Œ")
    }

    // æ£€æŸ¥æ˜¯å¦å·²ä½¿ç”¨
    if resetRecord.Used {
        prs.metrics.IncInvalidTokenValidations("token_used")
        return nil, errors.New("é‡ç½®ä»¤ç‰Œå·²è¢«ä½¿ç”¨")
    }

    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if time.Now().After(resetRecord.ExpiresAt) {
        prs.metrics.IncInvalidTokenValidations("token_expired")
        return nil, errors.New("é‡ç½®ä»¤ç‰Œå·²è¿‡æœŸ")
    }

    prs.metrics.IncValidTokenValidations()
    return resetRecord, nil
}

// é‡ç½®å¯†ç 
func (prs *PasswordResetService) ResetPassword(ctx context.Context, token, newPassword string) error {
    start := time.Now()
    defer func() {
        prs.metrics.ObservePasswordResetDuration(time.Since(start))
    }()

    // éªŒè¯Token
    resetRecord, err := prs.ValidateResetToken(ctx, token)
    if err != nil {
        return err
    }

    // éªŒè¯æ–°å¯†ç 
    if err := prs.validator.ValidatePassword(newPassword); err != nil {
        prs.metrics.IncPasswordResetErrors("invalid_password")
        return err
    }

    // æŸ¥æ‰¾ç”¨æˆ·
    user, err := prs.userRepo.FindByID(ctx, resetRecord.UserID)
    if err != nil {
        prs.logger.Errorf("Failed to find user for reset: %v", err)
        prs.metrics.IncPasswordResetErrors("user_not_found")
        return errors.New("ç”¨æˆ·ä¸å­˜åœ¨")
    }

    // æ£€æŸ¥æ–°å¯†ç æ˜¯å¦ä¸å½“å‰å¯†ç ç›¸åŒ
    if prs.validator.CheckPassword(newPassword, user.Password) {
        prs.metrics.IncPasswordResetErrors("same_password")
        return errors.New("æ–°å¯†ç ä¸èƒ½ä¸å½“å‰å¯†ç ç›¸åŒ")
    }

    // åŠ å¯†æ–°å¯†ç 
    hashedPassword, err := prs.validator.HashPassword(newPassword)
    if err != nil {
        prs.logger.Errorf("Failed to hash new password: %v", err)
        prs.metrics.IncPasswordResetErrors("hash_error")
        return errors.New("å¯†ç å¤„ç†å¤±è´¥")
    }

    // å¼€å§‹äº‹åŠ¡
    tx, err := prs.userRepo.BeginTx(ctx)
    if err != nil {
        prs.logger.Errorf("Failed to begin transaction: %v", err)
        return errors.New("å¯†ç é‡ç½®å¤±è´¥")
    }
    defer tx.Rollback()

    // æ›´æ–°ç”¨æˆ·å¯†ç 
    user.Password = hashedPassword
    user.PasswordChangedAt = time.Now()
    user.UpdatedAt = time.Now()

    if err := prs.userRepo.UpdateWithTx(ctx, tx, user); err != nil {
        prs.logger.Errorf("Failed to update user password: %v", err)
        prs.metrics.IncPasswordResetErrors("update_error")
        return errors.New("å¯†ç æ›´æ–°å¤±è´¥")
    }

    // æ ‡è®°é‡ç½®è®°å½•ä¸ºå·²ä½¿ç”¨
    resetRecord.Used = true
    resetRecord.UsedAt = time.Now()

    if err := prs.resetRepo.UpdateWithTx(ctx, tx, resetRecord); err != nil {
        prs.logger.Errorf("Failed to update reset record: %v", err)
        prs.metrics.IncPasswordResetErrors("record_update_error")
        return errors.New("é‡ç½®è®°å½•æ›´æ–°å¤±è´¥")
    }

    // æäº¤äº‹åŠ¡
    if err := tx.Commit(); err != nil {
        prs.logger.Errorf("Failed to commit transaction: %v", err)
        return errors.New("å¯†ç é‡ç½®å¤±è´¥")
    }

    // å‘é€å¯†ç é‡ç½®æˆåŠŸé€šçŸ¥é‚®ä»¶
    go func() {
        if err := prs.sendResetSuccessEmail(user); err != nil {
            prs.logger.Errorf("Failed to send reset success email: %v", err)
        }
    }()

    // æ’¤é”€ç”¨æˆ·çš„æ‰€æœ‰æ´»è·ƒä¼šè¯ï¼ˆå¯é€‰ï¼‰
    go func() {
        if err := prs.revokeUserSessions(ctx, user.ID); err != nil {
            prs.logger.Errorf("Failed to revoke user sessions: %v", err)
        }
    }()

    prs.metrics.IncSuccessfulPasswordResets()
    prs.logger.Infof("Password reset successfully for user: %s", user.Email)

    return nil
}

func (prs *PasswordResetService) sendResetEmail(user *User, token string) error {
    resetURL := fmt.Sprintf("https://movieinfo.com/reset-password?token=%s", token)
    
    emailData := PasswordResetEmailData{
        Username:  user.Username,
        Email:     user.Email,
        ResetURL:  resetURL,
        ExpiresIn: "1å°æ—¶",
        Timestamp: time.Now(),
    }

    return prs.emailSender.SendPasswordResetEmail(user.Email, emailData)
}

func (prs *PasswordResetService) sendResetSuccessEmail(user *User) error {
    emailData := PasswordResetSuccessEmailData{
        Username:  user.Username,
        Email:     user.Email,
        Timestamp: time.Now(),
        ClientIP:  "", // å¯ä»¥ä»ä¸Šä¸‹æ–‡è·å–
    }

    return prs.emailSender.SendPasswordResetSuccessEmail(user.Email, emailData)
}
```

### 2. **é¢‘ç‡é™åˆ¶å™¨**

```go
type ResetRateLimiter struct {
    redis         *redis.Client
    emailLimit    int
    ipLimit       int
    timeWindow    time.Duration
    blockDuration time.Duration
    logger        *logrus.Logger
}

func NewResetRateLimiter(redis *redis.Client) *ResetRateLimiter {
    return &ResetRateLimiter{
        redis:         redis,
        emailLimit:    3,  // æ¯ä¸ªé‚®ç®±æ¯å°æ—¶æœ€å¤š3æ¬¡
        ipLimit:       10, // æ¯ä¸ªIPæ¯å°æ—¶æœ€å¤š10æ¬¡
        timeWindow:    1 * time.Hour,
        blockDuration: 1 * time.Hour,
        logger:        logrus.New(),
    }
}

func (rrl *ResetRateLimiter) RecordRequest(email, clientIP string) {
    ctx := context.Background()
    now := time.Now()

    // è®°å½•é‚®ç®±è¯·æ±‚
    emailKey := fmt.Sprintf("reset_rate:email:%s", email)
    rrl.redis.ZAdd(ctx, emailKey, &redis.Z{
        Score:  float64(now.Unix()),
        Member: now.UnixNano(),
    })
    rrl.redis.Expire(ctx, emailKey, rrl.timeWindow)

    // è®°å½•IPè¯·æ±‚
    ipKey := fmt.Sprintf("reset_rate:ip:%s", clientIP)
    rrl.redis.ZAdd(ctx, ipKey, &redis.Z{
        Score:  float64(now.Unix()),
        Member: now.UnixNano(),
    })
    rrl.redis.Expire(ctx, ipKey, rrl.timeWindow)
}

func (rrl *ResetRateLimiter) IsBlocked(email, clientIP string) (bool, int64) {
    ctx := context.Background()
    now := time.Now()
    windowStart := now.Add(-rrl.timeWindow)

    // æ£€æŸ¥é‚®ç®±é¢‘ç‡
    emailKey := fmt.Sprintf("reset_rate:email:%s", email)
    emailCount, _ := rrl.redis.ZCount(ctx, emailKey, 
        fmt.Sprintf("%d", windowStart.Unix()), 
        fmt.Sprintf("%d", now.Unix())).Result()

    // æ£€æŸ¥IPé¢‘ç‡
    ipKey := fmt.Sprintf("reset_rate:ip:%s", clientIP)
    ipCount, _ := rrl.redis.ZCount(ctx, ipKey,
        fmt.Sprintf("%d", windowStart.Unix()),
        fmt.Sprintf("%d", now.Unix())).Result()

    if emailCount >= int64(rrl.emailLimit) || ipCount >= int64(rrl.ipLimit) {
        // è®¡ç®—å‰©ä½™é˜»å¡æ—¶é—´
        var oldestTime int64
        if emailCount >= int64(rrl.emailLimit) {
            oldest, _ := rrl.redis.ZRange(ctx, emailKey, 0, 0).Result()
            if len(oldest) > 0 {
                oldestTime, _ = strconv.ParseInt(oldest[0], 10, 64)
            }
        } else {
            oldest, _ := rrl.redis.ZRange(ctx, ipKey, 0, 0).Result()
            if len(oldest) > 0 {
                oldestTime, _ = strconv.ParseInt(oldest[0], 10, 64)
            }
        }

        if oldestTime > 0 {
            remaining := rrl.timeWindow.Seconds() - float64(now.Unix()-oldestTime)
            if remaining > 0 {
                return true, int64(remaining)
            }
        }
    }

    return false, 0
}
```

### 3. **å®‰å…¨Tokenç”Ÿæˆå™¨**

```go
type TokenGenerator interface {
    Generate() string
}

type SecureTokenGenerator struct {
    length int
}

func NewSecureTokenGenerator() *SecureTokenGenerator {
    return &SecureTokenGenerator{
        length: 32,
    }
}

func (stg *SecureTokenGenerator) Generate() string {
    // ç”Ÿæˆéšæœºå­—èŠ‚
    bytes := make([]byte, stg.length)
    if _, err := rand.Read(bytes); err != nil {
        // å¦‚æœéšæœºæ•°ç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨æ—¶é—´æˆ³ä½œä¸ºåå¤‡
        return fmt.Sprintf("%d-%s", time.Now().UnixNano(), uuid.New().String())
    }

    // è½¬æ¢ä¸ºURLå®‰å…¨çš„Base64ç¼–ç 
    return base64.URLEncoding.EncodeToString(bytes)
}

// éªŒè¯Tokenæ ¼å¼
func (stg *SecureTokenGenerator) ValidateFormat(token string) bool {
    if len(token) == 0 {
        return false
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„Base64ç¼–ç 
    if _, err := base64.URLEncoding.DecodeString(token); err != nil {
        return false
    }

    return true
}
```

### 4. **å¯†ç é‡ç½®æ•°æ®æ¨¡å‹**

```go
type PasswordReset struct {
    ID        string    `gorm:"primaryKey" json:"id"`
    UserID    string    `gorm:"not null;index" json:"user_id"`
    Email     string    `gorm:"not null;index" json:"email"`
    Token     string    `gorm:"not null;uniqueIndex" json:"token"`
    ClientIP  string    `gorm:"not null" json:"client_ip"`
    ExpiresAt time.Time `gorm:"not null;index" json:"expires_at"`
    CreatedAt time.Time `gorm:"not null" json:"created_at"`
    Used      bool      `gorm:"not null;default:false" json:"used"`
    UsedAt    time.Time `json:"used_at"`
}

type PasswordResetRepository interface {
    Create(ctx context.Context, reset *PasswordReset) error
    FindByToken(ctx context.Context, token string) (*PasswordReset, error)
    FindByUserID(ctx context.Context, userID string) ([]*PasswordReset, error)
    Update(ctx context.Context, reset *PasswordReset) error
    UpdateWithTx(ctx context.Context, tx *gorm.DB, reset *PasswordReset) error
    DeleteByUserID(ctx context.Context, userID string) error
    DeleteExpired(ctx context.Context) error
}

type passwordResetRepository struct {
    db     *gorm.DB
    logger *logrus.Logger
}

func NewPasswordResetRepository(db *gorm.DB) PasswordResetRepository {
    return &passwordResetRepository{
        db:     db,
        logger: logrus.New(),
    }
}

func (prr *passwordResetRepository) Create(ctx context.Context, reset *PasswordReset) error {
    return prr.db.WithContext(ctx).Create(reset).Error
}

func (prr *passwordResetRepository) FindByToken(ctx context.Context, token string) (*PasswordReset, error) {
    var reset PasswordReset
    err := prr.db.WithContext(ctx).Where("token = ?", token).First(&reset).Error
    if err != nil {
        return nil, err
    }
    return &reset, nil
}

func (prr *passwordResetRepository) DeleteExpired(ctx context.Context) error {
    return prr.db.WithContext(ctx).Where("expires_at < ?", time.Now()).Delete(&PasswordReset{}).Error
}
```

## ğŸ“Š ç›‘æ§æŒ‡æ ‡

### 1. **å¯†ç é‡ç½®æŒ‡æ ‡**

```go
type PasswordResetMetrics struct {
    resetRequests        *prometheus.CounterVec
    resetCompletions     prometheus.Counter
    resetRequestDuration prometheus.Histogram
    resetDuration        prometheus.Histogram
    tokenValidations     *prometheus.CounterVec
    blockedRequests      prometheus.Counter
    emailSendErrors      prometheus.Counter
}

func NewPasswordResetMetrics() *PasswordResetMetrics {
    return &PasswordResetMetrics{
        resetRequests: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "password_reset_requests_total",
                Help: "Total number of password reset requests",
            },
            []string{"status"},
        ),
        resetCompletions: prometheus.NewCounter(
            prometheus.CounterOpts{
                Name: "password_reset_completions_total",
                Help: "Total number of completed password resets",
            },
        ),
        resetRequestDuration: prometheus.NewHistogram(
            prometheus.HistogramOpts{
                Name: "password_reset_request_duration_seconds",
                Help: "Duration of password reset request processing",
            },
        ),
        resetDuration: prometheus.NewHistogram(
            prometheus.HistogramOpts{
                Name: "password_reset_duration_seconds",
                Help: "Duration of password reset completion",
            },
        ),
        tokenValidations: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "password_reset_token_validations_total",
                Help: "Total number of password reset token validations",
            },
            []string{"status"},
        ),
        blockedRequests: prometheus.NewCounter(
            prometheus.CounterOpts{
                Name: "password_reset_blocked_requests_total",
                Help: "Total number of blocked password reset requests",
            },
        ),
        emailSendErrors: prometheus.NewCounter(
            prometheus.CounterOpts{
                Name: "password_reset_email_errors_total",
                Help: "Total number of password reset email send errors",
            },
        ),
    }
}
```

## ğŸ”§ HTTPå¤„ç†å™¨

### 1. **å¯†ç é‡ç½®APIç«¯ç‚¹**

```go
func (uc *UserController) RequestPasswordReset(c *gin.Context) {
    var req struct {
        Email string `json:"email" binding:"required,email"`
    }

    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{
            "success": false,
            "message": "é‚®ç®±æ ¼å¼ä¸æ­£ç¡®",
        })
        return
    }

    clientIP := c.ClientIP()
    if err := uc.passwordResetService.RequestReset(c.Request.Context(), req.Email, clientIP); err != nil {
        c.JSON(400, gin.H{
            "success": false,
            "message": err.Error(),
        })
        return
    }

    c.JSON(200, gin.H{
        "success": true,
        "message": "å¦‚æœè¯¥é‚®ç®±å·²æ³¨å†Œï¼Œæ‚¨å°†æ”¶åˆ°å¯†ç é‡ç½®é‚®ä»¶",
    })
}

func (uc *UserController) ValidateResetToken(c *gin.Context) {
    token := c.Query("token")
    if token == "" {
        c.JSON(400, gin.H{
            "success": false,
            "message": "ç¼ºå°‘é‡ç½®ä»¤ç‰Œ",
        })
        return
    }

    _, err := uc.passwordResetService.ValidateResetToken(c.Request.Context(), token)
    if err != nil {
        c.JSON(400, gin.H{
            "success": false,
            "message": err.Error(),
        })
        return
    }

    c.JSON(200, gin.H{
        "success": true,
        "message": "é‡ç½®ä»¤ç‰Œæœ‰æ•ˆ",
    })
}

func (uc *UserController) ResetPassword(c *gin.Context) {
    var req struct {
        Token       string `json:"token" binding:"required"`
        NewPassword string `json:"new_password" binding:"required,min=8"`
    }

    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{
            "success": false,
            "message": "è¯·æ±‚å‚æ•°é”™è¯¯",
        })
        return
    }

    if err := uc.passwordResetService.ResetPassword(c.Request.Context(), req.Token, req.NewPassword); err != nil {
        c.JSON(400, gin.H{
            "success": false,
            "message": err.Error(),
        })
        return
    }

    c.JSON(200, gin.H{
        "success": true,
        "message": "å¯†ç é‡ç½®æˆåŠŸï¼Œè¯·ä½¿ç”¨æ–°å¯†ç ç™»å½•",
    })
}
```

## ğŸ“ æ€»ç»“

å¯†ç é‡ç½®åŠŸèƒ½ä¸ºMovieInfoé¡¹ç›®æä¾›äº†å®‰å…¨å¯é çš„å¯†ç æ¢å¤æœºåˆ¶ï¼š

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
1. **å®‰å…¨é‡ç½®**ï¼šTokenéªŒè¯ã€æ—¶æ•ˆæ§åˆ¶ã€ä¸€æ¬¡æ€§ä½¿ç”¨
2. **é¢‘ç‡é™åˆ¶**ï¼šé˜²æ­¢æš´åŠ›ç ´è§£å’Œæ¶æ„è¯·æ±‚
3. **é‚®ä»¶é€šçŸ¥**ï¼šé‡ç½®é“¾æ¥å‘é€å’ŒæˆåŠŸé€šçŸ¥
4. **å®¡è®¡æ—¥å¿—**ï¼šå®Œæ•´çš„æ“ä½œè®°å½•å’Œç›‘æ§

**å®‰å…¨æªæ–½**ï¼š
- é‡ç½®Tokenæ—¶æ•ˆæ€§æ§åˆ¶
- é¢‘ç‡é™åˆ¶å’ŒIPå°ç¦
- ä¸€æ¬¡æ€§ä½¿ç”¨æœºåˆ¶
- ä¼šè¯æ’¤é”€ä¿æŠ¤

**ç”¨æˆ·ä½“éªŒ**ï¼š
- ç®€å•çš„é‡ç½®æµç¨‹
- æ¸…æ™°çš„æ“ä½œæŒ‡å¼•
- å‹å¥½çš„é”™è¯¯æç¤º
- å¿«é€Ÿçš„é‚®ä»¶å“åº”

è‡³æ­¤ï¼Œç”¨æˆ·æœåŠ¡çš„æ ¸å¿ƒåŠŸèƒ½å·²ç»å®Œæˆã€‚ä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬å°†ç»§ç»­å®Œæˆç”µå½±æœåŠ¡ã€è¯„è®ºæœåŠ¡ç­‰å…¶ä»–æ¨¡å—çš„å¼€å‘æ–‡æ¡£ã€‚

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ  
**æœ€åæ›´æ–°**: 2025-07-22  
**ä¸‹ä¸€æ­¥**: [ç¬¬31æ­¥ï¼šç”µå½±æ•°æ®æ¨¡å‹](../07-movie-service/31-movie-model.md)
