# ç¬¬27æ­¥ï¼šæ³¨å†ŒåŠŸèƒ½å®ç°

## ğŸ“‹ æ¦‚è¿°

ç”¨æˆ·æ³¨å†Œæ˜¯MovieInfoé¡¹ç›®çš„æ ¸å¿ƒåŠŸèƒ½ä¹‹ä¸€ï¼Œå®ƒä¸ºæ–°ç”¨æˆ·æä¾›äº†åŠ å…¥å¹³å°çš„å…¥å£ã€‚ä¸€ä¸ªå®Œå–„çš„æ³¨å†Œç³»ç»Ÿä¸ä»…è¦ç¡®ä¿ç”¨æˆ·ä¿¡æ¯çš„å®‰å…¨æ€§ï¼Œè¿˜è¦æä¾›è‰¯å¥½çš„ç”¨æˆ·ä½“éªŒå’Œå®Œæ•´çš„æ•°æ®éªŒè¯æœºåˆ¶ã€‚

## ğŸ¯ è®¾è®¡ç›®æ ‡

### 1. **å®‰å…¨æ€§**
- å¯†ç å®‰å…¨å­˜å‚¨
- é‚®ç®±éªŒè¯æœºåˆ¶
- é˜²æ­¢é‡å¤æ³¨å†Œ
- è¾“å…¥æ•°æ®éªŒè¯

### 2. **ç”¨æˆ·ä½“éªŒ**
- ç®€æ´çš„æ³¨å†Œæµç¨‹
- æ¸…æ™°çš„é”™è¯¯æç¤º
- å¿«é€Ÿçš„å“åº”æ—¶é—´
- å‹å¥½çš„ç•Œé¢è®¾è®¡

### 3. **æ•°æ®å®Œæ•´æ€§**
- ç”¨æˆ·ä¿¡æ¯éªŒè¯
- æ•°æ®æ ¼å¼æ£€æŸ¥
- ä¸šåŠ¡è§„åˆ™æ ¡éªŒ
- äº‹åŠ¡ä¸€è‡´æ€§ä¿è¯

### 4. **å¯æ‰©å±•æ€§**
- æ”¯æŒå¤šç§æ³¨å†Œæ–¹å¼
- å¯é…ç½®çš„éªŒè¯è§„åˆ™
- çµæ´»çš„ç”¨æˆ·å±æ€§
- ç¬¬ä¸‰æ–¹ç™»å½•é¢„ç•™

## ğŸ—ï¸ æ³¨å†Œæµç¨‹è®¾è®¡

### 1. **æ³¨å†Œæµç¨‹å›¾**

```
ç”¨æˆ·è®¿é—®æ³¨å†Œé¡µé¢ â†’ å¡«å†™æ³¨å†Œä¿¡æ¯ â†’ å‰ç«¯éªŒè¯ â†’ æäº¤æ³¨å†Œè¯·æ±‚
        â†“                â†“            â†“           â†“
    æ˜¾ç¤ºæ³¨å†Œè¡¨å•      è¾“å…¥ç”¨æˆ·ä¿¡æ¯    å®¢æˆ·ç«¯éªŒè¯   å‘é€HTTPè¯·æ±‚
        â†“                â†“            â†“           â†“
æœåŠ¡ç«¯æ¥æ”¶è¯·æ±‚ â†’ æ•°æ®éªŒè¯ â†’ æ£€æŸ¥é‡å¤ â†’ åˆ›å»ºç”¨æˆ· â†’ å‘é€éªŒè¯é‚®ä»¶
        â†“            â†“        â†“        â†“           â†“
    è§£æè¯·æ±‚å‚æ•°    æ ¼å¼éªŒè¯   æŸ¥è¯¢æ•°æ®åº“  æ’å…¥è®°å½•    é‚®ä»¶æœåŠ¡
        â†“            â†“        â†“        â†“           â†“
è¿”å›æ³¨å†Œç»“æœ â† ç”Ÿæˆå“åº” â† äº‹åŠ¡æäº¤ â† å¯†ç åŠ å¯† â† ç”ŸæˆéªŒè¯ç 
```

### 2. **æ•°æ®æµè®¾è®¡**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    HTTP POST    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å‰ç«¯é¡µé¢       â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚   ä¸»é¡µæœåŠ¡       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                             â”‚
                                             â”‚ gRPC
                                             â–¼
                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                    â”‚   ç”¨æˆ·æœåŠ¡       â”‚
                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                             â”‚
                                             â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   æ•°æ®éªŒè¯   â”‚  â”‚  ä¸šåŠ¡é€»è¾‘    â”‚  â”‚  æ•°æ®å­˜å‚¨    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚              â”‚              â”‚
                             â–¼              â–¼              â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  æ ¼å¼æ£€æŸ¥    â”‚  â”‚  é‡å¤æ£€æŸ¥    â”‚  â”‚   MySQL     â”‚
                    â”‚  é•¿åº¦éªŒè¯    â”‚  â”‚  å¯†ç åŠ å¯†    â”‚  â”‚   Redis     â”‚
                    â”‚  è§„åˆ™æ ¡éªŒ    â”‚  â”‚  ç”¨æˆ·åˆ›å»º    â”‚  â”‚  é‚®ä»¶é˜Ÿåˆ—    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”§ æ ¸å¿ƒç»„ä»¶å®ç°

### 1. **æ³¨å†Œè¯·æ±‚æ¨¡å‹**

```go
// æ³¨å†Œè¯·æ±‚ç»“æ„
type RegisterRequest struct {
    Email           string `json:"email" binding:"required,email"`
    Password        string `json:"password" binding:"required,min=8,max=128"`
    ConfirmPassword string `json:"confirm_password" binding:"required"`
    Username        string `json:"username" binding:"required,min=3,max=50"`
    FirstName       string `json:"first_name" binding:"max=50"`
    LastName        string `json:"last_name" binding:"max=50"`
    AcceptTerms     bool   `json:"accept_terms" binding:"required"`
}

// æ³¨å†Œå“åº”ç»“æ„
type RegisterResponse struct {
    Success     bool   `json:"success"`
    Message     string `json:"message"`
    UserID      string `json:"user_id,omitempty"`
    NeedVerify  bool   `json:"need_verify"`
    VerifyEmail string `json:"verify_email,omitempty"`
}

// éªŒè¯é”™è¯¯ç»“æ„
type ValidationError struct {
    Field   string `json:"field"`
    Message string `json:"message"`
    Code    string `json:"code"`
}

type RegisterErrorResponse struct {
    Success bool              `json:"success"`
    Message string            `json:"message"`
    Errors  []ValidationError `json:"errors,omitempty"`
}
```

### 2. **æ•°æ®éªŒè¯å™¨**

```go
type UserValidator struct {
    db     *gorm.DB
    redis  *redis.Client
    logger *logrus.Logger
}

func NewUserValidator(db *gorm.DB, redis *redis.Client) *UserValidator {
    return &UserValidator{
        db:     db,
        redis:  redis,
        logger: logrus.New(),
    }
}

// éªŒè¯æ³¨å†Œè¯·æ±‚
func (uv *UserValidator) ValidateRegisterRequest(req *RegisterRequest) []ValidationError {
    var errors []ValidationError
    
    // éªŒè¯é‚®ç®±æ ¼å¼
    if err := uv.validateEmail(req.Email); err != nil {
        errors = append(errors, ValidationError{
            Field:   "email",
            Message: err.Error(),
            Code:    "INVALID_EMAIL",
        })
    }
    
    // éªŒè¯å¯†ç å¼ºåº¦
    if err := uv.validatePassword(req.Password); err != nil {
        errors = append(errors, ValidationError{
            Field:   "password",
            Message: err.Error(),
            Code:    "WEAK_PASSWORD",
        })
    }
    
    // éªŒè¯å¯†ç ç¡®è®¤
    if req.Password != req.ConfirmPassword {
        errors = append(errors, ValidationError{
            Field:   "confirm_password",
            Message: "å¯†ç ç¡®è®¤ä¸åŒ¹é…",
            Code:    "PASSWORD_MISMATCH",
        })
    }
    
    // éªŒè¯ç”¨æˆ·å
    if err := uv.validateUsername(req.Username); err != nil {
        errors = append(errors, ValidationError{
            Field:   "username",
            Message: err.Error(),
            Code:    "INVALID_USERNAME",
        })
    }
    
    // éªŒè¯æœåŠ¡æ¡æ¬¾
    if !req.AcceptTerms {
        errors = append(errors, ValidationError{
            Field:   "accept_terms",
            Message: "å¿…é¡»æ¥å—æœåŠ¡æ¡æ¬¾",
            Code:    "TERMS_NOT_ACCEPTED",
        })
    }
    
    return errors
}

func (uv *UserValidator) validateEmail(email string) error {
    // åŸºæœ¬æ ¼å¼éªŒè¯
    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
    if !emailRegex.MatchString(email) {
        return errors.New("é‚®ç®±æ ¼å¼ä¸æ­£ç¡®")
    }
    
    // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
    var count int64
    if err := uv.db.Model(&User{}).Where("email = ?", email).Count(&count).Error; err != nil {
        uv.logger.Errorf("Failed to check email existence: %v", err)
        return errors.New("é‚®ç®±éªŒè¯å¤±è´¥")
    }
    
    if count > 0 {
        return errors.New("é‚®ç®±å·²è¢«æ³¨å†Œ")
    }
    
    // æ£€æŸ¥é‚®ç®±åŸŸåé»‘åå•
    if uv.isEmailDomainBlocked(email) {
        return errors.New("ä¸æ”¯æŒè¯¥é‚®ç®±åŸŸå")
    }
    
    return nil
}

func (uv *UserValidator) validatePassword(password string) error {
    // é•¿åº¦æ£€æŸ¥
    if len(password) < 8 {
        return errors.New("å¯†ç é•¿åº¦è‡³å°‘8ä½")
    }
    
    if len(password) > 128 {
        return errors.New("å¯†ç é•¿åº¦ä¸èƒ½è¶…è¿‡128ä½")
    }
    
    // å¤æ‚åº¦æ£€æŸ¥
    hasLower := regexp.MustCompile(`[a-z]`).MatchString(password)
    hasUpper := regexp.MustCompile(`[A-Z]`).MatchString(password)
    hasNumber := regexp.MustCompile(`[0-9]`).MatchString(password)
    hasSpecial := regexp.MustCompile(`[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]`).MatchString(password)
    
    complexity := 0
    if hasLower {
        complexity++
    }
    if hasUpper {
        complexity++
    }
    if hasNumber {
        complexity++
    }
    if hasSpecial {
        complexity++
    }
    
    if complexity < 3 {
        return errors.New("å¯†ç å¿…é¡»åŒ…å«å¤§å†™å­—æ¯ã€å°å†™å­—æ¯ã€æ•°å­—ã€ç‰¹æ®Šå­—ç¬¦ä¸­çš„è‡³å°‘3ç§")
    }
    
    // å¸¸è§å¯†ç æ£€æŸ¥
    if uv.isCommonPassword(password) {
        return errors.New("å¯†ç è¿‡äºç®€å•ï¼Œè¯·ä½¿ç”¨æ›´å¤æ‚çš„å¯†ç ")
    }
    
    return nil
}

func (uv *UserValidator) validateUsername(username string) error {
    // é•¿åº¦æ£€æŸ¥
    if len(username) < 3 {
        return errors.New("ç”¨æˆ·åé•¿åº¦è‡³å°‘3ä½")
    }
    
    if len(username) > 50 {
        return errors.New("ç”¨æˆ·åé•¿åº¦ä¸èƒ½è¶…è¿‡50ä½")
    }
    
    // æ ¼å¼æ£€æŸ¥
    usernameRegex := regexp.MustCompile(`^[a-zA-Z0-9_-]+$`)
    if !usernameRegex.MatchString(username) {
        return errors.New("ç”¨æˆ·ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿å’Œè¿å­—ç¬¦")
    }
    
    // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
    var count int64
    if err := uv.db.Model(&User{}).Where("username = ?", username).Count(&count).Error; err != nil {
        uv.logger.Errorf("Failed to check username existence: %v", err)
        return errors.New("ç”¨æˆ·åéªŒè¯å¤±è´¥")
    }
    
    if count > 0 {
        return errors.New("ç”¨æˆ·åå·²è¢«ä½¿ç”¨")
    }
    
    // æ£€æŸ¥ä¿ç•™ç”¨æˆ·å
    if uv.isReservedUsername(username) {
        return errors.New("è¯¥ç”¨æˆ·åä¸ºç³»ç»Ÿä¿ç•™ï¼Œè¯·é€‰æ‹©å…¶ä»–ç”¨æˆ·å")
    }
    
    return nil
}

func (uv *UserValidator) isEmailDomainBlocked(email string) bool {
    domain := strings.Split(email, "@")[1]
    blockedDomains := []string{
        "tempmail.com",
        "10minutemail.com",
        "guerrillamail.com",
    }
    
    for _, blocked := range blockedDomains {
        if domain == blocked {
            return true
        }
    }
    
    return false
}

func (uv *UserValidator) isCommonPassword(password string) bool {
    commonPasswords := []string{
        "password", "123456", "123456789", "qwerty",
        "abc123", "password123", "admin", "letmein",
    }
    
    lowerPassword := strings.ToLower(password)
    for _, common := range commonPasswords {
        if lowerPassword == common {
            return true
        }
    }
    
    return false
}

func (uv *UserValidator) isReservedUsername(username string) bool {
    reserved := []string{
        "admin", "administrator", "root", "system",
        "api", "www", "mail", "ftp", "support",
        "help", "info", "contact", "about",
    }
    
    lowerUsername := strings.ToLower(username)
    for _, res := range reserved {
        if lowerUsername == res {
            return true
        }
    }
    
    return false
}
```

### 3. **æ³¨å†ŒæœåŠ¡å®ç°**

```go
type RegistrationService struct {
    userRepo    UserRepository
    validator   *UserValidator
    hasher      PasswordHasher
    emailSender EmailSender
    logger      *logrus.Logger
    metrics     *RegistrationMetrics
}

func NewRegistrationService(
    userRepo UserRepository,
    validator *UserValidator,
    hasher PasswordHasher,
    emailSender EmailSender,
) *RegistrationService {
    return &RegistrationService{
        userRepo:    userRepo,
        validator:   validator,
        hasher:      hasher,
        emailSender: emailSender,
        logger:      logrus.New(),
        metrics:     NewRegistrationMetrics(),
    }
}

func (rs *RegistrationService) Register(ctx context.Context, req *RegisterRequest) (*RegisterResponse, error) {
    start := time.Now()
    defer func() {
        rs.metrics.ObserveRegistrationDuration(time.Since(start))
    }()
    
    // æ•°æ®éªŒè¯
    if errors := rs.validator.ValidateRegisterRequest(req); len(errors) > 0 {
        rs.metrics.IncRegistrationErrors("validation_failed")
        return &RegisterResponse{
            Success: false,
            Message: "æ³¨å†Œä¿¡æ¯éªŒè¯å¤±è´¥",
        }, &ValidationErrors{Errors: errors}
    }
    
    // å¯†ç åŠ å¯†
    hashedPassword, err := rs.hasher.HashPassword(req.Password)
    if err != nil {
        rs.logger.Errorf("Failed to hash password: %v", err)
        rs.metrics.IncRegistrationErrors("hash_failed")
        return nil, errors.New("å¯†ç å¤„ç†å¤±è´¥")
    }
    
    // åˆ›å»ºç”¨æˆ·å¯¹è±¡
    user := &User{
        ID:        uuid.New().String(),
        Email:     req.Email,
        Username:  req.Username,
        Password:  hashedPassword,
        FirstName: req.FirstName,
        LastName:  req.LastName,
        Status:    UserStatusPending,
        CreatedAt: time.Now(),
        UpdatedAt: time.Now(),
    }
    
    // ç”Ÿæˆé‚®ç®±éªŒè¯ç 
    verificationCode := rs.generateVerificationCode()
    user.EmailVerificationCode = verificationCode
    user.EmailVerificationExpiry = time.Now().Add(24 * time.Hour)
    
    // ä¿å­˜ç”¨æˆ·
    if err := rs.userRepo.Create(ctx, user); err != nil {
        rs.logger.Errorf("Failed to create user: %v", err)
        rs.metrics.IncRegistrationErrors("create_failed")
        
        if strings.Contains(err.Error(), "duplicate") {
            return &RegisterResponse{
                Success: false,
                Message: "é‚®ç®±æˆ–ç”¨æˆ·åå·²è¢«æ³¨å†Œ",
            }, nil
        }
        
        return nil, errors.New("ç”¨æˆ·åˆ›å»ºå¤±è´¥")
    }
    
    // å‘é€éªŒè¯é‚®ä»¶
    if err := rs.sendVerificationEmail(user); err != nil {
        rs.logger.Errorf("Failed to send verification email: %v", err)
        // é‚®ä»¶å‘é€å¤±è´¥ä¸å½±å“æ³¨å†ŒæˆåŠŸ
    }
    
    rs.metrics.IncSuccessfulRegistrations()
    rs.logger.Infof("User registered successfully: %s", user.Email)
    
    return &RegisterResponse{
        Success:     true,
        Message:     "æ³¨å†ŒæˆåŠŸï¼Œè¯·æŸ¥æ”¶éªŒè¯é‚®ä»¶",
        UserID:      user.ID,
        NeedVerify:  true,
        VerifyEmail: user.Email,
    }, nil
}

func (rs *RegistrationService) generateVerificationCode() string {
    return fmt.Sprintf("%06d", rand.Intn(1000000))
}

func (rs *RegistrationService) sendVerificationEmail(user *User) error {
    emailData := EmailVerificationData{
        Username:         user.Username,
        Email:           user.Email,
        VerificationCode: user.EmailVerificationCode,
        ExpiryTime:      user.EmailVerificationExpiry,
        VerificationURL: fmt.Sprintf("https://movieinfo.com/verify?code=%s&email=%s", 
            user.EmailVerificationCode, user.Email),
    }
    
    return rs.emailSender.SendVerificationEmail(user.Email, emailData)
}
```

### 4. **é‚®ç®±éªŒè¯å®ç°**

```go
type EmailVerificationService struct {
    userRepo UserRepository
    logger   *logrus.Logger
}

func NewEmailVerificationService(userRepo UserRepository) *EmailVerificationService {
    return &EmailVerificationService{
        userRepo: userRepo,
        logger:   logrus.New(),
    }
}

func (evs *EmailVerificationService) VerifyEmail(ctx context.Context, email, code string) error {
    // æŸ¥æ‰¾ç”¨æˆ·
    user, err := evs.userRepo.FindByEmail(ctx, email)
    if err != nil {
        evs.logger.Errorf("Failed to find user by email: %v", err)
        return errors.New("ç”¨æˆ·ä¸å­˜åœ¨")
    }
    
    // æ£€æŸ¥éªŒè¯ç 
    if user.EmailVerificationCode != code {
        evs.logger.Warnf("Invalid verification code for user: %s", email)
        return errors.New("éªŒè¯ç ä¸æ­£ç¡®")
    }
    
    // æ£€æŸ¥éªŒè¯ç æ˜¯å¦è¿‡æœŸ
    if time.Now().After(user.EmailVerificationExpiry) {
        evs.logger.Warnf("Verification code expired for user: %s", email)
        return errors.New("éªŒè¯ç å·²è¿‡æœŸ")
    }
    
    // æ›´æ–°ç”¨æˆ·çŠ¶æ€
    user.Status = UserStatusActive
    user.EmailVerified = true
    user.EmailVerificationCode = ""
    user.EmailVerificationExpiry = time.Time{}
    user.UpdatedAt = time.Now()
    
    if err := evs.userRepo.Update(ctx, user); err != nil {
        evs.logger.Errorf("Failed to update user status: %v", err)
        return errors.New("é‚®ç®±éªŒè¯å¤±è´¥")
    }
    
    evs.logger.Infof("Email verified successfully for user: %s", email)
    return nil
}

func (evs *EmailVerificationService) ResendVerificationCode(ctx context.Context, email string) error {
    user, err := evs.userRepo.FindByEmail(ctx, email)
    if err != nil {
        return errors.New("ç”¨æˆ·ä¸å­˜åœ¨")
    }
    
    if user.EmailVerified {
        return errors.New("é‚®ç®±å·²éªŒè¯")
    }
    
    // ç”Ÿæˆæ–°çš„éªŒè¯ç 
    user.EmailVerificationCode = fmt.Sprintf("%06d", rand.Intn(1000000))
    user.EmailVerificationExpiry = time.Now().Add(24 * time.Hour)
    user.UpdatedAt = time.Now()
    
    if err := evs.userRepo.Update(ctx, user); err != nil {
        return errors.New("éªŒè¯ç ç”Ÿæˆå¤±è´¥")
    }
    
    // å‘é€éªŒè¯é‚®ä»¶
    // ... é‚®ä»¶å‘é€é€»è¾‘
    
    return nil
}
```

## ğŸ“Š ç›‘æ§ä¸æŒ‡æ ‡

### 1. **æ³¨å†ŒæŒ‡æ ‡æ”¶é›†**

```go
type RegistrationMetrics struct {
    registrationAttempts  *prometheus.CounterVec
    successfulRegistrations prometheus.Counter
    registrationErrors    *prometheus.CounterVec
    registrationDuration  prometheus.Histogram
    verificationAttempts  *prometheus.CounterVec
}

func NewRegistrationMetrics() *RegistrationMetrics {
    return &RegistrationMetrics{
        registrationAttempts: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "user_registration_attempts_total",
                Help: "Total number of user registration attempts",
            },
            []string{"status"},
        ),
        successfulRegistrations: prometheus.NewCounter(
            prometheus.CounterOpts{
                Name: "user_registrations_successful_total",
                Help: "Total number of successful user registrations",
            },
        ),
        registrationErrors: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "user_registration_errors_total",
                Help: "Total number of user registration errors",
            },
            []string{"error_type"},
        ),
        registrationDuration: prometheus.NewHistogram(
            prometheus.HistogramOpts{
                Name: "user_registration_duration_seconds",
                Help: "Duration of user registration process",
            },
        ),
        verificationAttempts: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "email_verification_attempts_total",
                Help: "Total number of email verification attempts",
            },
            []string{"status"},
        ),
    }
}
```

## ğŸ”§ HTTPå¤„ç†å™¨

### 1. **æ³¨å†ŒAPIç«¯ç‚¹**

```go
type UserController struct {
    registrationService *RegistrationService
    verificationService *EmailVerificationService
    logger             *logrus.Logger
}

func (uc *UserController) Register(c *gin.Context) {
    var req RegisterRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, RegisterErrorResponse{
            Success: false,
            Message: "è¯·æ±‚å‚æ•°é”™è¯¯",
            Errors:  []ValidationError{{Field: "request", Message: err.Error(), Code: "INVALID_REQUEST"}},
        })
        return
    }
    
    resp, err := uc.registrationService.Register(c.Request.Context(), &req)
    if err != nil {
        if validationErr, ok := err.(*ValidationErrors); ok {
            c.JSON(400, RegisterErrorResponse{
                Success: false,
                Message: "æ³¨å†Œä¿¡æ¯éªŒè¯å¤±è´¥",
                Errors:  validationErr.Errors,
            })
            return
        }
        
        uc.logger.Errorf("Registration failed: %v", err)
        c.JSON(500, RegisterErrorResponse{
            Success: false,
            Message: "æ³¨å†Œå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•",
        })
        return
    }
    
    c.JSON(200, resp)
}

func (uc *UserController) VerifyEmail(c *gin.Context) {
    email := c.Query("email")
    code := c.Query("code")
    
    if email == "" || code == "" {
        c.JSON(400, gin.H{
            "success": false,
            "message": "ç¼ºå°‘å¿…è¦å‚æ•°",
        })
        return
    }
    
    if err := uc.verificationService.VerifyEmail(c.Request.Context(), email, code); err != nil {
        c.JSON(400, gin.H{
            "success": false,
            "message": err.Error(),
        })
        return
    }
    
    c.JSON(200, gin.H{
        "success": true,
        "message": "é‚®ç®±éªŒè¯æˆåŠŸ",
    })
}
```

## ğŸ“ æ€»ç»“

ç”¨æˆ·æ³¨å†ŒåŠŸèƒ½ä¸ºMovieInfoé¡¹ç›®æä¾›äº†å®‰å…¨å¯é çš„ç”¨æˆ·å…¥å£ï¼š

**æ ¸å¿ƒç‰¹æ€§**ï¼š
1. **å®Œæ•´éªŒè¯**ï¼šé‚®ç®±ã€å¯†ç ã€ç”¨æˆ·åç­‰å…¨é¢éªŒè¯
2. **å®‰å…¨å­˜å‚¨**ï¼šå¯†ç åŠ å¯†å­˜å‚¨ï¼Œé˜²æ­¢æ³„éœ²
3. **é‚®ç®±éªŒè¯**ï¼šç¡®ä¿é‚®ç®±çœŸå®æ€§å’Œç”¨æˆ·èº«ä»½
4. **é”™è¯¯å¤„ç†**ï¼šè¯¦ç»†çš„é”™è¯¯ä¿¡æ¯å’Œç”¨æˆ·å‹å¥½æç¤º

**å®‰å…¨æªæ–½**ï¼š
- å¯†ç å¼ºåº¦éªŒè¯
- é˜²é‡å¤æ³¨å†Œæ£€æŸ¥
- é‚®ç®±åŸŸåé»‘åå•
- éªŒè¯ç è¿‡æœŸæœºåˆ¶

**æ€§èƒ½ä¼˜åŒ–**ï¼š
- å¼‚æ­¥é‚®ä»¶å‘é€
- æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–
- ç¼“å­˜éªŒè¯ç»“æœ
- ç›‘æ§æŒ‡æ ‡æ”¶é›†

ä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬å°†å®ç°ç™»å½•è®¤è¯ç³»ç»Ÿï¼Œä¸ºç”¨æˆ·æä¾›å®‰å…¨çš„èº«ä»½éªŒè¯æœºåˆ¶ã€‚

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ  
**æœ€åæ›´æ–°**: 2025-07-22  
**ä¸‹ä¸€æ­¥**: [ç¬¬28æ­¥ï¼šç™»å½•è®¤è¯ç³»ç»Ÿ](28-authentication.md)
