# 06-数据模型层开发

## 目标说明

本步骤将为 MovieInfo 项目构建完整的数据模型层，包括数据模型定义、数据访问层（DAL）实现、数据库连接管理、缓存机制集成等核心功能。数据模型层是整个应用的数据基础，负责与数据库和缓存系统的交互，为上层业务逻辑提供统一的数据访问接口。

## 前置条件

在开始本步骤之前，请确保已完成：

1. **项目初始化**（01-项目初始化.md）
2. **数据库设计**（02-数据库设计.md）
3. **配置管理系统**（03-配置管理系统.md）
4. **日志系统**（04-日志系统.md）
5. **gRPC协议定义**（05-gRPC协议定义.md）

## 技术要点

### 设计原则

1. **分层架构**：清晰的分层设计，分离关注点
2. **接口抽象**：使用接口定义数据访问契约
3. **依赖注入**：支持依赖注入，便于测试和扩展
4. **事务管理**：完善的事务处理机制
5. **错误处理**：统一的错误处理和日志记录
6. **性能优化**：连接池、查询优化、缓存策略

### 技术选型

1. **ORM框架**：GORM - Go语言最流行的ORM框架
2. **数据库驱动**：MySQL Driver - 官方MySQL驱动
3. **缓存系统**：Redis - 高性能内存数据库
4. **连接池**：内置连接池管理
5. **迁移工具**：GORM AutoMigrate + 自定义迁移

### 架构设计

```
数据模型层架构：

┌─────────────────────────────────────────────────────────────┐
│                    Business Logic Layer                     │
└─────────────────────┬───────────────────────────────────────┘
                      │
┌─────────────────────┴───────────────────────────────────────┐
│                  Data Access Layer (DAL)                   │
├─────────────────────────────────────────────────────────────┤
│  Repository Interface  │  Service Interface  │  DTO Models  │
├─────────────────────────────────────────────────────────────┤
│  Repository Impl      │  Service Impl       │  Converters  │
└─────────────────────┬───────────────────────────────────────┘
                      │
┌─────────────────────┴───────────────────────────────────────┐
│                    Data Model Layer                        │
├─────────────────────────────────────────────────────────────┤
│  Entity Models     │  Database Manager   │  Cache Manager  │
├─────────────────────────────────────────────────────────────┤
│  GORM Models      │  Connection Pool    │  Redis Client   │
└─────────────────────┬───────────────────────────────────────┘
                      │
┌─────────────────────┴───────────────────────────────────────┐
│                   Infrastructure Layer                     │
├─────────────────────────────────────────────────────────────┤
│     MySQL Database           │         Redis Cache         │
└─────────────────────────────────────────────────────────────┘
```

## 实现步骤

### 步骤1：定义数据模型实体

#### 1.1 创建基础模型

```go
// internal/models/base.go
package models

import (
	"time"

	"gorm.io/gorm"
)

// BaseModel 基础模型，包含通用字段
type BaseModel struct {
	ID        uint           `gorm:"primarykey" json:"id"`
	CreatedAt time.Time      `gorm:"not null;default:CURRENT_TIMESTAMP" json:"created_at"`
	UpdatedAt time.Time      `gorm:"not null;default:CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP" json:"updated_at"`
	DeletedAt gorm.DeletedAt `gorm:"index" json:"deleted_at,omitempty"`
}

// SoftDeleteModel 软删除模型
type SoftDeleteModel struct {
	BaseModel
	IsDeleted bool `gorm:"not null;default:false;index" json:"is_deleted"`
}

// TimestampModel 时间戳模型（不包含ID）
type TimestampModel struct {
	CreatedAt time.Time      `gorm:"not null;default:CURRENT_TIMESTAMP" json:"created_at"`
	UpdatedAt time.Time      `gorm:"not null;default:CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP" json:"updated_at"`
	DeletedAt gorm.DeletedAt `gorm:"index" json:"deleted_at,omitempty"`
}

// TableName 接口，用于自定义表名
type TableNamer interface {
	TableName() string
}

// BeforeCreate GORM钩子：创建前
func (m *BaseModel) BeforeCreate(tx *gorm.DB) error {
	now := time.Now()
	m.CreatedAt = now
	m.UpdatedAt = now
	return nil
}

// BeforeUpdate GORM钩子：更新前
func (m *BaseModel) BeforeUpdate(tx *gorm.DB) error {
	m.UpdatedAt = time.Now()
	return nil
}

// IsZero 检查模型是否为零值
func (m *BaseModel) IsZero() bool {
	return m.ID == 0
}

// GetID 获取ID
func (m *BaseModel) GetID() uint {
	return m.ID
}

// SetID 设置ID
func (m *BaseModel) SetID(id uint) {
	m.ID = id
}
```

#### 1.2 创建用户模型

```go
// internal/models/user.go
package models

import (
	"time"

	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

// User 用户模型
type User struct {
	BaseModel
	Username    string    `gorm:"uniqueIndex;not null;size:50" json:"username" validate:"required,min=3,max=50"`
	Email       string    `gorm:"uniqueIndex;not null;size:100" json:"email" validate:"required,email,max=100"`
	Password    string    `gorm:"not null;size:255" json:"-" validate:"required,min=6"`
	Nickname    string    `gorm:"size:100" json:"nickname" validate:"max=100"`
	Avatar      string    `gorm:"size:500" json:"avatar" validate:"url,max=500"`
	Bio         string    `gorm:"type:text" json:"bio" validate:"max=500"`
	Status      UserStatus `gorm:"not null;default:1" json:"status"`
	LastLoginAt *time.Time `gorm:"index" json:"last_login_at"`
	LoginCount  int64     `gorm:"not null;default:0" json:"login_count"`
	IsVerified  bool      `gorm:"not null;default:false" json:"is_verified"`
	VerifiedAt  *time.Time `json:"verified_at"`

	// 关联关系
	Ratings []Rating `gorm:"foreignKey:UserID;constraint:OnDelete:CASCADE" json:"ratings,omitempty"`
}

// UserStatus 用户状态枚举
type UserStatus int

const (
	UserStatusInactive UserStatus = iota // 0: 未激活
	UserStatusActive                     // 1: 活跃
	UserStatusSuspended                  // 2: 暂停
	UserStatusBanned                     // 3: 封禁
)

// String 实现 Stringer 接口
func (s UserStatus) String() string {
	switch s {
	case UserStatusInactive:
		return "inactive"
	case UserStatusActive:
		return "active"
	case UserStatusSuspended:
		return "suspended"
	case UserStatusBanned:
		return "banned"
	default:
		return "unknown"
	}
}

// IsValid 检查状态是否有效
func (s UserStatus) IsValid() bool {
	return s >= UserStatusInactive && s <= UserStatusBanned
}

// TableName 自定义表名
func (User) TableName() string {
	return "users"
}

// BeforeCreate GORM钩子：创建前
func (u *User) BeforeCreate(tx *gorm.DB) error {
	// 调用基础模型的钩子
	if err := u.BaseModel.BeforeCreate(tx); err != nil {
		return err
	}

	// 加密密码
	if u.Password != "" {
		if err := u.HashPassword(); err != nil {
			return err
		}
	}

	// 设置默认昵称
	if u.Nickname == "" {
		u.Nickname = u.Username
	}

	return nil
}

// BeforeUpdate GORM钩子：更新前
func (u *User) BeforeUpdate(tx *gorm.DB) error {
	// 调用基础模型的钩子
	if err := u.BaseModel.BeforeUpdate(tx); err != nil {
		return err
	}

	// 如果密码被修改，重新加密
	if tx.Statement.Changed("password") && u.Password != "" {
		if err := u.HashPassword(); err != nil {
			return err
		}
	}

	return nil
}

// HashPassword 加密密码
func (u *User) HashPassword() error {
	hashed, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
	if err != nil {
		return err
	}
	u.Password = string(hashed)
	return nil
}

// CheckPassword 验证密码
func (u *User) CheckPassword(password string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
	return err == nil
}

// IsActive 检查用户是否活跃
func (u *User) IsActive() bool {
	return u.Status == UserStatusActive
}

// CanLogin 检查用户是否可以登录
func (u *User) CanLogin() bool {
	return u.Status == UserStatusActive || u.Status == UserStatusInactive
}

// UpdateLoginInfo 更新登录信息
func (u *User) UpdateLoginInfo() {
	now := time.Now()
	u.LastLoginAt = &now
	u.LoginCount++
}

// Verify 验证用户
func (u *User) Verify() {
	now := time.Now()
	u.IsVerified = true
	u.VerifiedAt = &now
	if u.Status == UserStatusInactive {
		u.Status = UserStatusActive
	}
}

// Sanitize 清理敏感信息（用于API响应）
func (u *User) Sanitize() *User {
	sanitized := *u
	sanitized.Password = ""
	return &sanitized
}
```

#### 1.3 创建电影分类模型

```go
// internal/models/category.go
package models

// Category 电影分类模型
type Category struct {
	BaseModel
	Name        string `gorm:"uniqueIndex;not null;size:50" json:"name" validate:"required,min=1,max=50"`
	Slug        string `gorm:"uniqueIndex;not null;size:50" json:"slug" validate:"required,min=1,max=50"`
	Description string `gorm:"type:text" json:"description" validate:"max=500"`
	Color       string `gorm:"size:7;default:'#007bff'" json:"color" validate:"hexcolor"`
	Icon        string `gorm:"size:50" json:"icon" validate:"max=50"`
	SortOrder   int    `gorm:"not null;default:0;index" json:"sort_order"`
	IsActive    bool   `gorm:"not null;default:true;index" json:"is_active"`

	// 关联关系
	Movies []Movie `gorm:"many2many:movie_categories;constraint:OnDelete:CASCADE" json:"movies,omitempty"`
}

// TableName 自定义表名
func (Category) TableName() string {
	return "categories"
}

// BeforeCreate GORM钩子：创建前
func (c *Category) BeforeCreate(tx *gorm.DB) error {
	// 调用基础模型的钩子
	if err := c.BaseModel.BeforeCreate(tx); err != nil {
		return err
	}

	// 生成slug（如果为空）
	if c.Slug == "" {
		c.Slug = generateSlug(c.Name)
	}

	return nil
}

// BeforeUpdate GORM钩子：更新前
func (c *Category) BeforeUpdate(tx *gorm.DB) error {
	// 调用基础模型的钩子
	if err := c.BaseModel.BeforeUpdate(tx); err != nil {
		return err
	}

	// 如果名称被修改，更新slug
	if tx.Statement.Changed("name") {
		c.Slug = generateSlug(c.Name)
	}

	return nil
}

// IsEnabled 检查分类是否启用
func (c *Category) IsEnabled() bool {
	return c.IsActive
}

// Enable 启用分类
func (c *Category) Enable() {
	c.IsActive = true
}

// Disable 禁用分类
func (c *Category) Disable() {
	c.IsActive = false
}
```

#### 1.4 创建电影模型

```go
// internal/models/movie.go
package models

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"

	"gorm.io/gorm"
)

// Movie 电影模型
type Movie struct {
	BaseModel
	Title         string        `gorm:"not null;size:200;index" json:"title" validate:"required,min=1,max=200"`
	OriginalTitle string        `gorm:"size:200" json:"original_title" validate:"max=200"`
	Slug          string        `gorm:"uniqueIndex;not null;size:250" json:"slug" validate:"required,min=1,max=250"`
	Description   string        `gorm:"type:text" json:"description" validate:"max=2000"`
	Summary       string        `gorm:"type:text" json:"summary" validate:"max=500"`
	Poster        string        `gorm:"size:500" json:"poster" validate:"url,max=500"`
	Backdrop      string        `gorm:"size:500" json:"backdrop" validate:"url,max=500"`
	Trailer       string        `gorm:"size:500" json:"trailer" validate:"url,max=500"`
	IMDbID        string        `gorm:"uniqueIndex;size:20" json:"imdb_id" validate:"max=20"`
	TMDbID        int64         `gorm:"uniqueIndex" json:"tmdb_id"`
	ReleaseDate   *time.Time    `gorm:"index" json:"release_date"`
	Runtime       int           `gorm:"default:0" json:"runtime" validate:"min=0,max=1000"`
	Budget        int64         `gorm:"default:0" json:"budget" validate:"min=0"`
	Revenue       int64         `gorm:"default:0" json:"revenue" validate:"min=0"`
	Language      string        `gorm:"size:10;default:'en'" json:"language" validate:"max=10"`
	Country       string        `gorm:"size:100" json:"country" validate:"max=100"`
	Status        MovieStatus   `gorm:"not null;default:1;index" json:"status"`
	Rating        float64       `gorm:"type:decimal(3,1);default:0.0;index" json:"rating" validate:"min=0,max=10"`
	RatingCount   int64         `gorm:"not null;default:0" json:"rating_count"`
	Popularity    float64       `gorm:"type:decimal(8,2);default:0.0;index" json:"popularity"`
	ViewCount     int64         `gorm:"not null;default:0;index" json:"view_count"`
	Genres        StringArray   `gorm:"type:json" json:"genres"`
	Directors     StringArray   `gorm:"type:json" json:"directors"`
	Actors        StringArray   `gorm:"type:json" json:"actors"`
	Writers       StringArray   `gorm:"type:json" json:"writers"`
	Producers     StringArray   `gorm:"type:json" json:"producers"`
	Studios       StringArray   `gorm:"type:json" json:"studios"`
	Keywords      StringArray   `gorm:"type:json" json:"keywords"`
	Metadata      MovieMetadata `gorm:"type:json" json:"metadata"`
	IsPublished   bool          `gorm:"not null;default:false;index" json:"is_published"`
	PublishedAt   *time.Time    `json:"published_at"`

	// 关联关系
	Categories []Category `gorm:"many2many:movie_categories;constraint:OnDelete:CASCADE" json:"categories,omitempty"`
	Ratings    []Rating   `gorm:"foreignKey:MovieID;constraint:OnDelete:CASCADE" json:"ratings,omitempty"`
}

// MovieStatus 电影状态枚举
type MovieStatus int

const (
	MovieStatusDraft     MovieStatus = iota // 0: 草稿
	MovieStatusPublished                    // 1: 已发布
	MovieStatusArchived                     // 2: 已归档
	MovieStatusDeleted                      // 3: 已删除
)

// String 实现 Stringer 接口
func (s MovieStatus) String() string {
	switch s {
	case MovieStatusDraft:
		return "draft"
	case MovieStatusPublished:
		return "published"
	case MovieStatusArchived:
		return "archived"
	case MovieStatusDeleted:
		return "deleted"
	default:
		return "unknown"
	}
}

// IsValid 检查状态是否有效
func (s MovieStatus) IsValid() bool {
	return s >= MovieStatusDraft && s <= MovieStatusDeleted
}

// StringArray 字符串数组类型，用于JSON存储
type StringArray []string

// Scan 实现 sql.Scanner 接口
func (sa *StringArray) Scan(value interface{}) error {
	if value == nil {
		*sa = nil
		return nil
	}

	switch v := value.(type) {
	case []byte:
		return json.Unmarshal(v, sa)
	case string:
		return json.Unmarshal([]byte(v), sa)
	default:
		return fmt.Errorf("cannot scan %T into StringArray", value)
	}
}

// Value 实现 driver.Valuer 接口
func (sa StringArray) Value() (driver.Value, error) {
	if sa == nil {
		return nil, nil
	}
	return json.Marshal(sa)
}

// MovieMetadata 电影元数据
type MovieMetadata struct {
	AgeRating    string            `json:"age_rating,omitempty"`
	Awards       []string          `json:"awards,omitempty"`
	Certification string           `json:"certification,omitempty"`
	Tagline      string            `json:"tagline,omitempty"`
	Homepage     string            `json:"homepage,omitempty"`
	Soundtrack   []string          `json:"soundtrack,omitempty"`
	Trivia       []string          `json:"trivia,omitempty"`
	Goofs        []string          `json:"goofs,omitempty"`
	Quotes       []string          `json:"quotes,omitempty"`
	AlternateVersions []string     `json:"alternate_versions,omitempty"`
	Connections  map[string]string `json:"connections,omitempty"`
	ExternalIDs  map[string]string `json:"external_ids,omitempty"`
}

// Scan 实现 sql.Scanner 接口
func (mm *MovieMetadata) Scan(value interface{}) error {
	if value == nil {
		*mm = MovieMetadata{}
		return nil
	}

	switch v := value.(type) {
	case []byte:
		return json.Unmarshal(v, mm)
	case string:
		return json.Unmarshal([]byte(v), mm)
	default:
		return fmt.Errorf("cannot scan %T into MovieMetadata", value)
	}
}

// Value 实现 driver.Valuer 接口
func (mm MovieMetadata) Value() (driver.Value, error) {
	return json.Marshal(mm)
}

// TableName 自定义表名
func (Movie) TableName() string {
	return "movies"
}

// BeforeCreate GORM钩子：创建前
func (m *Movie) BeforeCreate(tx *gorm.DB) error {
	// 调用基础模型的钩子
	if err := m.BaseModel.BeforeCreate(tx); err != nil {
		return err
	}

	// 生成slug（如果为空）
	if m.Slug == "" {
		m.Slug = generateSlug(m.Title)
	}

	return nil
}

// BeforeUpdate GORM钩子：更新前
func (m *Movie) BeforeUpdate(tx *gorm.DB) error {
	// 调用基础模型的钩子
	if err := m.BaseModel.BeforeUpdate(tx); err != nil {
		return err
	}

	// 如果标题被修改，更新slug
	if tx.Statement.Changed("title") {
		m.Slug = generateSlug(m.Title)
	}

	return nil
}

// IsPublished 检查电影是否已发布
func (m *Movie) IsPublished() bool {
	return m.Status == MovieStatusPublished && m.IsPublished
}

// Publish 发布电影
func (m *Movie) Publish() {
	now := time.Now()
	m.Status = MovieStatusPublished
	m.IsPublished = true
	m.PublishedAt = &now
}

// Unpublish 取消发布电影
func (m *Movie) Unpublish() {
	m.Status = MovieStatusDraft
	m.IsPublished = false
	m.PublishedAt = nil
}

// Archive 归档电影
func (m *Movie) Archive() {
	m.Status = MovieStatusArchived
	m.IsPublished = false
}

// IncrementViewCount 增加观看次数
func (m *Movie) IncrementViewCount() {
	m.ViewCount++
}

// UpdateRating 更新评分
func (m *Movie) UpdateRating(newRating float64, newCount int64) {
	m.Rating = newRating
	m.RatingCount = newCount
}

// GetYear 获取上映年份
func (m *Movie) GetYear() int {
	if m.ReleaseDate != nil {
		return m.ReleaseDate.Year()
	}
	return 0
}

// GetDurationString 获取时长字符串
func (m *Movie) GetDurationString() string {
	if m.Runtime <= 0 {
		return "未知"
	}
	hours := m.Runtime / 60
	minutes := m.Runtime % 60
	if hours > 0 {
		return fmt.Sprintf("%d小时%d分钟", hours, minutes)
	}
	return fmt.Sprintf("%d分钟", minutes)
}

// HasGenre 检查是否包含指定类型
func (m *Movie) HasGenre(genre string) bool {
	for _, g := range m.Genres {
		if g == genre {
			return true
		}
	}
	return false
}

// AddGenre 添加类型
func (m *Movie) AddGenre(genre string) {
	if !m.HasGenre(genre) {
		m.Genres = append(m.Genres, genre)
	}
}

// RemoveGenre 移除类型
func (m *Movie) RemoveGenre(genre string) {
	for i, g := range m.Genres {
		if g == genre {
			m.Genres = append(m.Genres[:i], m.Genres[i+1:]...)
			break
		}
	}
}
```

#### 1.5 创建评分模型

```go
// internal/models/rating.go
package models

import (
	"time"

	"gorm.io/gorm"
)

// Rating 评分模型
type Rating struct {
	BaseModel
	UserID    uint        `gorm:"not null;index:idx_user_movie,unique" json:"user_id"`
	MovieID   uint        `gorm:"not null;index:idx_user_movie,unique;index" json:"movie_id"`
	Score     float64     `gorm:"type:decimal(3,1);not null;check:score >= 0.0 AND score <= 10.0" json:"score" validate:"required,min=0,max=10"`
	Comment   string      `gorm:"type:text" json:"comment" validate:"max=1000"`
	IsPublic  bool        `gorm:"not null;default:true;index" json:"is_public"`
	LikeCount int64       `gorm:"not null;default:0" json:"like_count"`
	Status    RatingStatus `gorm:"not null;default:1;index" json:"status"`

	// 关联关系
	User  User  `gorm:"foreignKey:UserID;constraint:OnDelete:CASCADE" json:"user,omitempty"`
	Movie Movie `gorm:"foreignKey:MovieID;constraint:OnDelete:CASCADE" json:"movie,omitempty"`
}

// RatingStatus 评分状态枚举
type RatingStatus int

const (
	RatingStatusPending  RatingStatus = iota // 0: 待审核
	RatingStatusApproved                     // 1: 已通过
	RatingStatusRejected                     // 2: 已拒绝
	RatingStatusHidden                       // 3: 已隐藏
)

// String 实现 Stringer 接口
func (s RatingStatus) String() string {
	switch s {
	case RatingStatusPending:
		return "pending"
	case RatingStatusApproved:
		return "approved"
	case RatingStatusRejected:
		return "rejected"
	case RatingStatusHidden:
		return "hidden"
	default:
		return "unknown"
	}
}

// IsValid 检查状态是否有效
func (s RatingStatus) IsValid() bool {
	return s >= RatingStatusPending && s <= RatingStatusHidden
}

// TableName 自定义表名
func (Rating) TableName() string {
	return "user_ratings"
}

// BeforeCreate GORM钩子：创建前
func (r *Rating) BeforeCreate(tx *gorm.DB) error {
	// 调用基础模型的钩子
	if err := r.BaseModel.BeforeCreate(tx); err != nil {
		return err
	}

	// 验证评分范围
	if r.Score < 0.0 || r.Score > 10.0 {
		return fmt.Errorf("score must be between 0.0 and 10.0")
	}

	return nil
}

// BeforeUpdate GORM钩子：更新前
func (r *Rating) BeforeUpdate(tx *gorm.DB) error {
	// 调用基础模型的钩子
	if err := r.BaseModel.BeforeUpdate(tx); err != nil {
		return err
	}

	// 验证评分范围
	if tx.Statement.Changed("score") {
		if r.Score < 0.0 || r.Score > 10.0 {
			return fmt.Errorf("score must be between 0.0 and 10.0")
		}
	}

	return nil
}

// IsApproved 检查评分是否已通过
func (r *Rating) IsApproved() bool {
	return r.Status == RatingStatusApproved
}

// IsVisible 检查评分是否可见
func (r *Rating) IsVisible() bool {
	return r.Status == RatingStatusApproved && r.IsPublic
}

// Approve 通过评分
func (r *Rating) Approve() {
	r.Status = RatingStatusApproved
}

// Reject 拒绝评分
func (r *Rating) Reject() {
	r.Status = RatingStatusRejected
}

// Hide 隐藏评分
func (r *Rating) Hide() {
	r.Status = RatingStatusHidden
}

// Show 显示评分
func (r *Rating) Show() {
	r.IsPublic = true
}

// HideFromPublic 从公开列表隐藏
func (r *Rating) HideFromPublic() {
	r.IsPublic = false
}

// IncrementLikeCount 增加点赞数
func (r *Rating) IncrementLikeCount() {
	r.LikeCount++
}

// DecrementLikeCount 减少点赞数
func (r *Rating) DecrementLikeCount() {
	if r.LikeCount > 0 {
		r.LikeCount--
	}
}

// GetScoreStars 获取星级评分（5星制）
func (r *Rating) GetScoreStars() float64 {
	return r.Score / 2.0
}

// GetScorePercentage 获取评分百分比
func (r *Rating) GetScorePercentage() float64 {
	return r.Score * 10.0
}

// HasComment 检查是否有评论
func (r *Rating) HasComment() bool {
	return r.Comment != ""
}
```

#### 1.6 创建电影分类关联模型

```go
// internal/models/movie_category.go
package models

// MovieCategory 电影分类关联模型
type MovieCategory struct {
	MovieID    uint `gorm:"primaryKey;index" json:"movie_id"`
	CategoryID uint `gorm:"primaryKey;index" json:"category_id"`
	TimestampModel

	// 关联关系
	Movie    Movie    `gorm:"foreignKey:MovieID;constraint:OnDelete:CASCADE" json:"movie,omitempty"`
	Category Category `gorm:"foreignKey:CategoryID;constraint:OnDelete:CASCADE" json:"category,omitempty"`
}

// TableName 自定义表名
func (MovieCategory) TableName() string {
	return "movie_categories"
}
```

#### 1.7 创建工具函数

```go
// internal/models/utils.go
package models

import (
	"regexp"
	"strings"
	"unicode"

	"golang.org/x/text/transform"
	"golang.org/x/text/unicode/norm"
)

// generateSlug 生成URL友好的slug
func generateSlug(text string) string {
	// 转换为小写
	text = strings.ToLower(text)

	// 移除重音符号
	t := transform.Chain(norm.NFD, transform.RemoveFunc(isMn), norm.NFC)
	text, _, _ = transform.String(t, text)

	// 替换非字母数字字符为连字符
	reg := regexp.MustCompile(`[^a-z0-9]+`)
	text = reg.ReplaceAllString(text, "-")

	// 移除首尾连字符
	text = strings.Trim(text, "-")

	// 限制长度
	if len(text) > 100 {
		text = text[:100]
		text = strings.Trim(text, "-")
	}

	return text
}

// isMn 检查是否为非间距标记（用于移除重音符号）
func isMn(r rune) bool {
	return unicode.Is(unicode.Mn, r)
}

// ValidateModel 验证模型
func ValidateModel(model interface{}) error {
	// 这里可以集成验证库，如 go-playground/validator
	// 暂时返回nil，后续可以扩展
	return nil
}

// SanitizeString 清理字符串
func SanitizeString(s string) string {
	// 移除首尾空格
	s = strings.TrimSpace(s)

	// 移除多余的空格
	reg := regexp.MustCompile(`\s+`)
	s = reg.ReplaceAllString(s, " ")

	return s
}

// TruncateString 截断字符串
func TruncateString(s string, length int) string {
	if len(s) <= length {
		return s
	}

	// 尝试在单词边界截断
	if length > 3 {
		for i := length - 3; i > 0; i-- {
			if s[i] == ' ' {
				return s[:i] + "..."
			}
		}
	}

	return s[:length-3] + "..."
}

// IsValidEmail 验证邮箱格式
func IsValidEmail(email string) bool {
	reg := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	return reg.MatchString(email)
}

// IsValidURL 验证URL格式
func IsValidURL(url string) bool {
	reg := regexp.MustCompile(`^https?://[\w\-]+(\.[\w\-]+)+([\w\-\.,@?^=%&:/~\+#]*[\w\-\@?^=%&/~\+#])?$`)
	return reg.MatchString(url)
}
```

### 步骤2：创建数据库管理器

#### 2.1 创建数据库配置

```go
// internal/database/config.go
package database

import (
	"fmt"
	"time"
)

// Config 数据库配置
type Config struct {
	// 基础连接配置
	Host     string `mapstructure:"host" json:"host"`
	Port     int    `mapstructure:"port" json:"port"`
	Username string `mapstructure:"username" json:"username"`
	Password string `mapstructure:"password" json:"-"`
	Database string `mapstructure:"database" json:"database"`
	Charset  string `mapstructure:"charset" json:"charset"`
	TimeZone string `mapstructure:"timezone" json:"timezone"`

	// 连接池配置
	MaxOpenConns    int           `mapstructure:"max_open_conns" json:"max_open_conns"`
	MaxIdleConns    int           `mapstructure:"max_idle_conns" json:"max_idle_conns"`
	ConnMaxLifetime time.Duration `mapstructure:"conn_max_lifetime" json:"conn_max_lifetime"`
	ConnMaxIdleTime time.Duration `mapstructure:"conn_max_idle_time" json:"conn_max_idle_time"`

	// GORM配置
	LogLevel                  int  `mapstructure:"log_level" json:"log_level"`
	SlowThreshold             time.Duration `mapstructure:"slow_threshold" json:"slow_threshold"`
	SkipDefaultTransaction    bool `mapstructure:"skip_default_transaction" json:"skip_default_transaction"`
	DisableForeignKeyConstraint bool `mapstructure:"disable_foreign_key_constraint" json:"disable_foreign_key_constraint"`

	// 迁移配置
	AutoMigrate bool `mapstructure:"auto_migrate" json:"auto_migrate"`

	// SSL配置
	SSLMode string `mapstructure:"ssl_mode" json:"ssl_mode"`
	SSLCert string `mapstructure:"ssl_cert" json:"ssl_cert"`
	SSLKey  string `mapstructure:"ssl_key" json:"ssl_key"`
	SSLCA   string `mapstructure:"ssl_ca" json:"ssl_ca"`
}

// DefaultConfig 返回默认配置
func DefaultConfig() *Config {
	return &Config{
		Host:     "localhost",
		Port:     3306,
		Username: "root",
		Password: "",
		Database: "movieinfo",
		Charset:  "utf8mb4",
		TimeZone: "Asia/Shanghai",

		MaxOpenConns:    100,
		MaxIdleConns:    10,
		ConnMaxLifetime: time.Hour,
		ConnMaxIdleTime: 10 * time.Minute,

		LogLevel:                    1, // Silent
		SlowThreshold:               200 * time.Millisecond,
		SkipDefaultTransaction:      false,
		DisableForeignKeyConstraint: false,

		AutoMigrate: true,

		SSLMode: "disable",
	}
}

// DSN 生成数据源名称
func (c *Config) DSN() string {
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=%s&parseTime=True&loc=%s",
		c.Username,
		c.Password,
		c.Host,
		c.Port,
		c.Database,
		c.Charset,
		c.TimeZone,
	)

	// 添加SSL配置
	if c.SSLMode != "" {
		dsn += "&tls=" + c.SSLMode
	}

	return dsn
}

// Validate 验证配置
func (c *Config) Validate() error {
	if c.Host == "" {
		return fmt.Errorf("database host is required")
	}
	if c.Port <= 0 || c.Port > 65535 {
		return fmt.Errorf("database port must be between 1 and 65535")
	}
	if c.Username == "" {
		return fmt.Errorf("database username is required")
	}
	if c.Database == "" {
		return fmt.Errorf("database name is required")
	}
	if c.MaxOpenConns <= 0 {
		return fmt.Errorf("max_open_conns must be greater than 0")
	}
	if c.MaxIdleConns <= 0 {
		return fmt.Errorf("max_idle_conns must be greater than 0")
	}
	if c.MaxIdleConns > c.MaxOpenConns {
		return fmt.Errorf("max_idle_conns cannot be greater than max_open_conns")
	}
	return nil
}
```

#### 2.2 创建数据库管理器

```go
// internal/database/manager.go
package database

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"

	logpkg "movieinfo/pkg/logger"
	"movieinfo/internal/models"
)

// Manager 数据库管理器
type Manager struct {
	config *Config
	db     *gorm.DB
	sqlDB  *sql.DB
	logger logpkg.Logger
}

// NewManager 创建数据库管理器
func NewManager(config *Config, logger logpkg.Logger) (*Manager, error) {
	if err := config.Validate(); err != nil {
		return nil, fmt.Errorf("invalid database config: %w", err)
	}

	return &Manager{
		config: config,
		logger: logger,
	}, nil
}

// Connect 连接数据库
func (m *Manager) Connect() error {
	// 创建GORM配置
	gormConfig := &gorm.Config{
		SkipDefaultTransaction:                   m.config.SkipDefaultTransaction,
		DisableForeignKeyConstraintWhenMigrating: m.config.DisableForeignKeyConstraint,
		Logger:                                   m.createGormLogger(),
	}

	// 连接数据库
	db, err := gorm.Open(mysql.Open(m.config.DSN()), gormConfig)
	if err != nil {
		return fmt.Errorf("failed to connect to database: %w", err)
	}

	// 获取底层sql.DB
	sqlDB, err := db.DB()
	if err != nil {
		return fmt.Errorf("failed to get underlying sql.DB: %w", err)
	}

	// 配置连接池
	sqlDB.SetMaxOpenConns(m.config.MaxOpenConns)
	sqlDB.SetMaxIdleConns(m.config.MaxIdleConns)
	sqlDB.SetConnMaxLifetime(m.config.ConnMaxLifetime)
	sqlDB.SetConnMaxIdleTime(m.config.ConnMaxIdleTime)

	m.db = db
	m.sqlDB = sqlDB

	m.logger.Info("Database connected successfully",
		"host", m.config.Host,
		"port", m.config.Port,
		"database", m.config.Database,
	)

	return nil
}

// Close 关闭数据库连接
func (m *Manager) Close() error {
	if m.sqlDB != nil {
		m.logger.Info("Closing database connection")
		return m.sqlDB.Close()
	}
	return nil
}

// DB 获取GORM数据库实例
func (m *Manager) DB() *gorm.DB {
	return m.db
}

// SqlDB 获取原生SQL数据库实例
func (m *Manager) SqlDB() *sql.DB {
	return m.sqlDB
}

// Ping 检查数据库连接
func (m *Manager) Ping(ctx context.Context) error {
	if m.sqlDB == nil {
		return fmt.Errorf("database not connected")
	}
	return m.sqlDB.PingContext(ctx)
}

// Stats 获取连接池统计信息
func (m *Manager) Stats() sql.DBStats {
	if m.sqlDB == nil {
		return sql.DBStats{}
	}
	return m.sqlDB.Stats()
}

// AutoMigrate 自动迁移数据库表
func (m *Manager) AutoMigrate() error {
	if !m.config.AutoMigrate {
		m.logger.Info("Auto migration is disabled")
		return nil
	}

	m.logger.Info("Starting database auto migration")

	// 定义需要迁移的模型
	models := []interface{}{
		&models.User{},
		&models.Category{},
		&models.Movie{},
		&models.Rating{},
		&models.MovieCategory{},
	}

	// 执行迁移
	for _, model := range models {
		if err := m.db.AutoMigrate(model); err != nil {
			return fmt.Errorf("failed to migrate %T: %w", model, err)
		}
	}

	m.logger.Info("Database auto migration completed successfully")
	return nil
}

// Transaction 执行事务
func (m *Manager) Transaction(fn func(*gorm.DB) error) error {
	return m.db.Transaction(fn)
}

// WithContext 创建带上下文的数据库实例
func (m *Manager) WithContext(ctx context.Context) *gorm.DB {
	return m.db.WithContext(ctx)
}

// createGormLogger 创建GORM日志器
func (m *Manager) createGormLogger() logger.Interface {
	return &gormLogger{
		logger:        m.logger,
		slowThreshold: m.config.SlowThreshold,
		logLevel:      logger.LogLevel(m.config.LogLevel),
	}
}

// gormLogger GORM日志器实现
type gormLogger struct {
	logger        logpkg.Logger
	slowThreshold time.Duration
	logLevel      logger.LogLevel
}

// LogMode 设置日志级别
func (l *gormLogger) LogMode(level logger.LogLevel) logger.Interface {
	newLogger := *l
	newLogger.logLevel = level
	return &newLogger
}

// Info 记录信息日志
func (l *gormLogger) Info(ctx context.Context, msg string, data ...interface{}) {
	if l.logLevel >= logger.Info {
		l.logger.Info(fmt.Sprintf(msg, data...))
	}
}

// Warn 记录警告日志
func (l *gormLogger) Warn(ctx context.Context, msg string, data ...interface{}) {
	if l.logLevel >= logger.Warn {
		l.logger.Warn(fmt.Sprintf(msg, data...))
	}
}

// Error 记录错误日志
func (l *gormLogger) Error(ctx context.Context, msg string, data ...interface{}) {
	if l.logLevel >= logger.Error {
		l.logger.Error(fmt.Sprintf(msg, data...))
	}
}

// Trace 记录SQL跟踪日志
func (l *gormLogger) Trace(ctx context.Context, begin time.Time, fc func() (string, int64), err error) {
	if l.logLevel <= logger.Silent {
		return
	}

	elapsed := time.Since(begin)
	sql, rows := fc()

	fields := []interface{}{
		"elapsed", elapsed,
		"rows", rows,
		"sql", sql,
	}

	switch {
	case err != nil && l.logLevel >= logger.Error:
		l.logger.Error("SQL execution failed", append(fields, "error", err)...)
	case elapsed > l.slowThreshold && l.slowThreshold != 0 && l.logLevel >= logger.Warn:
		l.logger.Warn("Slow SQL detected", fields...)
	case l.logLevel == logger.Info:
		l.logger.Debug("SQL executed", fields...)
	}
}
```

### 步骤3：创建缓存管理器

#### 3.1 创建缓存配置

```go
// internal/cache/manager.go
package cache

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/go-redis/redis/v8"

	logpkg "movieinfo/pkg/logger"
)

// Manager 缓存管理器
type Manager struct {
	config *Config
	client *redis.Client
	logger logpkg.Logger
}

// NewManager 创建缓存管理器
func NewManager(config *Config, logger logpkg.Logger) (*Manager, error) {
	if err := config.Validate(); err != nil {
		return nil, fmt.Errorf("invalid cache config: %w", err)
	}

	return &Manager{
		config: config,
		logger: logger,
	}, nil
}

// Connect 连接Redis
func (m *Manager) Connect() error {
	if !m.config.Enabled {
		m.logger.Info("Cache is disabled")
		return nil
	}

	// 创建Redis客户端
	m.client = redis.NewClient(&redis.Options{
		Addr:         m.config.Address(),
		Password:     m.config.Password,
		DB:           m.config.DB,
		PoolSize:     m.config.PoolSize,
		MinIdleConns: m.config.MinIdleConns,
		MaxConnAge:   m.config.MaxConnAge,
		PoolTimeout:  m.config.PoolTimeout,
		IdleTimeout:  m.config.IdleTimeout,
		DialTimeout:  m.config.DialTimeout,
		ReadTimeout:  m.config.ReadTimeout,
		WriteTimeout: m.config.WriteTimeout,
	})

	// 测试连接
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := m.client.Ping(ctx).Err(); err != nil {
		return fmt.Errorf("failed to connect to redis: %w", err)
	}

	m.logger.Info("Cache connected successfully",
		"host", m.config.Host,
		"port", m.config.Port,
		"db", m.config.DB,
	)

	return nil
}

// Close 关闭Redis连接
func (m *Manager) Close() error {
	if m.client != nil {
		m.logger.Info("Closing cache connection")
		return m.client.Close()
	}
	return nil
}

// Client 获取Redis客户端
func (m *Manager) Client() *redis.Client {
	return m.client
}

// IsEnabled 检查缓存是否启用
func (m *Manager) IsEnabled() bool {
	return m.config.Enabled && m.client != nil
}

// buildKey 构建缓存键
func (m *Manager) buildKey(key string) string {
	return m.config.KeyPrefix + key
}

// Set 设置缓存
func (m *Manager) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error {
	if !m.IsEnabled() {
		return nil
	}

	data, err := json.Marshal(value)
	if err != nil {
		return fmt.Errorf("failed to marshal value: %w", err)
	}

	if ttl == 0 {
		ttl = m.config.DefaultTTL
	}

	return m.client.Set(ctx, m.buildKey(key), data, ttl).Err()
}

// Get 获取缓存
func (m *Manager) Get(ctx context.Context, key string, dest interface{}) error {
	if !m.IsEnabled() {
		return redis.Nil
	}

	data, err := m.client.Get(ctx, m.buildKey(key)).Result()
	if err != nil {
		return err
	}

	return json.Unmarshal([]byte(data), dest)
}

// Delete 删除缓存
func (m *Manager) Delete(ctx context.Context, keys ...string) error {
	if !m.IsEnabled() {
		return nil
	}

	if len(keys) == 0 {
		return nil
	}

	// 构建完整的键名
	fullKeys := make([]string, len(keys))
	for i, key := range keys {
		fullKeys[i] = m.buildKey(key)
	}

	return m.client.Del(ctx, fullKeys...).Err()
}

// Exists 检查缓存是否存在
func (m *Manager) Exists(ctx context.Context, key string) (bool, error) {
	if !m.IsEnabled() {
		return false, nil
	}

	count, err := m.client.Exists(ctx, m.buildKey(key)).Result()
	return count > 0, err
}

// Expire 设置过期时间
func (m *Manager) Expire(ctx context.Context, key string, ttl time.Duration) error {
	if !m.IsEnabled() {
		return nil
	}

	return m.client.Expire(ctx, m.buildKey(key), ttl).Err()
}

// TTL 获取剩余过期时间
func (m *Manager) TTL(ctx context.Context, key string) (time.Duration, error) {
	if !m.IsEnabled() {
		return 0, nil
	}

	return m.client.TTL(ctx, m.buildKey(key)).Result()
}

// Increment 递增
func (m *Manager) Increment(ctx context.Context, key string, value int64) (int64, error) {
	if !m.IsEnabled() {
		return 0, nil
	}

	return m.client.IncrBy(ctx, m.buildKey(key), value).Result()
}

// Decrement 递减
func (m *Manager) Decrement(ctx context.Context, key string, value int64) (int64, error) {
	if !m.IsEnabled() {
		return 0, nil
	}

	return m.client.DecrBy(ctx, m.buildKey(key), value).Result()
}

// FlushDB 清空当前数据库
func (m *Manager) FlushDB(ctx context.Context) error {
	if !m.IsEnabled() {
		return nil
	}

	return m.client.FlushDB(ctx).Err()
}

// FlushAll 清空所有数据库
func (m *Manager) FlushAll(ctx context.Context) error {
	if !m.IsEnabled() {
		return nil
	}

	return m.client.FlushAll(ctx).Err()
}

// Keys 获取匹配的键
func (m *Manager) Keys(ctx context.Context, pattern string) ([]string, error) {
	if !m.IsEnabled() {
		return nil, nil
	}

	keys, err := m.client.Keys(ctx, m.buildKey(pattern)).Result()
	if err != nil {
		return nil, err
	}

	// 移除键前缀
	prefixLen := len(m.config.KeyPrefix)
	for i, key := range keys {
		if len(key) > prefixLen {
			keys[i] = key[prefixLen:]
		}
	}

	return keys, nil
}

// Pipeline 创建管道
func (m *Manager) Pipeline() redis.Pipeliner {
	if !m.IsEnabled() {
		return nil
	}

	return m.client.Pipeline()
}

// TxPipeline 创建事务管道
func (m *Manager) TxPipeline() redis.Pipeliner {
	if !m.IsEnabled() {
		return nil
	}

	return m.client.TxPipeline()
}

// Stats 获取连接池统计信息
func (m *Manager) Stats() *redis.PoolStats {
	if !m.IsEnabled() {
		return nil
	}

	return m.client.PoolStats()
}

// Ping 检查连接
func (m *Manager) Ping(ctx context.Context) error {
	if !m.IsEnabled() {
		return nil
	}

	return m.client.Ping(ctx).Err()
}
```

### 步骤4：创建数据访问层接口

#### 4.1 创建基础仓储接口

```go
// internal/repository/interfaces.go
package repository

import (
	"context"

	"movieinfo/internal/models"
)

// BaseRepository 基础仓储接口
type BaseRepository[T any] interface {
	// 基础CRUD操作
	Create(ctx context.Context, entity *T) error
	GetByID(ctx context.Context, id uint) (*T, error)
	Update(ctx context.Context, entity *T) error
	Delete(ctx context.Context, id uint) error
	SoftDelete(ctx context.Context, id uint) error

	// 批量操作
	BatchCreate(ctx context.Context, entities []*T) error
	BatchUpdate(ctx context.Context, entities []*T) error
	BatchDelete(ctx context.Context, ids []uint) error

	// 查询操作
	Exists(ctx context.Context, id uint) (bool, error)
	Count(ctx context.Context, conditions map[string]interface{}) (int64, error)
}

// UserRepository 用户仓储接口
type UserRepository interface {
	BaseRepository[models.User]

	// 用户特定查询
	GetByUsername(ctx context.Context, username string) (*models.User, error)
	GetByEmail(ctx context.Context, email string) (*models.User, error)
	GetByUsernameOrEmail(ctx context.Context, usernameOrEmail string) (*models.User, error)

	// 用户列表查询
	List(ctx context.Context, params *UserListParams) ([]*models.User, int64, error)
	GetActiveUsers(ctx context.Context, limit int) ([]*models.User, error)
	GetUsersByStatus(ctx context.Context, status models.UserStatus, limit, offset int) ([]*models.User, error)

	// 用户统计
	GetUserStats(ctx context.Context, userID uint) (*UserStats, error)
	GetRegistrationStats(ctx context.Context, days int) ([]DailyStats, error)

	// 用户操作
	UpdateLastLogin(ctx context.Context, userID uint) error
	UpdatePassword(ctx context.Context, userID uint, hashedPassword string) error
	VerifyUser(ctx context.Context, userID uint) error
	ChangeStatus(ctx context.Context, userID uint, status models.UserStatus) error
}

// CategoryRepository 分类仓储接口
type CategoryRepository interface {
	BaseRepository[models.Category]

	// 分类特定查询
	GetBySlug(ctx context.Context, slug string) (*models.Category, error)
	GetByName(ctx context.Context, name string) (*models.Category, error)

	// 分类列表查询
	List(ctx context.Context, params *CategoryListParams) ([]*models.Category, int64, error)
	GetActiveCategories(ctx context.Context) ([]*models.Category, error)
	GetCategoriesWithMovieCount(ctx context.Context) ([]*CategoryWithCount, error)

	// 分类操作
	UpdateSortOrder(ctx context.Context, categoryID uint, sortOrder int) error
	ToggleStatus(ctx context.Context, categoryID uint) error
}

// MovieRepository 电影仓储接口
type MovieRepository interface {
	BaseRepository[models.Movie]

	// 电影特定查询
	GetBySlug(ctx context.Context, slug string) (*models.Movie, error)
	GetByIMDbID(ctx context.Context, imdbID string) (*models.Movie, error)
	GetByTMDbID(ctx context.Context, tmdbID int64) (*models.Movie, error)

	// 电影列表查询
	List(ctx context.Context, params *MovieListParams) ([]*models.Movie, int64, error)
	GetPublishedMovies(ctx context.Context, limit, offset int) ([]*models.Movie, error)
	GetMoviesByCategory(ctx context.Context, categoryID uint, limit, offset int) ([]*models.Movie, error)
	GetMoviesByGenre(ctx context.Context, genre string, limit, offset int) ([]*models.Movie, error)
	GetMoviesByYear(ctx context.Context, year int, limit, offset int) ([]*models.Movie, error)
	GetPopularMovies(ctx context.Context, limit int) ([]*models.Movie, error)
	GetTopRatedMovies(ctx context.Context, limit int) ([]*models.Movie, error)
	GetRecentMovies(ctx context.Context, limit int) ([]*models.Movie, error)

	// 电影搜索
	Search(ctx context.Context, params *MovieSearchParams) ([]*models.Movie, int64, error)
	SearchByTitle(ctx context.Context, title string, limit, offset int) ([]*models.Movie, error)

	// 电影统计
	GetMovieStats(ctx context.Context, movieID uint) (*MovieStats, error)
	GetGenreStats(ctx context.Context) ([]GenreStats, error)
	GetYearStats(ctx context.Context) ([]YearStats, error)

	// 电影操作
	Publish(ctx context.Context, movieID uint) error
	Unpublish(ctx context.Context, movieID uint) error
	IncrementViewCount(ctx context.Context, movieID uint) error
	UpdateRating(ctx context.Context, movieID uint, rating float64, count int64) error

	// 电影关联
	AddCategories(ctx context.Context, movieID uint, categoryIDs []uint) error
	RemoveCategories(ctx context.Context, movieID uint, categoryIDs []uint) error
	GetMovieCategories(ctx context.Context, movieID uint) ([]*models.Category, error)
}

// RatingRepository 评分仓储接口
type RatingRepository interface {
	BaseRepository[models.Rating]

	// 评分特定查询
	GetByUserAndMovie(ctx context.Context, userID, movieID uint) (*models.Rating, error)
	GetUserRatings(ctx context.Context, userID uint, limit, offset int) ([]*models.Rating, error)
	GetMovieRatings(ctx context.Context, movieID uint, limit, offset int) ([]*models.Rating, error)

	// 评分列表查询
	List(ctx context.Context, params *RatingListParams) ([]*models.Rating, int64, error)
	GetPublicRatings(ctx context.Context, limit, offset int) ([]*models.Rating, error)
	GetPendingRatings(ctx context.Context, limit, offset int) ([]*models.Rating, error)
	GetTopRatings(ctx context.Context, limit int) ([]*models.Rating, error)

	// 评分统计
	GetMovieRatingStats(ctx context.Context, movieID uint) (*MovieRatingStats, error)
	GetUserRatingStats(ctx context.Context, userID uint) (*UserRatingStats, error)
	GetRatingDistribution(ctx context.Context, movieID uint) ([]RatingDistribution, error)

	// 评分操作
	Approve(ctx context.Context, ratingID uint) error
	Reject(ctx context.Context, ratingID uint) error
	ToggleVisibility(ctx context.Context, ratingID uint) error
	IncrementLikeCount(ctx context.Context, ratingID uint) error
	DecrementLikeCount(ctx context.Context, ratingID uint) error

	// 评分验证
	HasUserRated(ctx context.Context, userID, movieID uint) (bool, error)
	CanUserRate(ctx context.Context, userID, movieID uint) (bool, error)
}

// 查询参数结构体
type UserListParams struct {
	Keyword  string             `json:"keyword"`
	Status   *models.UserStatus `json:"status"`
	Verified *bool              `json:"verified"`
	Limit    int                `json:"limit"`
	Offset   int                `json:"offset"`
	SortBy   string             `json:"sort_by"`
	SortDesc bool               `json:"sort_desc"`
}

type CategoryListParams struct {
	Keyword  string `json:"keyword"`
	Active   *bool  `json:"active"`
	Limit    int    `json:"limit"`
	Offset   int    `json:"offset"`
	SortBy   string `json:"sort_by"`
	SortDesc bool   `json:"sort_desc"`
}

type MovieListParams struct {
	Keyword     string              `json:"keyword"`
	Status      *models.MovieStatus `json:"status"`
	Published   *bool               `json:"published"`
	CategoryID  *uint               `json:"category_id"`
	Genre       string              `json:"genre"`
	Year        *int                `json:"year"`
	MinRating   *float64            `json:"min_rating"`
	MaxRating   *float64            `json:"max_rating"`
	MinRuntime  *int                `json:"min_runtime"`
	MaxRuntime  *int                `json:"max_runtime"`
	Limit       int                 `json:"limit"`
	Offset      int                 `json:"offset"`
	SortBy      string              `json:"sort_by"`
	SortDesc    bool                `json:"sort_desc"`
}

type MovieSearchParams struct {
	Query       string   `json:"query"`
	Genres      []string `json:"genres"`
	YearFrom    *int     `json:"year_from"`
	YearTo      *int     `json:"year_to"`
	MinRating   *float64 `json:"min_rating"`
	MaxRating   *float64 `json:"max_rating"`
	MinRuntime  *int     `json:"min_runtime"`
	MaxRuntime  *int     `json:"max_runtime"`
	Limit       int      `json:"limit"`
	Offset      int      `json:"offset"`
}

type RatingListParams struct {
	UserID   *uint                `json:"user_id"`
	MovieID  *uint                `json:"movie_id"`
	Status   *models.RatingStatus `json:"status"`
	Public   *bool                `json:"public"`
	MinScore *float64             `json:"min_score"`
	MaxScore *float64             `json:"max_score"`
	Limit    int                  `json:"limit"`
	Offset   int                  `json:"offset"`
	SortBy   string               `json:"sort_by"`
	SortDesc bool                 `json:"sort_desc"`
}

// 统计结构体
type UserStats struct {
	TotalRatings   int64   `json:"total_ratings"`
	AverageRating  float64 `json:"average_rating"`
	FavoriteGenres []string `json:"favorite_genres"`
	TotalMovies    int64   `json:"total_movies"`
}

type MovieStats struct {
	TotalRatings    int64   `json:"total_ratings"`
	AverageRating   float64 `json:"average_rating"`
	TotalViews      int64   `json:"total_views"`
	TotalComments   int64   `json:"total_comments"`
	PopularityScore float64 `json:"popularity_score"`
}

type MovieRatingStats struct {
	TotalRatings  int64   `json:"total_ratings"`
	AverageRating float64 `json:"average_rating"`
	RatingSum     float64 `json:"rating_sum"`
	Distribution  []RatingDistribution `json:"distribution"`
}

type UserRatingStats struct {
	TotalRatings   int64   `json:"total_ratings"`
	AverageRating  float64 `json:"average_rating"`
	HighestRating  float64 `json:"highest_rating"`
	LowestRating   float64 `json:"lowest_rating"`
	FavoriteGenres []string `json:"favorite_genres"`
}

type CategoryWithCount struct {
	*models.Category
	MovieCount int64 `json:"movie_count"`
}

type DailyStats struct {
	Date  string `json:"date"`
	Count int64  `json:"count"`
}

type GenreStats struct {
	Genre      string  `json:"genre"`
	Count      int64   `json:"count"`
	AvgRating  float64 `json:"avg_rating"`
	TotalViews int64   `json:"total_views"`
}

type YearStats struct {
	Year       int     `json:"year"`
	Count      int64   `json:"count"`
	AvgRating  float64 `json:"avg_rating"`
	TotalViews int64   `json:"total_views"`
}

type RatingDistribution struct {
	Score float64 `json:"score"`
	Count int64   `json:"count"`
}
```

### 步骤5：创建数据模型层配置文件

#### 5.1 创建数据库配置文件

```yaml
# configs/database.yaml
database:
  # 基础连接配置
  host: "localhost"
  port: 3306
  username: "root"
  password: "your_password"
  database: "movieinfo"
  charset: "utf8mb4"
  timezone: "Asia/Shanghai"

  # 连接池配置
  max_open_conns: 100
  max_idle_conns: 10
  conn_max_lifetime: "1h"
  conn_max_idle_time: "10m"

  # GORM配置
  log_level: 1  # 1=Silent, 2=Error, 3=Warn, 4=Info
  slow_threshold: "200ms"
  skip_default_transaction: false
  disable_foreign_key_constraint: false

  # 迁移配置
  auto_migrate: true

  # SSL配置
  ssl_mode: "disable"
  ssl_cert: ""
  ssl_key: ""
  ssl_ca: ""
```

#### 5.2 创建缓存配置文件

```yaml
# configs/cache.yaml
cache:
  # Redis连接配置
  host: "localhost"
  port: 6379
  password: ""
  db: 0

  # 连接池配置
  pool_size: 10
  min_idle_conns: 3
  max_conn_age: "30m"
  pool_timeout: "4s"
  idle_timeout: "5m"

  # 超时配置
  dial_timeout: "5s"
  read_timeout: "3s"
  write_timeout: "3s"

  # 缓存配置
  default_ttl: "1h"
  key_prefix: "movieinfo:"

  # 功能开关
  enabled: true
```

#### 5.3 创建数据模型层初始化脚本

```go
// internal/models/init.go
package models

import (
	"context"
	"fmt"

	"movieinfo/internal/cache"
	"movieinfo/internal/database"
	"movieinfo/pkg/config"
	"movieinfo/pkg/logger"
)

// DataLayer 数据层结构
type DataLayer struct {
	DB    *database.Manager
	Cache *cache.Manager
}

// InitDataLayer 初始化数据层
func InitDataLayer(cfg *config.Config, logger logger.Logger) (*DataLayer, error) {
	// 初始化数据库
	dbConfig := &database.Config{
		Host:                        cfg.Database.Host,
		Port:                        cfg.Database.Port,
		Username:                    cfg.Database.Username,
		Password:                    cfg.Database.Password,
		Database:                    cfg.Database.Database,
		Charset:                     cfg.Database.Charset,
		TimeZone:                    cfg.Database.TimeZone,
		MaxOpenConns:                cfg.Database.MaxOpenConns,
		MaxIdleConns:                cfg.Database.MaxIdleConns,
		ConnMaxLifetime:             cfg.Database.ConnMaxLifetime,
		ConnMaxIdleTime:             cfg.Database.ConnMaxIdleTime,
		LogLevel:                    cfg.Database.LogLevel,
		SlowThreshold:               cfg.Database.SlowThreshold,
		SkipDefaultTransaction:      cfg.Database.SkipDefaultTransaction,
		DisableForeignKeyConstraint: cfg.Database.DisableForeignKeyConstraint,
		AutoMigrate:                 cfg.Database.AutoMigrate,
		SSLMode:                     cfg.Database.SSLMode,
		SSLCert:                     cfg.Database.SSLCert,
		SSLKey:                      cfg.Database.SSLKey,
		SSLCA:                       cfg.Database.SSLCA,
	}

	dbManager, err := database.NewManager(dbConfig, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to create database manager: %w", err)
	}

	if err := dbManager.Connect(); err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	// 执行数据库迁移
	if err := dbManager.AutoMigrate(); err != nil {
		return nil, fmt.Errorf("failed to migrate database: %w", err)
	}

	// 初始化缓存
	cacheConfig := &cache.Config{
		Host:         cfg.Cache.Host,
		Port:         cfg.Cache.Port,
		Password:     cfg.Cache.Password,
		DB:           cfg.Cache.DB,
		PoolSize:     cfg.Cache.PoolSize,
		MinIdleConns: cfg.Cache.MinIdleConns,
		MaxConnAge:   cfg.Cache.MaxConnAge,
		PoolTimeout:  cfg.Cache.PoolTimeout,
		IdleTimeout:  cfg.Cache.IdleTimeout,
		DialTimeout:  cfg.Cache.DialTimeout,
		ReadTimeout:  cfg.Cache.ReadTimeout,
		WriteTimeout: cfg.Cache.WriteTimeout,
		DefaultTTL:   cfg.Cache.DefaultTTL,
		KeyPrefix:    cfg.Cache.KeyPrefix,
		Enabled:      cfg.Cache.Enabled,
	}

	cacheManager, err := cache.NewManager(cacheConfig, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to create cache manager: %w", err)
	}

	if err := cacheManager.Connect(); err != nil {
		return nil, fmt.Errorf("failed to connect to cache: %w", err)
	}

	return &DataLayer{
		DB:    dbManager,
		Cache: cacheManager,
	}, nil
}

// Close 关闭数据层连接
func (dl *DataLayer) Close() error {
	var errs []error

	if dl.Cache != nil {
		if err := dl.Cache.Close(); err != nil {
			errs = append(errs, fmt.Errorf("failed to close cache: %w", err))
		}
	}

	if dl.DB != nil {
		if err := dl.DB.Close(); err != nil {
			errs = append(errs, fmt.Errorf("failed to close database: %w", err))
		}
	}

	if len(errs) > 0 {
		return fmt.Errorf("errors closing data layer: %v", errs)
	}

	return nil
}

// HealthCheck 健康检查
func (dl *DataLayer) HealthCheck(ctx context.Context) error {
	// 检查数据库连接
	if err := dl.DB.Ping(ctx); err != nil {
		return fmt.Errorf("database health check failed: %w", err)
	}

	// 检查缓存连接
	if dl.Cache.IsEnabled() {
		if err := dl.Cache.Ping(ctx); err != nil {
			return fmt.Errorf("cache health check failed: %w", err)
		}
	}

	return nil
}
```

## 测试验证

### 单元测试

#### 1. 数据模型测试

```go
// internal/models/user_test.go
package models

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestUser_HashPassword(t *testing.T) {
	user := &User{
		Username: "testuser",
		Email:    "test@example.com",
		Password: "password123",
	}

	err := user.HashPassword()
	require.NoError(t, err)
	assert.NotEqual(t, "password123", user.Password)
	assert.True(t, user.CheckPassword("password123"))
	assert.False(t, user.CheckPassword("wrongpassword"))
}

func TestUser_IsActive(t *testing.T) {
	tests := []struct {
		name     string
		status   UserStatus
		expected bool
	}{
		{"Active user", UserStatusActive, true},
		{"Inactive user", UserStatusInactive, false},
		{"Suspended user", UserStatusSuspended, false},
		{"Banned user", UserStatusBanned, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			user := &User{Status: tt.status}
			assert.Equal(t, tt.expected, user.IsActive())
		})
	}
}

func TestUser_UpdateLoginInfo(t *testing.T) {
	user := &User{LoginCount: 5}
	before := time.Now()

	user.UpdateLoginInfo()

	assert.Equal(t, int64(6), user.LoginCount)
	assert.NotNil(t, user.LastLoginAt)
	assert.True(t, user.LastLoginAt.After(before))
}

func TestUser_Verify(t *testing.T) {
	user := &User{
		Status:     UserStatusInactive,
		IsVerified: false,
	}
	before := time.Now()

	user.Verify()

	assert.True(t, user.IsVerified)
	assert.NotNil(t, user.VerifiedAt)
	assert.True(t, user.VerifiedAt.After(before))
	assert.Equal(t, UserStatusActive, user.Status)
}
```

#### 2. 数据库管理器测试

```go
// internal/database/manager_test.go
package database

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"movieinfo/pkg/logger"
)

func TestManager_Connect(t *testing.T) {
	config := DefaultConfig()
	config.Database = "test_movieinfo"

	logger := logger.NewNopLogger()
	manager, err := NewManager(config, logger)
	require.NoError(t, err)

	err = manager.Connect()
	require.NoError(t, err)
	defer manager.Close()

	// 测试连接
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	err = manager.Ping(ctx)
	assert.NoError(t, err)

	// 测试统计信息
	stats := manager.Stats()
	assert.GreaterOrEqual(t, stats.MaxOpenConnections, 0)
}

func TestManager_Transaction(t *testing.T) {
	config := DefaultConfig()
	config.Database = "test_movieinfo"

	logger := logger.NewNopLogger()
	manager, err := NewManager(config, logger)
	require.NoError(t, err)

	err = manager.Connect()
	require.NoError(t, err)
	defer manager.Close()

	// 测试事务
	err = manager.Transaction(func(tx *gorm.DB) error {
		// 在事务中执行一些操作
		return nil
	})
	assert.NoError(t, err)
}
```

#### 3. 缓存管理器测试

```go
// internal/cache/manager_test.go
package cache

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"movieinfo/pkg/logger"
)

func TestManager_SetGet(t *testing.T) {
	config := DefaultConfig()
	config.DB = 1 // 使用测试数据库

	logger := logger.NewNopLogger()
	manager, err := NewManager(config, logger)
	require.NoError(t, err)

	err = manager.Connect()
	require.NoError(t, err)
	defer manager.Close()

	ctx := context.Background()

	// 测试设置和获取
	testData := map[string]interface{}{
		"name": "test",
		"age":  25,
	}

	err = manager.Set(ctx, "test:user:1", testData, time.Minute)
	require.NoError(t, err)

	var result map[string]interface{}
	err = manager.Get(ctx, "test:user:1", &result)
	require.NoError(t, err)
	assert.Equal(t, "test", result["name"])
	assert.Equal(t, float64(25), result["age"])

	// 测试删除
	err = manager.Delete(ctx, "test:user:1")
	require.NoError(t, err)

	err = manager.Get(ctx, "test:user:1", &result)
	assert.Error(t, err)
}

func TestManager_Increment(t *testing.T) {
	config := DefaultConfig()
	config.DB = 1

	logger := logger.NewNopLogger()
	manager, err := NewManager(config, logger)
	require.NoError(t, err)

	err = manager.Connect()
	require.NoError(t, err)
	defer manager.Close()

	ctx := context.Background()

	// 测试递增
	value, err := manager.Increment(ctx, "test:counter", 1)
	require.NoError(t, err)
	assert.Equal(t, int64(1), value)

	value, err = manager.Increment(ctx, "test:counter", 5)
	require.NoError(t, err)
	assert.Equal(t, int64(6), value)

	// 清理
	manager.Delete(ctx, "test:counter")
}
```

### 集成测试

```go
// tests/integration/data_layer_test.go
package integration

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"

	"movieinfo/internal/models"
	"movieinfo/pkg/config"
	"movieinfo/pkg/logger"
)

type DataLayerTestSuite struct {
	suite.Suite
	dataLayer *models.DataLayer
	ctx       context.Context
}

func (suite *DataLayerTestSuite) SetupSuite() {
	// 加载测试配置
	cfg := config.LoadTestConfig()
	logger := logger.NewNopLogger()

	// 初始化数据层
	dataLayer, err := models.InitDataLayer(cfg, logger)
	suite.Require().NoError(err)

	suite.dataLayer = dataLayer
	suite.ctx = context.Background()
}

func (suite *DataLayerTestSuite) TearDownSuite() {
	if suite.dataLayer != nil {
		suite.dataLayer.Close()
	}
}

func (suite *DataLayerTestSuite) TestHealthCheck() {
	err := suite.dataLayer.HealthCheck(suite.ctx)
	suite.NoError(err)
}

func (suite *DataLayerTestSuite) TestUserCRUD() {
	db := suite.dataLayer.DB.DB()

	// 创建用户
	user := &models.User{
		Username: "testuser",
		Email:    "test@example.com",
		Password: "password123",
		Nickname: "Test User",
	}

	err := db.Create(user).Error
	suite.NoError(err)
	suite.NotZero(user.ID)

	// 读取用户
	var foundUser models.User
	err = db.First(&foundUser, user.ID).Error
	suite.NoError(err)
	suite.Equal(user.Username, foundUser.Username)
	suite.Equal(user.Email, foundUser.Email)

	// 更新用户
	foundUser.Nickname = "Updated User"
	err = db.Save(&foundUser).Error
	suite.NoError(err)

	// 验证更新
	var updatedUser models.User
	err = db.First(&updatedUser, user.ID).Error
	suite.NoError(err)
	suite.Equal("Updated User", updatedUser.Nickname)

	// 删除用户
	err = db.Delete(&updatedUser).Error
	suite.NoError(err)
}

func (suite *DataLayerTestSuite) TestCacheIntegration() {
	cache := suite.dataLayer.Cache

	if !cache.IsEnabled() {
		suite.T().Skip("Cache is disabled")
	}

	// 测试缓存操作
	testData := map[string]interface{}{
		"id":   1,
		"name": "Test Movie",
	}

	err := cache.Set(suite.ctx, "movie:1", testData, time.Minute)
	suite.NoError(err)

	var result map[string]interface{}
	err = cache.Get(suite.ctx, "movie:1", &result)
	suite.NoError(err)
	suite.Equal(testData["name"], result["name"])

	// 清理
	cache.Delete(suite.ctx, "movie:1")
}

func TestDataLayerTestSuite(t *testing.T) {
	suite.Run(t, new(DataLayerTestSuite))
}
```

## 预期结果

完成本步骤后，您应该拥有：

1. **完整的数据模型定义**：
   - 用户模型（User）
   - 电影分类模型（Category）
   - 电影模型（Movie）
   - 评分模型（Rating）
   - 关联模型（MovieCategory）

2. **数据库管理器**：
   - 数据库连接管理
   - 连接池配置
   - 事务支持
   - 自动迁移
   - 日志集成

3. **缓存管理器**：
   - Redis连接管理
   - 缓存操作接口
   - 连接池配置
   - 管道支持

4. **数据访问层接口**：
   - 基础仓储接口
   - 特定业务接口
   - 查询参数结构
   - 统计结构定义

5. **配置文件**：
   - 数据库配置
   - 缓存配置
   - 环境隔离

6. **测试覆盖**：
   - 单元测试
   - 集成测试
   - 健康检查

## 注意事项

### 安全性

1. **密码安全**：
   - 使用bcrypt加密密码
   - 密码字段不在JSON中序列化
   - 密码复杂度验证

2. **SQL注入防护**：
   - 使用GORM的参数化查询
   - 输入验证和清理
   - 避免动态SQL拼接

3. **数据验证**：
   - 模型字段验证
   - 业务规则验证
   - 数据完整性约束

### 性能优化

1. **数据库优化**：
   - 合理的索引设计
   - 连接池配置优化
   - 慢查询监控
   - 查询优化

2. **缓存策略**：
   - 合理的TTL设置
   - 缓存键命名规范
   - 缓存穿透防护
   - 缓存雪崩防护

3. **内存管理**：
   - 避免内存泄漏
   - 合理的批量操作大小
   - 连接资源及时释放

### 维护性

1. **代码组织**：
   - 清晰的目录结构
   - 接口与实现分离
   - 统一的错误处理

2. **日志记录**：
   - 详细的操作日志
   - 错误日志记录
   - 性能监控日志

3. **测试覆盖**：
   - 完整的单元测试
   - 集成测试
   - 性能测试

## 下一步骤

完成数据模型层开发后，接下来将进行：

1. **用户服务开发**（07-用户服务开发.md）
   - 用户仓储实现
   - 用户业务逻辑
   - 用户gRPC服务
   - 用户认证授权

2. **关键检查点**：
   - [ ] 所有数据模型定义完成
   - [ ] 数据库连接正常
   - [ ] 缓存连接正常
   - [ ] 数据模型测试通过
   - [ ] 数据库迁移成功
   - [ ] 配置文件完整
   - [ ] 日志记录正常
   - [ ] 健康检查通过

请确保所有检查点都已完成，然后继续下一个开发步骤。
	"fmt"
	"time"
)

// Config 缓存配置
type Config struct {
	// Redis连接配置
	Host     string `mapstructure:"host" json:"host"`
	Port     int    `mapstructure:"port" json:"port"`
	Password string `mapstructure:"password" json:"-"`
	DB       int    `mapstructure:"db" json:"db"`

	// 连接池配置
	PoolSize     int           `mapstructure:"pool_size" json:"pool_size"`
	MinIdleConns int           `mapstructure:"min_idle_conns" json:"min_idle_conns"`
	MaxConnAge   time.Duration `mapstructure:"max_conn_age" json:"max_conn_age"`
	PoolTimeout  time.Duration `mapstructure:"pool_timeout" json:"pool_timeout"`
	IdleTimeout  time.Duration `mapstructure:"idle_timeout" json:"idle_timeout"`

	// 超时配置
	DialTimeout  time.Duration `mapstructure:"dial_timeout" json:"dial_timeout"`
	ReadTimeout  time.Duration `mapstructure:"read_timeout" json:"read_timeout"`
	WriteTimeout time.Duration `mapstructure:"write_timeout" json:"write_timeout"`

	// 缓存配置
	DefaultTTL time.Duration `mapstructure:"default_ttl" json:"default_ttl"`
	KeyPrefix  string        `mapstructure:"key_prefix" json:"key_prefix"`

	// 功能开关
	Enabled bool `mapstructure:"enabled" json:"enabled"`
}

// DefaultConfig 返回默认配置
func DefaultConfig() *Config {
	return &Config{
		Host:     "localhost",
		Port:     6379,
		Password: "",
		DB:       0,

		PoolSize:     10,
		MinIdleConns: 3,
		MaxConnAge:   30 * time.Minute,
		PoolTimeout:  4 * time.Second,
		IdleTimeout:  5 * time.Minute,

		DialTimeout:  5 * time.Second,
		ReadTimeout:  3 * time.Second,
		WriteTimeout: 3 * time.Second,

		DefaultTTL: 1 * time.Hour,
		KeyPrefix:  "movieinfo:",

		Enabled: true,
	}
}

// Address 返回Redis地址
func (c *Config) Address() string {
	return fmt.Sprintf("%s:%d", c.Host, c.Port)
}

// Validate 验证配置
func (c *Config) Validate() error {
	if !c.Enabled {
		return nil
	}

	if c.Host == "" {
		return fmt.Errorf("redis host is required")
	}
	if c.Port <= 0 || c.Port > 65535 {
		return fmt.Errorf("redis port must be between 1 and 65535")
	}
	if c.DB < 0 || c.DB > 15 {
		return fmt.Errorf("redis db must be between 0 and 15")
	}
	if c.PoolSize <= 0 {
		return fmt.Errorf("pool_size must be greater than 0")
	}
	if c.MinIdleConns < 0 {
		return fmt.Errorf("min_idle_conns cannot be negative")
	}
	if c.MinIdleConns > c.PoolSize {
		return fmt.Errorf("min_idle_conns cannot be greater than pool_size")
	}
	return nil
}
```

#### 3.2 创建缓存管理器

```go
// internal/cache