# 06-数据模型层开发

## 目标说明

数据模型层是 MovieInfo 项目的核心基础设施，承担着数据持久化、缓存管理、数据访问抽象等关键职责。本步骤将构建一个完整、高效、可扩展的数据模型层，包括：

### 核心功能
- **数据模型定义**：设计符合业务需求的实体模型，包含完整的字段定义、约束条件、关联关系
- **数据访问层（DAL）**：提供统一的数据访问接口，封装复杂的数据库操作逻辑
- **数据库连接管理**：实现高效的连接池管理、事务处理、性能监控
- **缓存机制集成**：构建多层缓存策略，提升系统响应速度和并发能力
- **数据验证与安全**：确保数据完整性、防止SQL注入、保护敏感信息

### 设计目标
- **高性能**：通过连接池、缓存、索引优化等手段提升数据访问性能
- **高可用**：支持数据库故障转移、缓存降级、健康检查等可用性保障
- **可扩展**：采用接口抽象、依赖注入等设计模式，便于功能扩展和测试
- **易维护**：清晰的代码结构、完善的日志记录、全面的测试覆盖

## 前置条件

在开始本步骤之前，请确保已完成以下准备工作：

### 项目基础准备
1. **项目初始化**（01-项目初始化.md）
   - 项目目录结构已创建
   - Go 模块已初始化
   - 基础依赖已安装

2. **数据库设计**（02-数据库设计.md）
   - 数据库表结构已设计
   - 索引策略已确定
   - 关联关系已明确

3. **配置管理系统**（03-配置管理系统.md）
   - 配置文件结构已建立
   - 环境变量管理已实现
   - 配置验证机制已完善

4. **日志系统**（04-日志系统.md）
   - 日志框架已集成
   - 日志级别已配置
   - 日志格式已统一

5. **gRPC协议定义**（05-gRPC协议定义.md）
   - Protocol Buffers 文件已定义
   - gRPC 服务接口已生成
   - 数据传输对象已确定

### 环境依赖检查

#### 数据库环境
- **MySQL 8.0+** 或 **PostgreSQL 13+** 已安装并运行
- 数据库用户权限已配置（CREATE、DROP、ALTER、SELECT、INSERT、UPDATE、DELETE）
- 数据库连接参数已确认（主机、端口、用户名、密码、数据库名）

#### 缓存环境
- **Redis 6.0+** 已安装并运行
- Redis 配置已优化（内存策略、持久化、安全设置）
- Redis 连接参数已确认（主机、端口、密码、数据库索引）

#### 开发工具
- **Go 1.19+** 开发环境
- **Git** 版本控制工具
- **Make** 构建工具（可选）
- **Docker** 容器化工具（可选，用于本地开发环境）

### 依赖包准备

确保以下 Go 依赖包已正确安装：

```bash
# 核心 ORM 和数据库驱动
go get gorm.io/gorm@latest
go get gorm.io/driver/mysql@latest     # MySQL 驱动
go get gorm.io/driver/postgres@latest  # PostgreSQL 驱动

# 缓存客户端
go get github.com/go-redis/redis/v8@latest

# 数据验证
go get github.com/go-playground/validator/v10@latest

# 密码加密
go get golang.org/x/crypto@latest

# 工具库
go get github.com/google/uuid@latest
go get github.com/shopspring/decimal@latest
```

## 技术要点

### 设计原则

我们遵循以下核心设计原则来构建高质量、可维护的数据模型层：

#### 1. 分层架构（Layered Architecture）
- **职责分离**：将数据访问、业务逻辑、表示层清晰分离
- **依赖方向**：上层依赖下层，下层不依赖上层
- **接口隔离**：通过接口定义层间契约，降低耦合度
- **可测试性**：每层都可以独立进行单元测试

#### 2. 接口抽象（Interface Abstraction）
- **契约定义**：使用接口定义数据访问契约，而非具体实现
- **实现替换**：支持不同数据源的实现切换（如测试时使用内存数据库）
- **依赖倒置**：高层模块依赖抽象接口，不依赖具体实现
- **扩展性**：新增数据源或修改实现不影响上层业务逻辑

#### 3. 依赖注入（Dependency Injection）
- **松耦合**：通过构造函数或方法参数注入依赖
- **配置化**：依赖关系通过配置文件或代码配置管理
- **测试友好**：便于在测试中注入 Mock 对象
- **生命周期管理**：统一管理对象的创建和销毁

#### 4. 事务管理（Transaction Management）
- **ACID 保证**：确保数据操作的原子性、一致性、隔离性、持久性
- **嵌套事务**：支持事务的嵌套和传播
- **回滚机制**：异常情况下自动回滚事务
- **性能优化**：合理控制事务范围，避免长事务

#### 5. 错误处理（Error Handling）
- **统一错误类型**：定义标准的错误类型和错误码
- **错误传播**：错误信息在调用链中正确传播
- **日志记录**：关键错误信息记录到日志系统
- **用户友好**：向用户返回有意义的错误信息

#### 6. 性能优化（Performance Optimization）
- **连接池管理**：合理配置数据库连接池参数
- **查询优化**：使用索引、避免 N+1 查询、批量操作
- **缓存策略**：多层缓存设计，减少数据库访问
- **监控指标**：收集性能指标，持续优化

### 技术选型

经过综合考虑性能、生态、学习成本、维护性等因素，我们选择以下技术栈：

#### 1. ORM框架：GORM v2
**选择理由：**
- **成熟稳定**：Go 语言生态中最流行和成熟的 ORM 框架
- **功能丰富**：支持自动迁移、关联查询、钩子函数、软删除等高级特性
- **性能优良**：内置连接池、预编译语句、批量操作等性能优化
- **社区活跃**：活跃的社区支持，丰富的插件生态
- **文档完善**：详细的官方文档和示例代码

**核心特性：**
- 自动迁移和表结构同步
- 丰富的查询 API（链式调用、原生 SQL、子查询）
- 关联关系管理（一对一、一对多、多对多）
- 钩子函数支持（BeforeCreate、AfterUpdate 等）
- 软删除和乐观锁支持

#### 2. 数据库驱动：MySQL/PostgreSQL Driver
**MySQL Driver 特点：**
- **高性能**：官方维护的高性能驱动
- **兼容性好**：支持 MySQL 5.7+ 的所有特性
- **连接池**：内置连接池管理和监控

**PostgreSQL Driver 特点：**
- **功能强大**：支持 PostgreSQL 的高级特性（JSON、数组、自定义类型）
- **事务支持**：完善的事务和锁机制
- **扩展性**：丰富的扩展插件支持

#### 3. 缓存系统：Redis
**选择理由：**
- **高性能**：内存存储，微秒级响应时间
- **数据结构丰富**：支持字符串、哈希、列表、集合、有序集合等
- **持久化**：支持 RDB 和 AOF 两种持久化方式
- **高可用**：支持主从复制、哨兵模式、集群模式
- **生态丰富**：丰富的客户端库和监控工具

**应用场景：**
- 热点数据缓存（用户信息、电影详情）
- 会话存储（用户登录状态）
- 计数器（观看次数、点赞数）
- 排行榜（热门电影、评分排序）
- 分布式锁（防止重复操作）

#### 4. 连接池：database/sql 标准库
**特点：**
- **标准化**：Go 标准库提供的数据库连接池
- **自动管理**：自动管理连接的创建、复用、销毁
- **并发安全**：线程安全的连接池实现
- **监控支持**：提供连接池状态监控接口

**配置参数：**
- MaxOpenConns：最大打开连接数
- MaxIdleConns：最大空闲连接数
- ConnMaxLifetime：连接最大生存时间
- ConnMaxIdleTime：连接最大空闲时间

#### 5. 数据验证：validator v10
**选择理由：**
- **功能强大**：支持结构体字段验证、自定义验证规则
- **性能优秀**：基于反射的高性能验证引擎
- **标签丰富**：内置丰富的验证标签（required、email、min、max 等）
- **国际化**：支持多语言错误消息
- **扩展性**：支持自定义验证函数和错误消息

#### 6. 迁移工具：GORM AutoMigrate + 自定义迁移
**GORM AutoMigrate：**
- 自动创建表和索引
- 自动添加新字段
- 保持向后兼容性

**自定义迁移：**
- 复杂的数据迁移逻辑
- 数据转换和清理
- 版本控制和回滚支持

### 架构设计

数据模型层采用分层架构设计，确保职责清晰、易于测试和维护。整体架构分为四个主要层次：

#### 架构层次图

```
数据模型层分层架构：

┌─────────────────────────────────────────────────────────────┐
│                    Business Logic Layer                     │
│                      (业务逻辑层)                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │ User Service│  │Movie Service│  │Rating Service│         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────┬───────────────────────────────────────┘
                      │ 依赖注入 & 接口调用
┌─────────────────────┴───────────────────────────────────────┐
│                  Data Access Layer (DAL)                   │
│                     (数据访问层)                             │
├─────────────────────────────────────────────────────────────┤
│  Repository Interface  │  Service Interface  │  DTO Models  │
│  ┌─────────────────┐   │  ┌─────────────────┐ │ ┌─────────┐ │
│  │ UserRepository  │   │  │ CacheService    │ │ │ Request │ │
│  │ MovieRepository │   │  │ ValidationSvc   │ │ │Response │ │
│  │ RatingRepository│   │  │ TransactionSvc  │ │ │ DTO     │ │
│  └─────────────────┘   │  └─────────────────┘ │ └─────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Repository Impl      │  Service Impl       │  Converters  │
│  ┌─────────────────┐   │  ┌─────────────────┐ │ ┌─────────┐ │
│  │ GORM Repository │   │  │ Redis Cache     │ │ │ Model   │ │
│  │ Implementation  │   │  │ Implementation  │ │ │ to DTO  │ │
│  └─────────────────┘   │  └─────────────────┘ │ └─────────┘ │
└─────────────────────┬───────────────────────────────────────┘
                      │ 数据持久化 & 缓存操作
┌─────────────────────┴───────────────────────────────────────┐
│                    Data Model Layer                        │
│                     (数据模型层)                             │
├─────────────────────────────────────────────────────────────┤
│  Entity Models     │  Database Manager   │  Cache Manager  │
│  ┌─────────────┐   │  ┌─────────────────┐ │ ┌─────────────┐ │
│  │ User Model  │   │  │ Connection Pool │ │ │ Redis Pool  │ │
│  │ Movie Model │   │  │ Transaction Mgr │ │ │ Key Manager │ │
│  │ Rating Model│   │  │ Migration Tool  │ │ │ Serializer  │ │
│  └─────────────┘   │  └─────────────────┘ │ └─────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  GORM Models      │  Connection Pool    │  Redis Client   │
│  ┌─────────────┐   │  ┌─────────────────┐ │ ┌─────────────┐ │
│  │ Struct Tags │   │  │ Health Check    │ │ │ Pub/Sub     │ │
│  │ Hooks       │   │  │ Metrics Monitor │ │ │ Pipeline    │ │
│  │ Validations │   │  │ Query Logger    │ │ │ Cluster     │ │
│  └─────────────┘   │  └─────────────────┘ │ └─────────────┘ │
└─────────────────────┬───────────────────────────────────────┘
                      │ 网络连接 & 数据存储
┌─────────────────────┴───────────────────────────────────────┐
│                   Infrastructure Layer                     │
│                     (基础设施层)                             │
├─────────────────────────────────────────────────────────────┤
│     MySQL/PostgreSQL Database    │         Redis Cache     │
│  ┌─────────────────────────────┐  │  ┌─────────────────────┐ │
│  │ Tables: users, movies,      │  │  │ Cache: sessions,    │ │
│  │         ratings, categories │  │  │        hot_data,    │ │
│  │ Indexes: Primary, Foreign,  │  │  │        counters,    │ │
│  │          Composite, Unique  │  │  │        rankings     │ │
│  │ Constraints: FK, Check      │  │  │ TTL: Auto Expire    │ │
│  └─────────────────────────────┘  │  └─────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

#### 层次职责说明

**1. 业务逻辑层（Business Logic Layer）**
- **职责**：实现具体的业务规则和流程控制
- **组件**：各种业务服务（UserService、MovieService、RatingService）
- **特点**：不直接操作数据库，通过数据访问层接口获取数据

**2. 数据访问层（Data Access Layer）**
- **职责**：提供统一的数据访问接口，封装数据操作逻辑
- **组件**：
  - Repository 接口：定义数据访问契约
  - Service 接口：定义辅助服务契约（缓存、验证、事务）
  - DTO 模型：数据传输对象
  - 具体实现：Repository 和 Service 的具体实现
  - 转换器：模型与 DTO 之间的转换逻辑

**3. 数据模型层（Data Model Layer）**
- **职责**：定义数据结构、管理数据库连接、处理缓存操作
- **组件**：
  - 实体模型：业务实体的数据结构定义
  - 数据库管理器：连接池、事务、迁移管理
  - 缓存管理器：Redis 连接、操作、监控

**4. 基础设施层（Infrastructure Layer）**
- **职责**：提供底层的数据存储和缓存服务
- **组件**：MySQL/PostgreSQL 数据库、Redis 缓存服务

#### 核心设计模式

**1. 仓储模式（Repository Pattern）**
```go
// 接口定义
type UserRepository interface {
    Create(ctx context.Context, user *User) error
    GetByID(ctx context.Context, id uint64) (*User, error)
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id uint64) error
}

// 具体实现
type userRepository struct {
    db *gorm.DB
    cache CacheManager
}
```

**2. 工厂模式（Factory Pattern）**
```go
// 数据库连接工厂
type DatabaseFactory interface {
    CreateConnection(config *Config) (*gorm.DB, error)
}

// 缓存连接工厂
type CacheFactory interface {
    CreateClient(config *Config) (redis.Cmdable, error)
}
```

**3. 策略模式（Strategy Pattern）**
```go
// 缓存策略接口
type CacheStrategy interface {
    Set(key string, value interface{}, ttl time.Duration) error
    Get(key string) (interface{}, error)
    Delete(key string) error
}

// 不同的缓存策略实现
type LRUCacheStrategy struct{}
type TTLCacheStrategy struct{}
```

## 实现步骤

### 步骤1：定义数据模型实体

数据模型实体是整个数据层的核心，定义了业务对象的数据结构、约束条件、关联关系和业务方法。我们采用组合模式设计基础模型，提供通用功能的复用。

#### 1.1 创建基础模型

基础模型提供了所有实体的通用字段和方法，包括主键、时间戳、软删除等功能。通过组合基础模型，其他实体可以继承这些通用功能。

```go
// internal/models/base.go
package models

import (
	"time"
	"errors"
	"fmt"

	"gorm.io/gorm"
)

// BaseModel 基础模型，包含所有实体的通用字段
// 提供主键、创建时间、更新时间、软删除等基础功能
type BaseModel struct {
	// ID 主键，使用 uint64 类型支持大数据量
	// gorm:"primarykey" 指定为主键
	// json:"id" 指定 JSON 序列化字段名
	ID uint64 `gorm:"primarykey" json:"id"`
	
	// CreatedAt 创建时间，记录数据首次插入的时间
	// gorm:"not null;default:CURRENT_TIMESTAMP" 设置为非空且有默认值
	// json:"created_at" 指定 JSON 序列化字段名
	CreatedAt time.Time `gorm:"not null;default:CURRENT_TIMESTAMP" json:"created_at"`
	
	// UpdatedAt 更新时间，记录数据最后修改的时间
	// gorm:"not null;default:CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP" 
	// 设置为非空，默认值为当前时间，更新时自动更新为当前时间
	UpdatedAt time.Time `gorm:"not null;default:CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP" json:"updated_at"`
	
	// DeletedAt 软删除时间，GORM 内置软删除字段
	// gorm:"index" 为软删除字段创建索引，提高查询性能
	// json:"deleted_at,omitempty" 序列化时如果为空则忽略该字段
	DeletedAt gorm.DeletedAt `gorm:"index" json:"deleted_at,omitempty"`
}

// SoftDeleteModel 软删除模型，在基础模型基础上增加软删除标记
// 适用于需要明确软删除状态的业务场景
type SoftDeleteModel struct {
	BaseModel
	
	// IsDeleted 软删除标记，true 表示已删除，false 表示正常
	// gorm:"not null;default:false;index" 设置为非空，默认值为 false，并创建索引
	// 索引可以提高按删除状态查询的性能
	IsDeleted bool `gorm:"not null;default:false;index" json:"is_deleted"`
}

// TimestampModel 时间戳模型，仅包含时间戳字段，不包含主键
// 适用于关联表或不需要独立主键的场景
type TimestampModel struct {
	// 创建时间
	CreatedAt time.Time `gorm:"not null;default:CURRENT_TIMESTAMP" json:"created_at"`
	
	// 更新时间
	UpdatedAt time.Time `gorm:"not null;default:CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP" json:"updated_at"`
	
	// 软删除时间
	DeletedAt gorm.DeletedAt `gorm:"index" json:"deleted_at,omitempty"`
}

// TableNamer 表名接口，用于自定义表名
// 实现此接口的模型可以自定义数据库表名
type TableNamer interface {
	TableName() string
}

// Validator 验证接口，用于模型数据验证
// 实现此接口的模型可以自定义验证逻辑
type Validator interface {
	Validate() error
}

// Sanitizer 数据清理接口，用于数据清理和格式化
// 实现此接口的模型可以自定义数据清理逻辑
type Sanitizer interface {
	Sanitize()
}

// BeforeCreate GORM 钩子函数：在创建记录前执行
// 自动设置创建时间和更新时间
func (m *BaseModel) BeforeCreate(tx *gorm.DB) error {
	now := time.Now()
	
	// 设置创建时间和更新时间为当前时间
	m.CreatedAt = now
	m.UpdatedAt = now
	
	return nil
}

// BeforeUpdate GORM 钩子函数：在更新记录前执行
// 自动更新修改时间
func (m *BaseModel) BeforeUpdate(tx *gorm.DB) error {
	// 更新修改时间为当前时间
	m.UpdatedAt = time.Now()
	return nil
}

// AfterFind GORM 钩子函数：在查询记录后执行
// 可用于数据后处理，如解密、格式化等
func (m *BaseModel) AfterFind(tx *gorm.DB) error {
	// 默认不做任何处理，子模型可以重写此方法
	return nil
}

// IsZero 检查模型是否为零值
// 通过检查主键是否为 0 来判断模型是否已初始化
func (m *BaseModel) IsZero() bool {
	return m.ID == 0
}

// IsNew 检查模型是否为新记录
// 新记录的特征是主键为 0 且没有创建时间
func (m *BaseModel) IsNew() bool {
	return m.ID == 0 && m.CreatedAt.IsZero()
}

// GetID 获取模型主键
func (m *BaseModel) GetID() uint64 {
	return m.ID
}

// SetID 设置模型主键
// 注意：通常不建议手动设置主键，应由数据库自动生成
func (m *BaseModel) SetID(id uint64) {
	m.ID = id
}

// GetCreatedAt 获取创建时间
func (m *BaseModel) GetCreatedAt() time.Time {
	return m.CreatedAt
}

// GetUpdatedAt 获取更新时间
func (m *BaseModel) GetUpdatedAt() time.Time {
	return m.UpdatedAt
}

// IsDeleted 检查记录是否被软删除
func (m *BaseModel) IsDeleted() bool {
	return m.DeletedAt.Valid
}

// GetAge 获取记录存在时长
func (m *BaseModel) GetAge() time.Duration {
	if m.CreatedAt.IsZero() {
		return 0
	}
	return time.Since(m.CreatedAt)
}

// GetLastModified 获取最后修改时长
func (m *BaseModel) GetLastModified() time.Duration {
	if m.UpdatedAt.IsZero() {
		return 0
	}
	return time.Since(m.UpdatedAt)
}

// String 实现 Stringer 接口，提供模型的字符串表示
func (m *BaseModel) String() string {
	return fmt.Sprintf("BaseModel{ID: %d, CreatedAt: %v, UpdatedAt: %v}", 
		m.ID, m.CreatedAt, m.UpdatedAt)
}

// Validate 基础验证方法
// 子模型可以重写此方法实现自定义验证逻辑
func (m *BaseModel) Validate() error {
	// 检查时间字段的合理性
	if !m.CreatedAt.IsZero() && !m.UpdatedAt.IsZero() {
		if m.UpdatedAt.Before(m.CreatedAt) {
			return errors.New("更新时间不能早于创建时间")
		}
	}
	
	return nil
}

// 软删除模型的额外方法

// MarkAsDeleted 标记为已删除
func (m *SoftDeleteModel) MarkAsDeleted() {
	m.IsDeleted = true
}

// MarkAsActive 标记为活跃状态
func (m *SoftDeleteModel) MarkAsActive() {
	m.IsDeleted = false
}

// IsActive 检查是否为活跃状态
func (m *SoftDeleteModel) IsActive() bool {
	return !m.IsDeleted && !m.DeletedAt.Valid
}

// String 软删除模型的字符串表示
func (m *SoftDeleteModel) String() string {
	return fmt.Sprintf("SoftDeleteModel{%s, IsDeleted: %t}", 
		m.BaseModel.String(), m.IsDeleted)
}
```

#### 基础模型设计说明

**1. 字段设计原则**
- **主键设计**：使用 `uint64` 类型，支持大数据量场景
- **时间戳**：统一使用 `time.Time` 类型，便于时区处理和格式化
- **软删除**：同时支持 GORM 内置软删除和自定义软删除标记
- **索引优化**：为常用查询字段创建索引，提高查询性能

**2. 钩子函数设计**
- **BeforeCreate**：创建前自动设置时间戳
- **BeforeUpdate**：更新前自动更新修改时间
- **AfterFind**：查询后可进行数据后处理

**3. 方法设计**
- **状态检查**：提供多种状态检查方法（IsZero、IsNew、IsDeleted 等）
- **时间计算**：提供时间相关的计算方法（GetAge、GetLastModified）
- **验证支持**：提供基础验证框架，子模型可扩展

**4. 接口设计**
- **TableNamer**：支持自定义表名
- **Validator**：支持自定义验证逻辑
- **Sanitizer**：支持数据清理和格式化

#### 1.2 创建用户模型

用户模型是系统的核心实体之一，负责管理用户的基本信息、认证数据、状态管理等。设计时需要考虑安全性、可扩展性和性能优化。

```go
// internal/models/user.go
package models

import (
	"errors"
	"fmt"
	"regexp"
	"strings"
	"time"

	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

// User 用户模型 - 系统用户的核心实体
// 包含用户的基本信息、认证数据、状态管理和行为统计
type User struct {
	// 继承基础模型的通用字段（ID、时间戳、软删除）
	BaseModel
	
	// Username 用户名，系统内唯一标识
	// gorm:"uniqueIndex" 创建唯一索引，确保用户名唯一性
	// gorm:"not null;size:50" 设置为非空，最大长度50字符
	// validate:"required,min=3,max=50" 验证规则：必填，3-50字符
	Username string `gorm:"uniqueIndex;not null;size:50" json:"username" validate:"required,min=3,max=50"`
	
	// Email 邮箱地址，用于登录和通知
	// gorm:"uniqueIndex" 创建唯一索引，确保邮箱唯一性
	// gorm:"not null;size:100" 设置为非空，最大长度100字符
	// validate:"required,email,max=100" 验证规则：必填，邮箱格式，最大100字符
	Email string `gorm:"uniqueIndex;not null;size:100" json:"email" validate:"required,email,max=100"`
	
	// Password 密码哈希值，存储加密后的密码
	// gorm:"not null;size:255" 设置为非空，最大长度255字符（bcrypt哈希长度）
	// json:"-" 在JSON序列化时忽略此字段，保护密码安全
	// validate:"required,min=6" 验证规则：必填，最少6字符（原始密码）
	Password string `gorm:"not null;size:255" json:"-" validate:"required,min=6"`
	
	// Nickname 用户昵称，用于显示
	// gorm:"size:100" 最大长度100字符
	// validate:"max=100" 验证规则：最大100字符
	Nickname string `gorm:"size:100" json:"nickname" validate:"max=100"`
	
	// Avatar 头像URL
	// gorm:"size:500" 最大长度500字符
	// validate:"url,max=500" 验证规则：URL格式，最大500字符
	Avatar string `gorm:"size:500" json:"avatar" validate:"url,max=500"`
	
	// Bio 用户简介
	// gorm:"type:text" 使用TEXT类型，支持长文本
	// validate:"max=500" 验证规则：最大500字符
	Bio string `gorm:"type:text" json:"bio" validate:"max=500"`
	
	// Status 用户状态，控制用户的访问权限
	// gorm:"not null;default:1" 设置为非空，默认值为1（活跃状态）
	Status UserStatus `gorm:"not null;default:1" json:"status"`
	
	// LastLoginAt 最后登录时间，用于统计和安全监控
	// gorm:"index" 创建索引，提高按登录时间查询的性能
	// 使用指针类型，允许为空（新用户未登录）
	LastLoginAt *time.Time `gorm:"index" json:"last_login_at"`
	
	// LoginCount 登录次数统计
	// gorm:"not null;default:0" 设置为非空，默认值为0
	LoginCount int64 `gorm:"not null;default:0" json:"login_count"`
	
	// IsVerified 邮箱验证状态
	// gorm:"not null;default:false" 设置为非空，默认值为false（未验证）
	IsVerified bool `gorm:"not null;default:false" json:"is_verified"`
	
	// VerifiedAt 邮箱验证时间
	// 使用指针类型，允许为空（未验证时为空）
	VerifiedAt *time.Time `json:"verified_at"`

	// 关联关系定义
	
	// Ratings 用户的评分记录，一对多关系
	// gorm:"foreignKey:UserID" 指定外键字段
	// gorm:"constraint:OnDelete:CASCADE" 级联删除，删除用户时同时删除其评分
	// json:"ratings,omitempty" JSON序列化时如果为空则忽略
	Ratings []Rating `gorm:"foreignKey:UserID;constraint:OnDelete:CASCADE" json:"ratings,omitempty"`
}

// UserStatus 用户状态枚举
// 定义用户在系统中的不同状态，用于权限控制和用户管理
type UserStatus int

// 用户状态常量定义
// 使用 iota 自动递增，确保状态值的唯一性和连续性
const (
	// UserStatusInactive 未激活状态（0）
	// 新注册用户的默认状态，需要邮箱验证后才能激活
	UserStatusInactive UserStatus = iota // 0: 未激活
	
	// UserStatusActive 活跃状态（1）
	// 正常用户状态，可以正常使用系统所有功能
	UserStatusActive                     // 1: 活跃
	
	// UserStatusSuspended 暂停状态（2）
	// 临时暂停用户，通常用于违规处理，可以恢复
	UserStatusSuspended                  // 2: 暂停
	
	// UserStatusBanned 封禁状态（3）
	// 永久封禁用户，严重违规时使用，无法恢复
	UserStatusBanned                     // 3: 封禁
)

// String 实现 Stringer 接口，返回状态的字符串表示
// 用于日志记录、调试和API响应中的状态显示
func (s UserStatus) String() string {
	switch s {
	case UserStatusInactive:
		return "inactive"
	case UserStatusActive:
		return "active"
	case UserStatusSuspended:
		return "suspended"
	case UserStatusBanned:
		return "banned"
	default:
		return "unknown"
	}
}

// IsValid 检查状态值是否有效
// 用于验证从外部输入或数据库读取的状态值
func (s UserStatus) IsValid() bool {
	return s >= UserStatusInactive && s <= UserStatusBanned
}

// CanAccess 检查该状态是否允许访问系统
// 只有活跃状态的用户才能正常访问系统功能
func (s UserStatus) CanAccess() bool {
	return s == UserStatusActive
}

// CanLogin 检查该状态是否允许登录
// 未激活和活跃状态的用户可以登录，暂停和封禁状态不能登录
func (s UserStatus) CanLogin() bool {
	return s == UserStatusInactive || s == UserStatusActive
}

// TableName 指定数据库表名
// GORM 会使用此方法返回的表名进行数据库操作
func (User) TableName() string {
	return "users"
}

// BeforeCreate GORM钩子：创建记录前的预处理
// 在插入数据库前自动执行，用于数据预处理和验证
func (u *User) BeforeCreate(tx *gorm.DB) error {
	// 调用基础模型的 BeforeCreate 钩子
	// 处理 ID 生成、创建时间设置等通用逻辑
	if err := u.BaseModel.BeforeCreate(tx); err != nil {
		return err
	}

	// 对密码进行哈希加密
	// 确保密码以加密形式存储到数据库
	if u.Password != "" {
		if err := u.HashPassword(); err != nil {
			return fmt.Errorf("failed to hash password: %w", err)
		}
	}

	// 设置默认昵称（如果未提供）
	// 使用用户名作为默认昵称，提升用户体验
	if u.Nickname == "" {
		u.Nickname = u.Username
	}

	// 数据验证
	if err := u.Validate(); err != nil {
		return fmt.Errorf("user validation failed: %w", err)
	}

	return nil
}

// BeforeUpdate GORM钩子：更新记录前的预处理
// 在更新数据库前自动执行，用于数据预处理和验证
func (u *User) BeforeUpdate(tx *gorm.DB) error {
	// 调用基础模型的 BeforeUpdate 钩子
	// 处理更新时间设置等通用逻辑
	if err := u.BaseModel.BeforeUpdate(tx); err != nil {
		return err
	}

	// 如果密码字段被修改，重新进行哈希加密
	// 避免在更新其他字段时重复加密已加密的密码
	if tx.Statement.Changed("password") && u.Password != "" {
		if err := u.HashPassword(); err != nil {
			return fmt.Errorf("failed to hash password: %w", err)
		}
	}

	// 数据验证
	if err := u.Validate(); err != nil {
		return fmt.Errorf("user validation failed: %w", err)
	}

	return nil
}

// HashPassword 使用 bcrypt 算法加密用户密码
// 将明文密码转换为安全的哈希值进行存储
func (u *User) HashPassword() error {
	// 检查密码是否为空
	if u.Password == "" {
		return errors.New("password cannot be empty")
	}

	// 检查密码是否已经是哈希值（避免重复加密）
	if len(u.Password) == 60 && strings.HasPrefix(u.Password, "$2") {
		return nil // 已经是 bcrypt 哈希值
	}

	// 使用 bcrypt 默认强度（10）进行哈希加密
	hashed, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
	if err != nil {
		return fmt.Errorf("failed to generate password hash: %w", err)
	}

	u.Password = string(hashed)
	return nil
}

// CheckPassword 验证用户输入的密码是否正确
// 将明文密码与存储的哈希值进行比较
func (u *User) CheckPassword(password string) bool {
	// 检查输入密码是否为空
	if password == "" {
		return false
	}

	// 使用 bcrypt 比较密码哈希值
	err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
	return err == nil
}

// IsActive 检查用户是否处于活跃状态
// 活跃状态的用户可以正常使用系统功能
func (u *User) IsActive() bool {
	return u.Status == UserStatusActive && !u.IsDeleted()
}

// CanLogin 检查用户是否可以登录系统
// 需要同时满足：状态允许登录 + 邮箱已验证 + 未被软删除
func (u *User) CanLogin() bool {
	return u.Status.CanLogin() && u.IsVerified && !u.IsDeleted()
}

// UpdateLoginInfo 更新用户登录信息
// 记录最后登录时间和登录次数，用于统计和安全监控
func (u *User) UpdateLoginInfo() {
	now := time.Now()
	u.LastLoginAt = &now
	u.LoginCount++
}

// Verify 验证用户邮箱
// 设置邮箱验证状态和验证时间，并激活未激活的用户
func (u *User) Verify() {
	now := time.Now()
	u.IsVerified = true
	u.VerifiedAt = &now
	
	// 如果用户状态是未激活，自动激活用户
	if u.Status == UserStatusInactive {
		u.Status = UserStatusActive
	}
}

// Suspend 暂停用户
// 将用户状态设置为暂停，用于临时限制用户访问
func (u *User) Suspend() {
	u.Status = UserStatusSuspended
}

// Ban 封禁用户
// 将用户状态设置为封禁，用于永久限制用户访问
func (u *User) Ban() {
	u.Status = UserStatusBanned
}

// Activate 激活用户
// 将用户状态设置为活跃，恢复用户的正常访问权限
func (u *User) Activate() {
	u.Status = UserStatusActive
}

// Sanitize 清理敏感信息，返回安全的用户数据副本
// 用于API响应，移除密码等敏感字段
func (u *User) Sanitize() *User {
	sanitized := *u
	sanitized.Password = "" // 清除密码字段
	return &sanitized
}

// Validate 验证用户数据的完整性和有效性
// 实现 Validator 接口，进行业务逻辑验证
func (u *User) Validate() error {
	// 验证用户名格式（字母、数字、下划线）
	usernameRegex := regexp.MustCompile(`^[a-zA-Z0-9_]+$`)
	if !usernameRegex.MatchString(u.Username) {
		return errors.New("username can only contain letters, numbers and underscores")
	}

	// 验证邮箱格式
	emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	if !emailRegex.MatchString(u.Email) {
		return errors.New("invalid email format")
	}

	// 验证用户状态
	if !u.Status.IsValid() {
		return errors.New("invalid user status")
	}

	return nil
}
```

#### 1.3 创建电影分类模型

电影分类模型用于管理电影的分类信息，支持多级分类、排序、状态管理等功能。设计时考虑了SEO友好的URL、视觉标识和灵活的分类管理。

```go
// internal/models/category.go
package models

import (
	"errors"
	"fmt"
	"regexp"
	"strings"
	"unicode"

	"gorm.io/gorm"
)

// Category 电影分类模型 - 管理电影的分类信息
// 支持分层分类、SEO优化、视觉标识和状态管理
type Category struct {
	// 继承基础模型的通用字段
	BaseModel
	
	// Name 分类名称，用于显示
	// gorm:"uniqueIndex" 创建唯一索引，确保分类名称唯一
	// gorm:"not null;size:50" 设置为非空，最大长度50字符
	// validate:"required,min=1,max=50" 验证规则：必填，1-50字符
	Name string `gorm:"uniqueIndex;not null;size:50" json:"name" validate:"required,min=1,max=50"`
	
	// Slug URL友好的标识符，用于SEO优化的URL
	// gorm:"uniqueIndex" 创建唯一索引，确保slug唯一
	// gorm:"not null;size:50" 设置为非空，最大长度50字符
	// validate:"required,min=1,max=50" 验证规则：必填，1-50字符
	Slug string `gorm:"uniqueIndex;not null;size:50" json:"slug" validate:"required,min=1,max=50"`
	
	// Description 分类描述，详细说明分类内容
	// gorm:"type:text" 使用TEXT类型，支持长文本
	// validate:"max=500" 验证规则：最大500字符
	Description string `gorm:"type:text" json:"description" validate:"max=500"`
	
	// Color 分类主题色，用于UI显示和视觉区分
	// gorm:"size:7;default:'#007bff'" 存储7位十六进制颜色值，默认蓝色
	// validate:"hexcolor" 验证规则：十六进制颜色格式
	Color string `gorm:"size:7;default:'#007bff'" json:"color" validate:"hexcolor"`
	
	// Icon 分类图标，用于UI显示
	// gorm:"size:50" 最大长度50字符（图标类名或Unicode）
	// validate:"max=50" 验证规则：最大50字符
	Icon string `gorm:"size:50" json:"icon" validate:"max=50"`
	
	// SortOrder 排序权重，数值越小排序越靠前
	// gorm:"not null;default:0;index" 设置为非空，默认值0，创建索引
	SortOrder int `gorm:"not null;default:0;index" json:"sort_order"`
	
	// IsActive 分类状态，控制分类是否可用
	// gorm:"not null;default:true;index" 设置为非空，默认启用，创建索引
	IsActive bool `gorm:"not null;default:true;index" json:"is_active"`

	// 关联关系定义
	
	// Movies 分类下的电影，多对多关系
	// gorm:"many2many:movie_categories" 指定中间表名
	// gorm:"constraint:OnDelete:CASCADE" 级联删除
	// json:"movies,omitempty" JSON序列化时如果为空则忽略
	Movies []Movie `gorm:"many2many:movie_categories;constraint:OnDelete:CASCADE" json:"movies,omitempty"`
}

// TableName 指定数据库表名
// GORM 会使用此方法返回的表名进行数据库操作
func (Category) TableName() string {
	return "categories"
}

// BeforeCreate GORM钩子：创建记录前的预处理
// 在插入数据库前自动执行，用于数据预处理和验证
func (c *Category) BeforeCreate(tx *gorm.DB) error {
	// 调用基础模型的 BeforeCreate 钩子
	// 处理 ID 生成、创建时间设置等通用逻辑
	if err := c.BaseModel.BeforeCreate(tx); err != nil {
		return err
	}

	// 自动生成 slug（如果为空）
	// 基于分类名称生成SEO友好的URL标识符
	if c.Slug == "" {
		c.Slug = c.generateSlug(c.Name)
	}

	// 数据验证
	if err := c.Validate(); err != nil {
		return fmt.Errorf("category validation failed: %w", err)
	}

	return nil
}

// BeforeUpdate GORM钩子：更新记录前的预处理
// 在更新数据库前自动执行，用于数据预处理和验证
func (c *Category) BeforeUpdate(tx *gorm.DB) error {
	// 调用基础模型的 BeforeUpdate 钩子
	// 处理更新时间设置等通用逻辑
	if err := c.BaseModel.BeforeUpdate(tx); err != nil {
		return err
	}

	// 如果分类名称被修改，自动更新对应的 slug
	// 保持 slug 与名称的一致性
	if tx.Statement.Changed("name") {
		c.Slug = c.generateSlug(c.Name)
	}

	// 数据验证
	if err := c.Validate(); err != nil {
		return fmt.Errorf("category validation failed: %w", err)
	}

	return nil
}

// generateSlug 生成SEO友好的URL标识符
// 将分类名称转换为适合URL的格式
func (c *Category) generateSlug(name string) string {
	// 转换为小写
	slug := strings.ToLower(name)
	
	// 移除特殊字符，只保留字母、数字和连字符
	reg := regexp.MustCompile(`[^a-z0-9\s-]`)
	slug = reg.ReplaceAllString(slug, "")
	
	// 将空格替换为连字符
	slug = regexp.MustCompile(`\s+`).ReplaceAllString(slug, "-")
	
	// 移除多余的连字符
	slug = regexp.MustCompile(`-+`).ReplaceAllString(slug, "-")
	
	// 移除首尾的连字符
	slug = strings.Trim(slug, "-")
	
	return slug
}

// IsEnabled 检查分类是否启用
// 启用状态的分类可以在前端显示和使用
func (c *Category) IsEnabled() bool {
	return c.IsActive && !c.IsDeleted()
}

// Enable 启用分类
// 将分类状态设置为启用，允许在系统中使用
func (c *Category) Enable() {
	c.IsActive = true
}

// Disable 禁用分类
// 将分类状态设置为禁用，隐藏但不删除分类
func (c *Category) Disable() {
	c.IsActive = false
}

// GetMovieCount 获取分类下的电影数量
// 用于统计和显示分类的内容丰富度
func (c *Category) GetMovieCount() int {
	return len(c.Movies)
}

// Validate 验证分类数据的完整性和有效性
// 实现 Validator 接口，进行业务逻辑验证
func (c *Category) Validate() error {
	// 验证分类名称
	if strings.TrimSpace(c.Name) == "" {
		return errors.New("category name cannot be empty")
	}

	// 验证分类名称长度和字符
	if len(c.Name) > 50 {
		return errors.New("category name too long (max 50 characters)")
	}

	// 验证 slug 格式（只允许小写字母、数字和连字符）
	slugRegex := regexp.MustCompile(`^[a-z0-9-]+$`)
	if c.Slug != "" && !slugRegex.MatchString(c.Slug) {
		return errors.New("slug can only contain lowercase letters, numbers and hyphens")
	}

	// 验证颜色格式（十六进制颜色值）
	if c.Color != "" {
		colorRegex := regexp.MustCompile(`^#[0-9A-Fa-f]{6}$`)
		if !colorRegex.MatchString(c.Color) {
			return errors.New("color must be a valid hex color code (e.g., #007bff)")
		}
	}

	// 验证排序权重范围
	if c.SortOrder < 0 {
		return errors.New("sort order cannot be negative")
	}

	return nil
}
```

#### 1.4 创建电影模型

电影模型是系统的核心实体，包含电影的详细信息、媒体资源、统计数据、元数据等。设计时考虑了数据完整性、性能优化、扩展性和第三方数据源集成。

```go
// internal/models/movie.go
package models

import (
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"regexp"
	"strings"
	"time"

	"gorm.io/gorm"
)

// Movie 电影模型 - 系统的核心实体
// 包含电影的基本信息、媒体资源、统计数据、元数据和关联关系
type Movie struct {
	// 继承基础模型的通用字段
	BaseModel
	
	// === 基本信息字段 ===
	
	// Title 电影标题，主要显示名称
	// gorm:"not null;size:200;index" 设置为非空，最大200字符，创建索引
	// validate:"required,min=1,max=200" 验证规则：必填，1-200字符
	Title string `gorm:"not null;size:200;index" json:"title" validate:"required,min=1,max=200"`
	
	// OriginalTitle 电影原始标题（原语言标题）
	// gorm:"size:200" 最大200字符
	// validate:"max=200" 验证规则：最大200字符
	OriginalTitle string `gorm:"size:200" json:"original_title" validate:"max=200"`
	
	// Slug URL友好的标识符，用于SEO优化的URL
	// gorm:"uniqueIndex;not null;size:250" 创建唯一索引，非空，最大250字符
	// validate:"required,min=1,max=250" 验证规则：必填，1-250字符
	Slug string `gorm:"uniqueIndex;not null;size:250" json:"slug" validate:"required,min=1,max=250"`
	
	// Description 电影详细描述
	// gorm:"type:text" 使用TEXT类型，支持长文本
	// validate:"max=2000" 验证规则：最大2000字符
	Description string `gorm:"type:text" json:"description" validate:"max=2000"`
	
	// Summary 电影简介，用于列表显示
	// gorm:"type:text" 使用TEXT类型
	// validate:"max=500" 验证规则：最大500字符
	Summary string `gorm:"type:text" json:"summary" validate:"max=500"`
	
	// === 媒体资源字段 ===
	
	// Poster 电影海报图片URL
	// gorm:"size:500" 最大500字符
	// validate:"url,max=500" 验证规则：URL格式，最大500字符
	Poster string `gorm:"size:500" json:"poster" validate:"url,max=500"`
	
	// Backdrop 电影背景图片URL
	// gorm:"size:500" 最大500字符
	// validate:"url,max=500" 验证规则：URL格式，最大500字符
	Backdrop string `gorm:"size:500" json:"backdrop" validate:"url,max=500"`
	
	// Trailer 电影预告片URL
	// gorm:"size:500" 最大500字符
	// validate:"url,max=500" 验证规则：URL格式，最大500字符
	Trailer string `gorm:"size:500" json:"trailer" validate:"url,max=500"`
	
	// === 外部数据源标识 ===
	
	// IMDbID IMDb数据库标识符
	// gorm:"uniqueIndex;size:20" 创建唯一索引，最大20字符
	// validate:"max=20" 验证规则：最大20字符
	IMDbID string `gorm:"uniqueIndex;size:20" json:"imdb_id" validate:"max=20"`
	
	// TMDbID The Movie Database标识符
	// gorm:"uniqueIndex" 创建唯一索引
	TMDbID int64 `gorm:"uniqueIndex" json:"tmdb_id"`
	
	// === 电影属性字段 ===
	
	// ReleaseDate 电影上映日期
	// gorm:"index" 创建索引，用于按日期查询
	// 使用指针类型，允许为空（未知上映日期）
	ReleaseDate *time.Time `gorm:"index" json:"release_date"`
	
	// Runtime 电影时长（分钟）
	// gorm:"default:0" 默认值为0
	// validate:"min=0,max=1000" 验证规则：0-1000分钟
	Runtime int `gorm:"default:0" json:"runtime" validate:"min=0,max=1000"`
	
	// Budget 电影预算（美元）
	// gorm:"default:0" 默认值为0
	// validate:"min=0" 验证规则：非负数
	Budget int64 `gorm:"default:0" json:"budget" validate:"min=0"`
	
	// Revenue 电影票房收入（美元）
	// gorm:"default:0" 默认值为0
	// validate:"min=0" 验证规则：非负数
	Revenue int64 `gorm:"default:0" json:"revenue" validate:"min=0"`
	
	// Language 电影主要语言（ISO 639-1代码）
	// gorm:"size:10;default:'en'" 最大10字符，默认英语
	// validate:"max=10" 验证规则：最大10字符
	Language string `gorm:"size:10;default:'en'" json:"language" validate:"max=10"`
	
	// Country 电影制作国家
	// gorm:"size:100" 最大100字符
	// validate:"max=100" 验证规则：最大100字符
	Country string `gorm:"size:100" json:"country" validate:"max=100"`
	
	// === 状态和统计字段 ===
	
	// Status 电影状态（草稿、已发布、已归档、已删除）
	// gorm:"not null;default:1;index" 非空，默认已发布，创建索引
	Status MovieStatus `gorm:"not null;default:1;index" json:"status"`
	
	// Rating 电影平均评分（0.0-5.0）
	// gorm:"type:decimal(3,1);default:0.0;index" 使用DECIMAL类型，默认0.0，创建索引
	// validate:"min=0,max=5" 验证规则：0-5分
	Rating float64 `gorm:"type:decimal(3,1);default:0.0;index" json:"rating" validate:"min=0,max=5"`
	
	// RatingCount 评分总数
	// gorm:"not null;default:0" 非空，默认值为0
	RatingCount int64 `gorm:"not null;default:0" json:"rating_count"`
	
	// Popularity 电影热度值
	// gorm:"type:decimal(8,2);default:0.0;index" 使用DECIMAL类型，默认0.0，创建索引
	Popularity float64 `gorm:"type:decimal(8,2);default:0.0;index" json:"popularity"`
	
	// ViewCount 观看次数统计
	// gorm:"not null;default:0;index" 非空，默认值为0，创建索引
	ViewCount int64 `gorm:"not null;default:0;index" json:"view_count"`
	
	// === JSON存储的数组字段 ===
	
	// Genres 电影类型列表（动作、喜剧、剧情等）
	// gorm:"type:json" 使用JSON类型存储
	Genres StringArray `gorm:"type:json" json:"genres"`
	
	// Directors 导演列表
	// gorm:"type:json" 使用JSON类型存储
	Directors StringArray `gorm:"type:json" json:"directors"`
	
	// Actors 主要演员列表
	// gorm:"type:json" 使用JSON类型存储
	Actors StringArray `gorm:"type:json" json:"actors"`
	
	// Writers 编剧列表
	// gorm:"type:json" 使用JSON类型存储
	Writers StringArray `gorm:"type:json" json:"writers"`
	
	// Producers 制片人列表
	// gorm:"type:json" 使用JSON类型存储
	Producers StringArray `gorm:"type:json" json:"producers"`
	
	// Studios 制片公司列表
	// gorm:"type:json" 使用JSON类型存储
	Studios StringArray `gorm:"type:json" json:"studios"`
	
	// Keywords 关键词列表，用于搜索和推荐
	// gorm:"type:json" 使用JSON类型存储
	Keywords StringArray `gorm:"type:json" json:"keywords"`
	
	// === 元数据和发布状态 ===
	
	// Metadata 电影扩展元数据
	// gorm:"type:json" 使用JSON类型存储复杂结构
	Metadata MovieMetadata `gorm:"type:json" json:"metadata"`
	
	// IsPublished 是否已发布到前端
	// gorm:"not null;default:false;index" 非空，默认未发布，创建索引
	IsPublished bool `gorm:"not null;default:false;index" json:"is_published"`
	
	// PublishedAt 发布时间
	// 使用指针类型，允许为空（未发布时为空）
	PublishedAt *time.Time `json:"published_at"`

	// === 关联关系定义 ===
	
	// Categories 电影分类，多对多关系
	// gorm:"many2many:movie_categories" 指定中间表名
	// gorm:"constraint:OnDelete:CASCADE" 级联删除
	// json:"categories,omitempty" JSON序列化时如果为空则忽略
	Categories []Category `gorm:"many2many:movie_categories;constraint:OnDelete:CASCADE" json:"categories,omitempty"`
	
	// Ratings 电影评分记录，一对多关系
	// gorm:"foreignKey:MovieID" 指定外键字段
	// gorm:"constraint:OnDelete:CASCADE" 级联删除
	// json:"ratings,omitempty" JSON序列化时如果为空则忽略
	Ratings []Rating `gorm:"foreignKey:MovieID;constraint:OnDelete:CASCADE" json:"ratings,omitempty"`
}

// MovieStatus 电影状态枚举
// 定义电影在系统中的生命周期状态，用于控制电影的可见性和操作权限
type MovieStatus int

// 电影状态常量定义
// 使用 iota 自动递增，确保状态值的唯一性和顺序性
const (
	// MovieStatusDraft 草稿状态 (0)
	// 电影信息正在编辑中，未对外展示，仅管理员可见
	MovieStatusDraft MovieStatus = iota
	
	// MovieStatusPublished 已发布状态 (1)
	// 电影信息完整，对外展示，用户可以浏览和评分
	MovieStatusPublished
	
	// MovieStatusArchived 已归档状态 (2)
	// 电影不再活跃展示，但保留数据，可用于历史查询
	MovieStatusArchived
	
	// MovieStatusDeleted 已删除状态 (3)
	// 电影被标记删除，不对外展示，但数据仍保留（软删除）
	MovieStatusDeleted
)

// String 返回电影状态的字符串表示
// 实现 fmt.Stringer 接口，用于日志记录、调试和API响应
func (s MovieStatus) String() string {
	switch s {
	case MovieStatusDraft:
		return "draft"
	case MovieStatusPublished:
		return "published"
	case MovieStatusArchived:
		return "archived"
	case MovieStatusDeleted:
		return "deleted"
	default:
		return "unknown"
	}
}

// IsValid 检查电影状态是否有效
// 用于数据验证，确保状态值在合法范围内
// 返回 true 表示状态有效，false 表示状态无效
func (s MovieStatus) IsValid() bool {
	return s >= MovieStatusDraft && s <= MovieStatusDeleted
}

// CanDisplay 检查电影是否可以对外展示
// 只有已发布状态的电影才能对外展示
// 用于前端列表和详情页面的权限控制
func (s MovieStatus) CanDisplay() bool {
	return s == MovieStatusPublished
}

// CanEdit 检查电影是否可以编辑
// 草稿和已发布状态的电影可以编辑
// 已归档和已删除的电影不允许编辑
func (s MovieStatus) CanEdit() bool {
	return s == MovieStatusDraft || s == MovieStatusPublished
}

// IsActive 检查电影是否处于活跃状态
// 草稿和已发布状态被认为是活跃的
// 用于统计活跃电影数量
func (s MovieStatus) IsActive() bool {
	return s == MovieStatusDraft || s == MovieStatusPublished
}

// GetDisplayName 获取状态的中文显示名称
// 用于管理后台的状态显示
func (s MovieStatus) GetDisplayName() string {
	switch s {
	case MovieStatusDraft:
		return "草稿"
	case MovieStatusPublished:
		return "已发布"
	case MovieStatusArchived:
		return "已归档"
	case MovieStatusDeleted:
		return "已删除"
	default:
		return "未知状态"
	}
}

// StringArray 字符串数组类型，用于在数据库中以JSON格式存储字符串数组
// 主要用于存储电影的类型、导演、演员等列表信息
// 实现了 sql.Scanner 和 driver.Valuer 接口，支持数据库的读写操作
type StringArray []string

// Scan 实现 sql.Scanner 接口，用于从数据库读取JSON数据并转换为字符串数组
// 支持从 []byte 和 string 类型的JSON数据进行反序列化
// 如果数据库值为 NULL，则将数组设置为 nil
func (sa *StringArray) Scan(value interface{}) error {
	// 处理 NULL 值
	if value == nil {
		*sa = nil
		return nil
	}

	// 根据不同的数据类型进行处理
	switch v := value.(type) {
	case []byte:
		// 从字节数组反序列化
		return json.Unmarshal(v, sa)
	case string:
		// 从字符串反序列化
		return json.Unmarshal([]byte(v), sa)
	default:
		// 不支持的数据类型
		return fmt.Errorf("cannot scan %T into StringArray", value)
	}
}

// Value 实现 driver.Valuer 接口，用于将字符串数组转换为JSON格式存储到数据库
// 如果数组为 nil，则返回 NULL 值
// 否则将数组序列化为JSON字符串
func (sa StringArray) Value() (driver.Value, error) {
	// 处理 nil 数组
	if sa == nil {
		return nil, nil
	}
	// 序列化为JSON
	return json.Marshal(sa)
}

// Contains 检查数组是否包含指定的字符串
// 用于快速查找数组中是否存在某个元素
func (sa StringArray) Contains(item string) bool {
	for _, s := range sa {
		if s == item {
			return true
		}
	}
	return false
}

// Add 向数组中添加字符串（如果不存在）
// 避免重复添加相同的元素
func (sa *StringArray) Add(item string) {
	if !sa.Contains(item) {
		*sa = append(*sa, item)
	}
}

// Remove 从数组中移除指定的字符串
// 移除第一个匹配的元素
func (sa *StringArray) Remove(item string) {
	for i, s := range *sa {
		if s == item {
			*sa = append((*sa)[:i], (*sa)[i+1:]...)
			return
		}
	}
}

// MovieMetadata 电影扩展元数据结构体
// 用于存储电影的详细信息和扩展属性，以JSON格式存储在数据库中
// 包含年龄分级、获奖信息、宣传语、官网链接等丰富的电影信息
type MovieMetadata struct {
	// AgeRating 年龄分级（如：G, PG, PG-13, R, NC-17）
	// 用于标识电影适合的观众年龄群体
	AgeRating string `json:"age_rating,omitempty"`
	
	// Awards 获奖记录列表
	// 存储电影获得的各种奖项和提名信息
	Awards []string `json:"awards,omitempty"`
	
	// Certification 电影认证信息
	// 各国家/地区的电影分级认证
	Certification string `json:"certification,omitempty"`
	
	// Tagline 电影宣传语/标语
	// 用于营销推广的简短宣传文案
	Tagline string `json:"tagline,omitempty"`
	
	// Homepage 电影官方网站链接
	// 电影的官方主页或宣传网站
	Homepage string `json:"homepage,omitempty"`
	
	// Soundtrack 电影原声音乐列表
	// 记录电影中使用的音乐和歌曲
	Soundtrack []string `json:"soundtrack,omitempty"`
	
	// Trivia 电影花絮/趣闻列表
	// 电影拍摄过程中的有趣事实和幕后故事
	Trivia []string `json:"trivia,omitempty"`
	
	// Goofs 电影穿帮/错误列表
	// 电影中的技术错误、连续性错误等
	Goofs []string `json:"goofs,omitempty"`
	
	// Quotes 经典台词列表
	// 电影中的经典对白和名言
	Quotes []string `json:"quotes,omitempty"`
	
	// AlternateVersions 其他版本信息列表
	// 导演剪辑版、加长版、删减版等不同版本的说明
	AlternateVersions []string `json:"alternate_versions,omitempty"`
	
	// Connections 关联电影映射
	// 存储与其他电影的关系（续集、前传、重制版等）
	// key: 关系类型（如 "sequel", "prequel", "remake"）
	// value: 关联电影的标识或名称
	Connections map[string]string `json:"connections,omitempty"`
	
	// ExternalIDs 外部数据源ID映射
	// 存储在各个外部平台的标识符
	// key: 平台名称（如 "imdb", "tmdb", "douban"）
	// value: 对应平台的ID
	ExternalIDs map[string]string `json:"external_ids,omitempty"`
}

// Scan 实现 sql.Scanner 接口，用于从数据库读取JSON数据并转换为MovieMetadata结构体
// 支持从 []byte 和 string 类型的JSON数据进行反序列化
// 如果数据库值为 NULL，则初始化为空的MovieMetadata结构体
func (mm *MovieMetadata) Scan(value interface{}) error {
	// 处理 NULL 值，初始化为空结构体
	if value == nil {
		*mm = MovieMetadata{}
		return nil
	}

	// 根据不同的数据类型进行处理
	switch v := value.(type) {
	case []byte:
		// 从字节数组反序列化
		return json.Unmarshal(v, mm)
	case string:
		// 从字符串反序列化
		return json.Unmarshal([]byte(v), mm)
	default:
		// 不支持的数据类型
		return fmt.Errorf("cannot scan %T into MovieMetadata", value)
	}
}

// Value 实现 driver.Valuer 接口，用于将MovieMetadata结构体转换为JSON格式存储到数据库
// 将结构体序列化为JSON字符串进行存储
func (mm MovieMetadata) Value() (driver.Value, error) {
	// 序列化为JSON
	return json.Marshal(mm)
}

// IsEmpty 检查元数据是否为空
// 用于判断是否有扩展元数据信息
func (mm MovieMetadata) IsEmpty() bool {
	return mm.AgeRating == "" &&
		len(mm.Awards) == 0 &&
		mm.Certification == "" &&
		mm.Tagline == "" &&
		mm.Homepage == "" &&
		len(mm.Soundtrack) == 0 &&
		len(mm.Trivia) == 0 &&
		len(mm.Goofs) == 0 &&
		len(mm.Quotes) == 0 &&
		len(mm.AlternateVersions) == 0 &&
		len(mm.Connections) == 0 &&
		len(mm.ExternalIDs) == 0
}

// GetExternalID 获取指定平台的外部ID
// 安全地获取外部ID，避免map的nil指针异常
func (mm MovieMetadata) GetExternalID(platform string) string {
	if mm.ExternalIDs == nil {
		return ""
	}
	return mm.ExternalIDs[platform]
}

// SetExternalID 设置指定平台的外部ID
// 如果ExternalIDs为nil，则初始化map
func (mm *MovieMetadata) SetExternalID(platform, id string) {
	if mm.ExternalIDs == nil {
		mm.ExternalIDs = make(map[string]string)
	}
	mm.ExternalIDs[platform] = id
}

// TableName 自定义数据库表名
// 实现 GORM 的 Tabler 接口，指定电影模型对应的数据库表名
// 返回 "movies" 作为表名，遵循复数命名约定
func (Movie) TableName() string {
	return "movies"
}

// BeforeCreate GORM钩子函数：在创建电影记录前执行
// 用于在数据插入数据库前进行数据预处理和验证
// 主要功能：调用基础模型钩子、生成URL友好的slug
func (m *Movie) BeforeCreate(tx *gorm.DB) error {
	// 调用基础模型的钩子函数，处理通用的创建前逻辑
	// 如设置创建时间、更新时间、ID生成等
	if err := m.BaseModel.BeforeCreate(tx); err != nil {
		return err
	}

	// 自动生成slug（如果为空）
	// slug用于SEO友好的URL，基于电影标题生成
	if m.Slug == "" {
		m.Slug = generateSlug(m.Title)
	}

	// 数据验证
	if err := m.Validate(); err != nil {
		return err
	}

	return nil
}

// BeforeUpdate GORM钩子函数：在更新电影记录前执行
// 用于在数据更新到数据库前进行数据预处理和验证
// 主要功能：调用基础模型钩子、智能更新slug
func (m *Movie) BeforeUpdate(tx *gorm.DB) error {
	// 调用基础模型的钩子函数，处理通用的更新前逻辑
	// 如更新修改时间等
	if err := m.BaseModel.BeforeUpdate(tx); err != nil {
		return err
	}

	// 智能更新slug：只有当标题被修改时才重新生成slug
	// 避免不必要的slug更新，保持URL的稳定性
	if tx.Statement.Changed("title") {
		m.Slug = generateSlug(m.Title)
	}

	// 数据验证
	if err := m.Validate(); err != nil {
		return err
	}

	return nil
}

// IsPublished 检查电影是否已发布并可对外展示
// 同时检查状态和发布标志，确保电影真正可见
// 返回 true 表示电影已发布且可对外展示
func (m *Movie) IsPublished() bool {
	return m.Status == MovieStatusPublished && m.IsPublished
}

// Publish 发布电影到前端
// 设置电影状态为已发布，标记为可见，并记录发布时间
// 用于将草稿状态的电影正式发布给用户浏览
func (m *Movie) Publish() {
	now := time.Now()
	m.Status = MovieStatusPublished
	m.IsPublished = true
	m.PublishedAt = &now
}

// Unpublish 取消发布电影
// 将电影状态改为草稿，取消对外展示，清除发布时间
// 用于临时下架电影或回退到编辑状态
func (m *Movie) Unpublish() {
	m.Status = MovieStatusDraft
	m.IsPublished = false
	m.PublishedAt = nil
}

// Archive 归档电影
// 将电影状态改为已归档，取消对外展示
// 用于将不再活跃的电影进行归档处理，但保留数据
func (m *Movie) Archive() {
	m.Status = MovieStatusArchived
	m.IsPublished = false
}

// Delete 软删除电影
// 将电影状态改为已删除，取消对外展示
// 实现软删除，数据仍保留在数据库中
func (m *Movie) Delete() {
	m.Status = MovieStatusDeleted
	m.IsPublished = false
}

// IncrementViewCount 增加电影观看次数
// 用于统计电影的浏览量，支持热度计算和推荐算法
// 注意：此方法只更新内存中的值，需要调用Save()持久化到数据库
func (m *Movie) IncrementViewCount() {
	m.ViewCount++
}

// UpdateRating 更新电影评分统计
// 当有新的评分或评分被删除时，更新电影的平均评分和评分总数
// newRating: 新的平均评分 (0.0-5.0)
// newCount: 新的评分总数
func (m *Movie) UpdateRating(newRating float64, newCount int64) {
	m.Rating = newRating
	m.RatingCount = newCount
}

// GetYear 获取电影上映年份
// 从上映日期中提取年份，用于按年份分组和筛选
// 如果上映日期为空，返回 0 表示未知年份
func (m *Movie) GetYear() int {
	if m.ReleaseDate != nil {
		return m.ReleaseDate.Year()
	}
	return 0
}

// GetDurationString 获取格式化的电影时长字符串
// 将分钟数转换为易读的时长格式（如："2小时30分钟" 或 "90分钟"）
// 用于前端显示和用户界面
func (m *Movie) GetDurationString() string {
	if m.Runtime <= 0 {
		return "未知"
	}
	hours := m.Runtime / 60
	minutes := m.Runtime % 60
	if hours > 0 {
		return fmt.Sprintf("%d小时%d分钟", hours, minutes)
	}
	return fmt.Sprintf("%d分钟", minutes)
}

// HasGenre 检查电影是否包含指定类型
// 用于类型筛选和分类查询
// genre: 要检查的电影类型（如："动作", "喜剧", "剧情"）
func (m *Movie) HasGenre(genre string) bool {
	for _, g := range m.Genres {
		if g == genre {
			return true
		}
	}
	return false
}

// AddGenre 向电影添加新的类型
// 避免重复添加相同的类型，保持类型列表的唯一性
// genre: 要添加的电影类型
func (m *Movie) AddGenre(genre string) {
	if !m.HasGenre(genre) {
		m.Genres = append(m.Genres, genre)
	}
}

// RemoveGenre 从电影中移除指定类型
// 移除第一个匹配的类型，用于类型管理
// genre: 要移除的电影类型
func (m *Movie) RemoveGenre(genre string) {
	for i, g := range m.Genres {
		if g == genre {
			m.Genres = append(m.Genres[:i], m.Genres[i+1:]...)
			break
		}
	}
}

// GetGenresString 获取类型的字符串表示
// 将类型数组转换为逗号分隔的字符串，用于显示
func (m *Movie) GetGenresString() string {
	if len(m.Genres) == 0 {
		return "未分类"
	}
	return strings.Join(m.Genres, ", ")
}

// Validate 验证电影数据的完整性和有效性
// 检查必填字段、数据格式、业务规则等
// 返回验证错误信息，用于数据入库前的校验
func (m *Movie) Validate() error {
	// 验证标题
	if strings.TrimSpace(m.Title) == "" {
		return errors.New("电影标题不能为空")
	}
	
	// 验证slug
	if strings.TrimSpace(m.Slug) == "" {
		return errors.New("电影slug不能为空")
	}
	
	// 验证slug格式（只允许字母、数字、连字符）
	slugPattern := regexp.MustCompile(`^[a-z0-9-]+$`)
	if !slugPattern.MatchString(m.Slug) {
		return errors.New("slug格式无效，只允许小写字母、数字和连字符")
	}
	
	// 验证评分范围
	if m.Rating < 0 || m.Rating > 5 {
		return errors.New("评分必须在0-5之间")
	}
	
	// 验证时长
	if m.Runtime < 0 {
		return errors.New("电影时长不能为负数")
	}
	
	// 验证状态
	if !m.Status.IsValid() {
		return errors.New("电影状态无效")
	}
	
	return nil
}
```

#### 1.5 创建评分模型

评分模型用于存储用户对电影的评分和评论信息，支持评分审核、可见性控制和社交互动功能。

```go
// internal/models/rating.go
package models

import (
	"errors"
	"fmt"
	"strings"
	"time"

	"gorm.io/gorm"
)

// Rating 用户电影评分模型
// 存储用户对电影的评分、评论和相关的社交数据
// 支持评分审核机制和可见性控制
type Rating struct {
	// 继承基础模型的通用字段
	BaseModel
	
	// === 关联字段 ===
	
	// UserID 评分用户ID
	// gorm:"not null;index:idx_user_movie,unique" 非空，创建复合唯一索引
	// 与MovieID组成复合唯一索引，确保一个用户只能对一部电影评分一次
	UserID uint64 `gorm:"not null;index:idx_user_movie,unique" json:"user_id"`
	
	// MovieID 被评分电影ID
	// gorm:"not null;index:idx_user_movie,unique;index" 非空，复合唯一索引+单独索引
	// 复合唯一索引确保用户评分唯一性，单独索引支持按电影查询评分
	MovieID uint64 `gorm:"not null;index:idx_user_movie,unique;index" json:"movie_id"`
	
	// === 评分内容字段 ===
	
	// Score 评分分数（1-5分）
	// gorm:"not null;check:score >= 1 AND score <= 5" 非空，数据库层面约束评分范围
	// validate:"required,min=1,max=5" 应用层验证规则
	Score int32 `gorm:"not null;check:score >= 1 AND score <= 5" json:"score" validate:"required,min=1,max=5"`
	
	// Comment 评分评论内容
	// gorm:"type:text" 使用TEXT类型，支持长文本评论
	// validate:"max=1000" 限制评论最大长度为1000字符
	Comment string `gorm:"type:text" json:"comment" validate:"max=1000"`
	
	// === 可见性和状态字段 ===
	
	// IsPublic 是否公开显示
	// gorm:"not null;default:true;index" 非空，默认公开，创建索引
	// 控制评分是否在公开列表中显示
	IsPublic bool `gorm:"not null;default:true;index" json:"is_public"`
	
	// LikeCount 点赞数量
	// gorm:"not null;default:0" 非空，默认值为0
	// 记录其他用户对该评分的点赞数
	LikeCount int64 `gorm:"not null;default:0" json:"like_count"`
	
	// Status 评分审核状态
	// gorm:"not null;default:1;index" 非空，默认已通过，创建索引
	// 支持评分内容的审核机制
	Status RatingStatus `gorm:"not null;default:1;index" json:"status"`

	// === 关联关系定义 ===
	
	// User 评分用户，一对一关系
	// gorm:"foreignKey:UserID" 指定外键字段
	// gorm:"constraint:OnDelete:CASCADE" 级联删除
	// json:"user,omitempty" JSON序列化时如果为空则忽略
	User User `gorm:"foreignKey:UserID;constraint:OnDelete:CASCADE" json:"user,omitempty"`
	
	// Movie 被评分电影，一对一关系
	// gorm:"foreignKey:MovieID" 指定外键字段
	// gorm:"constraint:OnDelete:CASCADE" 级联删除
	// json:"movie,omitempty" JSON序列化时如果为空则忽略
	Movie Movie `gorm:"foreignKey:MovieID;constraint:OnDelete:CASCADE" json:"movie,omitempty"`
}

// RatingStatus 评分审核状态枚举
// 定义评分在系统中的审核和显示状态
// 支持内容审核机制和可见性控制
type RatingStatus int

const (
	// RatingStatusPending 待审核状态
	// 新提交的评分默认状态，需要管理员审核
	RatingStatusPending RatingStatus = iota // 0: 待审核
	
	// RatingStatusApproved 已通过审核
	// 评分内容符合规范，可以公开显示
	RatingStatusApproved // 1: 已通过
	
	// RatingStatusRejected 审核被拒绝
	// 评分内容不符合规范，不允许公开显示
	RatingStatusRejected // 2: 已拒绝
	
	// RatingStatusHidden 已隐藏
	// 管理员手动隐藏的评分，不在公开列表中显示
	RatingStatusHidden // 3: 已隐藏
)

// String 实现 Stringer 接口
// 返回评分状态的字符串表示，用于日志记录、API响应和调试输出
func (s RatingStatus) String() string {
	switch s {
	case RatingStatusPending:
		return "pending"
	case RatingStatusApproved:
		return "approved"
	case RatingStatusRejected:
		return "rejected"
	case RatingStatusHidden:
		return "hidden"
	default:
		return "unknown"
	}
}

// IsValid 验证评分状态是否为有效值
// 确保状态值在定义的枚举范围内
func (s RatingStatus) IsValid() bool {
	return s >= RatingStatusPending && s <= RatingStatusHidden
}

// CanDisplay 检查评分是否可以公开显示
// 只有已通过审核的评分才能在前端显示
func (s RatingStatus) CanDisplay() bool {
	return s == RatingStatusApproved
}

// NeedsReview 检查评分是否需要审核
// 待审核状态的评分需要管理员处理
func (s RatingStatus) NeedsReview() bool {
	return s == RatingStatusPending
}

// IsRejected 检查评分是否被拒绝
// 被拒绝的评分不能显示，可能需要用户修改
func (s RatingStatus) IsRejected() bool {
	return s == RatingStatusRejected
}

// GetDisplayName 获取状态的中文显示名称
// 用于管理后台和用户界面的状态显示
func (s RatingStatus) GetDisplayName() string {
	switch s {
	case RatingStatusPending:
		return "待审核"
	case RatingStatusApproved:
		return "已通过"
	case RatingStatusRejected:
		return "已拒绝"
	case RatingStatusHidden:
		return "已隐藏"
	default:
		return "未知状态"
	}
}

// TableName 自定义表名
// 指定评分模型在数据库中的表名为 user_ratings
// 遵循复数命名约定，明确表示用户评分数据
func (Rating) TableName() string {
	return "user_ratings"
}

// BeforeCreate GORM钩子：创建前数据验证和处理
// 在评分记录插入数据库前执行，确保数据完整性和业务规则
func (r *Rating) BeforeCreate(tx *gorm.DB) error {
	// 调用基础模型的钩子，处理通用字段（如创建时间、更新时间等）
	if err := r.BaseModel.BeforeCreate(tx); err != nil {
		return err
	}

	// 验证评分范围，确保评分在1-5分之间
	// 这是业务层面的重要约束，防止无效评分数据
	if r.Score < 1 || r.Score > 5 {
		return fmt.Errorf("score must be between 1 and 5")
	}

	// 调用完整的数据验证
	if err := r.Validate(); err != nil {
		return err
	}

	return nil
}

// BeforeUpdate GORM钩子：更新前数据验证和处理
// 在评分记录更新前执行，确保修改后的数据仍然符合业务规则
func (r *Rating) BeforeUpdate(tx *gorm.DB) error {
	// 调用基础模型的钩子，更新通用字段（如更新时间等）
	if err := r.BaseModel.BeforeUpdate(tx); err != nil {
		return err
	}

	// 只在评分字段发生变化时验证评分范围
	// 避免不必要的验证，提高更新性能
	if tx.Statement.Changed("score") {
		if r.Score < 1 || r.Score > 5 {
			return fmt.Errorf("score must be between 1 and 5")
		}
	}

	// 调用完整的数据验证
	if err := r.Validate(); err != nil {
		return err
	}

	return nil
}

// === 状态检查方法 ===

// IsApproved 检查评分是否已通过审核
// 返回评分是否处于已通过状态，用于判断是否可以公开显示
func (r *Rating) IsApproved() bool {
	return r.Status == RatingStatusApproved
}

// IsVisible 检查评分是否在前端可见
// 评分必须同时满足：已通过审核 且 设置为公开
// 这是前端显示评分的核心判断逻辑
func (r *Rating) IsVisible() bool {
	return r.Status == RatingStatusApproved && r.IsPublic
}

// IsPending 检查评分是否待审核
// 用于管理后台识别需要处理的评分
func (r *Rating) IsPending() bool {
	return r.Status == RatingStatusPending
}

// === 状态管理方法 ===

// Approve 通过评分审核
// 管理员审核通过评分，允许其在前端显示
func (r *Rating) Approve() {
	r.Status = RatingStatusApproved
}

// Reject 拒绝评分审核
// 管理员拒绝评分，通常因为内容不当或违规
func (r *Rating) Reject() {
	r.Status = RatingStatusRejected
}

// Hide 隐藏评分
// 管理员手动隐藏评分，不在公开列表中显示
func (r *Rating) Hide() {
	r.Status = RatingStatusHidden
}

// === 可见性管理方法 ===

// Show 设置评分为公开显示
// 用户或管理员将评分设置为公开状态
func (r *Rating) Show() {
	r.IsPublic = true
}

// HideFromPublic 从公开列表中隐藏评分
// 用户可以选择不公开显示自己的评分
func (r *Rating) HideFromPublic() {
	r.IsPublic = false
}

// === 社交互动方法 ===

// IncrementLikeCount 增加点赞数
// 当其他用户点赞该评分时调用，用于社交功能统计
func (r *Rating) IncrementLikeCount() {
	r.LikeCount++
}

// DecrementLikeCount 减少点赞数
// 当用户取消点赞时调用，确保点赞数不会变为负数
func (r *Rating) DecrementLikeCount() {
	if r.LikeCount > 0 {
		r.LikeCount--
	}
}

// ResetLikeCount 重置点赞数
// 管理员可能需要重置异常的点赞数据
func (r *Rating) ResetLikeCount() {
	r.LikeCount = 0
}

// === 评分展示方法 ===

// GetScoreStars 获取星级评分（5星制）
// 返回1-5的星级评分，用于前端星级显示组件
func (r *Rating) GetScoreStars() int32 {
	return r.Score
}

// GetScorePercentage 获取评分百分比
// 将1-5分转换为0-100%，用于进度条或百分比显示
func (r *Rating) GetScorePercentage() float64 {
	return float64(r.Score) * 20.0
}

// GetScoreText 获取评分文字描述
// 将数字评分转换为文字描述，提升用户体验
func (r *Rating) GetScoreText() string {
	switch r.Score {
	case 1:
		return "很差"
	case 2:
		return "较差"
	case 3:
		return "一般"
	case 4:
		return "不错"
	case 5:
		return "很棒"
	default:
		return "未知"
	}
}

// === 内容检查方法 ===

// HasComment 检查是否有评论内容
// 判断用户是否提供了文字评论，用于区分纯评分和带评论的评分
func (r *Rating) HasComment() bool {
	return strings.TrimSpace(r.Comment) != ""
}

// GetCommentPreview 获取评论预览
// 返回评论的前50个字符，用于列表页面的评论预览
func (r *Rating) GetCommentPreview() string {
	comment := strings.TrimSpace(r.Comment)
	if len(comment) <= 50 {
		return comment
	}
	return comment[:50] + "..."
}

// === 数据验证方法 ===

// Validate 验证评分数据的完整性和有效性
// 确保评分数据符合业务规则和约束条件
func (r *Rating) Validate() error {
	// 验证评分范围
	if r.Score < 1 || r.Score > 5 {
		return errors.New("评分必须在1-5分之间")
	}

	// 验证用户ID
	if r.UserID == 0 {
		return errors.New("用户ID不能为空")
	}

	// 验证电影ID
	if r.MovieID == 0 {
		return errors.New("电影ID不能为空")
	}

	// 验证评论长度
	if len(r.Comment) > 1000 {
		return errors.New("评论内容不能超过1000个字符")
	}

	// 验证状态有效性
	if !r.Status.IsValid() {
		return errors.New("评分状态无效")
	}

	// 验证点赞数不能为负数
	if r.LikeCount < 0 {
		return errors.New("点赞数不能为负数")
	}

	return nil
}
```

#### 1.6 创建电影分类关联模型

电影分类关联模型用于实现电影和分类之间的多对多关系，一部电影可以属于多个分类，一个分类可以包含多部电影。

```go
// internal/models/movie_category.go
package models

import (
	"errors"
	"time"

	"gorm.io/gorm"
)

// MovieCategory 电影分类关联模型
// 实现电影和分类之间的多对多关系映射
// 使用复合主键确保电影和分类的关联唯一性
type MovieCategory struct {
	// === 复合主键字段 ===
	
	// MovieID 电影ID，复合主键的一部分
	// gorm:"primaryKey;index" 主键+索引，支持快速查询电影的所有分类
	MovieID uint `gorm:"primaryKey;index" json:"movie_id"`
	
	// CategoryID 分类ID，复合主键的一部分
	// gorm:"primaryKey;index" 主键+索引，支持快速查询分类下的所有电影
	CategoryID uint `gorm:"primaryKey;index" json:"category_id"`
	
	// === 时间戳字段 ===
	
	// 继承时间戳模型，记录关联关系的创建和更新时间
	// 用于追踪电影分类关系的变更历史
	TimestampModel

	// === 关联关系定义 ===
	
	// Movie 关联的电影实体
	// gorm:"foreignKey:MovieID" 指定外键字段
	// gorm:"constraint:OnDelete:CASCADE" 级联删除，电影删除时自动删除关联关系
	// json:"movie,omitempty" JSON序列化时如果为空则忽略
	Movie Movie `gorm:"foreignKey:MovieID;constraint:OnDelete:CASCADE" json:"movie,omitempty"`
	
	// Category 关联的分类实体
	// gorm:"foreignKey:CategoryID" 指定外键字段
	// gorm:"constraint:OnDelete:CASCADE" 级联删除，分类删除时自动删除关联关系
	// json:"category,omitempty" JSON序列化时如果为空则忽略
	Category Category `gorm:"foreignKey:CategoryID;constraint:OnDelete:CASCADE" json:"category,omitempty"`
}

// TableName 自定义表名
// 指定关联模型在数据库中的表名为 movie_categories
// 遵循复数命名约定，明确表示电影分类关联数据
func (MovieCategory) TableName() string {
	return "movie_categories"
}

// === GORM 钩子函数 ===

// BeforeCreate GORM钩子：创建前数据验证
// 在关联关系创建前执行，确保数据完整性
func (mc *MovieCategory) BeforeCreate(tx *gorm.DB) error {
	// 调用时间戳模型的钩子
	if err := mc.TimestampModel.BeforeCreate(tx); err != nil {
		return err
	}

	// 验证关联数据
	if err := mc.Validate(); err != nil {
		return err
	}

	return nil
}

// BeforeUpdate GORM钩子：更新前数据验证
// 在关联关系更新前执行，确保修改后的数据仍然有效
func (mc *MovieCategory) BeforeUpdate(tx *gorm.DB) error {
	// 调用时间戳模型的钩子
	if err := mc.TimestampModel.BeforeUpdate(tx); err != nil {
		return err
	}

	// 验证关联数据
	if err := mc.Validate(); err != nil {
		return err
	}

	return nil
}

// === 数据验证方法 ===

// Validate 验证关联关系数据的有效性
// 确保电影ID和分类ID都是有效的
func (mc *MovieCategory) Validate() error {
	// 验证电影ID
	if mc.MovieID == 0 {
		return errors.New("电影ID不能为空")
	}

	// 验证分类ID
	if mc.CategoryID == 0 {
		return errors.New("分类ID不能为空")
	}

	return nil
}

// === 工具方法 ===

// IsValid 检查关联关系是否有效
// 快速验证电影ID和分类ID是否都不为零
func (mc *MovieCategory) IsValid() bool {
	return mc.MovieID > 0 && mc.CategoryID > 0
}

// GetRelationKey 获取关联关系的唯一标识
// 返回格式为 "movieID-categoryID" 的字符串，用于缓存键等场景
func (mc *MovieCategory) GetRelationKey() string {
	return fmt.Sprintf("%d-%d", mc.MovieID, mc.CategoryID)
}
```

#### 1.7 创建工具函数

工具函数模块提供了数据模型层常用的辅助功能，包括字符串处理、数据验证、格式转换等实用工具。

```go
// internal/models/utils.go
package models

import (
	"fmt"
	"regexp"
	"strings"
	"unicode"

	"golang.org/x/text/transform"
	"golang.org/x/text/unicode/norm"
)

// === URL Slug 生成工具 ===

// generateSlug 生成URL友好的slug字符串
// 将任意文本转换为适合在URL中使用的格式
// 主要用于电影标题、分类名称等生成SEO友好的URL路径
func generateSlug(text string) string {
	// 转换为小写，确保URL的一致性
	text = strings.ToLower(text)

	// 移除重音符号和特殊字符，支持国际化文本
	// 例如："café" -> "cafe"
	t := transform.Chain(norm.NFD, transform.RemoveFunc(isMn), norm.NFC)
	text, _, _ = transform.String(t, text)

	// 替换所有非字母数字字符为连字符
	// 保持URL的可读性和SEO友好性
	reg := regexp.MustCompile(`[^a-z0-9]+`)
	text = reg.ReplaceAllString(text, "-")

	// 移除首尾的连字符，避免无效的URL格式
	text = strings.Trim(text, "-")

	// 限制长度为100字符，防止URL过长
	// 在单词边界截断，保持语义完整性
	if len(text) > 100 {
		text = text[:100]
		text = strings.Trim(text, "-")
	}

	return text
}

// isMn 检查字符是否为非间距标记（用于移除重音符号）
// 这是Unicode分类中的一种，主要用于识别重音符号等修饰字符
// 在生成slug时需要移除这些字符以确保URL的兼容性
func isMn(r rune) bool {
	return unicode.Is(unicode.Mn, r)
}

// GenerateMovieSlug 为电影生成专用的slug
// 基于电影标题和发布年份生成唯一的URL标识
func GenerateMovieSlug(title string, year int) string {
	slug := generateSlug(title)
	if year > 0 {
		slug = fmt.Sprintf("%s-%d", slug, year)
	}
	return slug
}

// GenerateCategorySlug 为分类生成专用的slug
// 基于分类名称生成URL友好的标识
func GenerateCategorySlug(name string) string {
	return generateSlug(name)
}

// === 数据验证工具 ===

// ValidateModel 通用模型验证函数
// 可以集成第三方验证库（如 go-playground/validator）进行统一的数据验证
// 为所有模型提供一致的验证入口点
func ValidateModel(model interface{}) error {
	// 这里可以集成验证库，如 go-playground/validator
	// 暂时返回nil，后续可以扩展
	return nil
}

// === 字符串处理工具 ===

// SanitizeString 清理和标准化字符串
// 移除多余的空白字符，确保数据的一致性
// 主要用于用户输入的文本内容处理
func SanitizeString(s string) string {
	// 移除首尾空格，清理用户输入
	s = strings.TrimSpace(s)

	// 将多个连续空格替换为单个空格，标准化格式
	reg := regexp.MustCompile(`\s+`)
	s = reg.ReplaceAllString(s, " ")

	return s
}

// TruncateString 智能截断字符串
// 在指定长度处截断文本，尽量在单词边界处截断以保持可读性
// 主要用于生成摘要、预览文本等场景
func TruncateString(s string, length int) string {
	if len(s) <= length {
		return s
	}

	// 尝试在单词边界截断，保持语义完整性
	// 为省略号预留3个字符的空间
	if length > 3 {
		for i := length - 3; i > 0; i-- {
			if s[i] == ' ' {
				return s[:i] + "..."
			}
		}
	}

	// 如果找不到合适的截断点，直接截断并添加省略号
	return s[:length-3] + "..."
}

// CleanMovieTitle 清理电影标题
// 移除特殊字符和多余空格，标准化电影标题格式
func CleanMovieTitle(title string) string {
	// 基础清理
	title = SanitizeString(title)
	
	// 移除常见的特殊字符（保留基本标点）
	reg := regexp.MustCompile(`[<>"'\\|*?]+`)
	title = reg.ReplaceAllString(title, "")
	
	return strings.TrimSpace(title)
}

// === 格式验证工具 ===

// IsValidEmail 验证邮箱地址格式
// 使用正则表达式验证邮箱格式的有效性
// 用于用户注册、联系信息等场景的数据验证
func IsValidEmail(email string) bool {
	reg := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	return reg.MatchString(email)
}

// IsValidURL 验证URL格式
// 检查URL是否符合HTTP/HTTPS协议的标准格式
// 用于验证海报链接、预告片链接等外部资源URL
func IsValidURL(url string) bool {
	reg := regexp.MustCompile(`^https?://[\w\-]+(\.[\ w\-]+)+([\w\-\.,@?^=%&:/~\+#]*[\w\-\@?^=%&/~\+#])?$`)
	return reg.MatchString(url)
}

// IsValidIMDbID 验证IMDb ID格式
// IMDb ID格式为 "tt" + 7位数字，如 "tt0111161"
// 用于验证电影的IMDb标识符
func IsValidIMDbID(imdbID string) bool {
	reg := regexp.MustCompile(`^tt\d{7,8}$`)
	return reg.MatchString(imdbID)
}

// IsValidYear 验证年份范围
// 检查年份是否在合理的电影发布年份范围内
// 通常电影年份应该在1888年（第一部电影）到当前年份+2年之间
func IsValidYear(year int) bool {
	return year >= 1888 && year <= time.Now().Year()+2
}

// === 数据转换工具 ===

// FormatDuration 格式化时长显示
// 将分钟数转换为 "X小时Y分钟" 的友好格式
// 用于前端显示电影时长
func FormatDuration(minutes int) string {
	if minutes <= 0 {
		return "未知"
	}
	
	hours := minutes / 60
	mins := minutes % 60
	
	if hours > 0 {
		if mins > 0 {
			return fmt.Sprintf("%d小时%d分钟", hours, mins)
		}
		return fmt.Sprintf("%d小时", hours)
	}
	
	return fmt.Sprintf("%d分钟", mins)
}

// FormatRating 格式化评分显示
// 将浮点数评分格式化为指定小数位数的字符串
// 用于统一评分的显示格式
func FormatRating(rating float64, precision int) string {
	format := fmt.Sprintf("%%.%df", precision)
	return fmt.Sprintf(format, rating)
}
```

### 步骤2：创建数据库管理器

#### 2.1 创建数据库配置

```go
// internal/database/config.go
package database

import (
	"fmt"
	"time"
)

// Config 数据库配置
type Config struct {
	// 基础连接配置
	Host     string `mapstructure:"host" json:"host"`
	Port     int    `mapstructure:"port" json:"port"`
	Username string `mapstructure:"username" json:"username"`
	Password string `mapstructure:"password" json:"-"`
	Database string `mapstructure:"database" json:"database"`
	Charset  string `mapstructure:"charset" json:"charset"`
	TimeZone string `mapstructure:"timezone" json:"timezone"`

	// 连接池配置
	MaxOpenConns    int           `mapstructure:"max_open_conns" json:"max_open_conns"`
	MaxIdleConns    int           `mapstructure:"max_idle_conns" json:"max_idle_conns"`
	ConnMaxLifetime time.Duration `mapstructure:"conn_max_lifetime" json:"conn_max_lifetime"`
	ConnMaxIdleTime time.Duration `mapstructure:"conn_max_idle_time" json:"conn_max_idle_time"`

	// GORM配置
	LogLevel                  int  `mapstructure:"log_level" json:"log_level"`
	SlowThreshold             time.Duration `mapstructure:"slow_threshold" json:"slow_threshold"`
	SkipDefaultTransaction    bool `mapstructure:"skip_default_transaction" json:"skip_default_transaction"`
	DisableForeignKeyConstraint bool `mapstructure:"disable_foreign_key_constraint" json:"disable_foreign_key_constraint"`

	// 迁移配置
	AutoMigrate bool `mapstructure:"auto_migrate" json:"auto_migrate"`

	// SSL配置
	SSLMode string `mapstructure:"ssl_mode" json:"ssl_mode"`
	SSLCert string `mapstructure:"ssl_cert" json:"ssl_cert"`
	SSLKey  string `mapstructure:"ssl_key" json:"ssl_key"`
	SSLCA   string `mapstructure:"ssl_ca" json:"ssl_ca"`
}

// DefaultConfig 返回默认配置
func DefaultConfig() *Config {
	return &Config{
		Host:     "localhost",
		Port:     3306,
		Username: "root",
		Password: "",
		Database: "movieinfo",
		Charset:  "utf8mb4",
		TimeZone: "Asia/Shanghai",

		MaxOpenConns:    100,
		MaxIdleConns:    10,
		ConnMaxLifetime: time.Hour,
		ConnMaxIdleTime: 10 * time.Minute,

		LogLevel:                    1, // Silent
		SlowThreshold:               200 * time.Millisecond,
		SkipDefaultTransaction:      false,
		DisableForeignKeyConstraint: false,

		AutoMigrate: true,

		SSLMode: "disable",
	}
}

// DSN 生成数据源名称
func (c *Config) DSN() string {
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=%s&parseTime=True&loc=%s",
		c.Username,
		c.Password,
		c.Host,
		c.Port,
		c.Database,
		c.Charset,
		c.TimeZone,
	)

	// 添加SSL配置
	if c.SSLMode != "" {
		dsn += "&tls=" + c.SSLMode
	}

	return dsn
}

// Validate 验证配置
func (c *Config) Validate() error {
	if c.Host == "" {
		return fmt.Errorf("database host is required")
	}
	if c.Port <= 0 || c.Port > 65535 {
		return fmt.Errorf("database port must be between 1 and 65535")
	}
	if c.Username == "" {
		return fmt.Errorf("database username is required")
	}
	if c.Database == "" {
		return fmt.Errorf("database name is required")
	}
	if c.MaxOpenConns <= 0 {
		return fmt.Errorf("max_open_conns must be greater than 0")
	}
	if c.MaxIdleConns <= 0 {
		return fmt.Errorf("max_idle_conns must be greater than 0")
	}
	if c.MaxIdleConns > c.MaxOpenConns {
		return fmt.Errorf("max_idle_conns cannot be greater than max_open_conns")
	}
	return nil
}
```

#### 2.2 创建数据库管理器

```go
// internal/database/manager.go
package database

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"

	logpkg "movieinfo/pkg/logger"
	"movieinfo/internal/models"
)

// Manager 数据库管理器
type Manager struct {
	config *Config
	db     *gorm.DB
	sqlDB  *sql.DB
	logger logpkg.Logger
}

// NewManager 创建数据库管理器
func NewManager(config *Config, logger logpkg.Logger) (*Manager, error) {
	if err := config.Validate(); err != nil {
		return nil, fmt.Errorf("invalid database config: %w", err)
	}

	return &Manager{
		config: config,
		logger: logger,
	}, nil
}

// Connect 连接数据库
func (m *Manager) Connect() error {
	// 创建GORM配置
	gormConfig := &gorm.Config{
		SkipDefaultTransaction:                   m.config.SkipDefaultTransaction,
		DisableForeignKeyConstraintWhenMigrating: m.config.DisableForeignKeyConstraint,
		Logger:                                   m.createGormLogger(),
	}

	// 连接数据库
	db, err := gorm.Open(mysql.Open(m.config.DSN()), gormConfig)
	if err != nil {
		return fmt.Errorf("failed to connect to database: %w", err)
	}

	// 获取底层sql.DB
	sqlDB, err := db.DB()
	if err != nil {
		return fmt.Errorf("failed to get underlying sql.DB: %w", err)
	}

	// 配置连接池
	sqlDB.SetMaxOpenConns(m.config.MaxOpenConns)
	sqlDB.SetMaxIdleConns(m.config.MaxIdleConns)
	sqlDB.SetConnMaxLifetime(m.config.ConnMaxLifetime)
	sqlDB.SetConnMaxIdleTime(m.config.ConnMaxIdleTime)

	m.db = db
	m.sqlDB = sqlDB

	m.logger.Info("Database connected successfully",
		"host", m.config.Host,
		"port", m.config.Port,
		"database", m.config.Database,
	)

	return nil
}

// Close 关闭数据库连接
func (m *Manager) Close() error {
	if m.sqlDB != nil {
		m.logger.Info("Closing database connection")
		return m.sqlDB.Close()
	}
	return nil
}

// DB 获取GORM数据库实例
func (m *Manager) DB() *gorm.DB {
	return m.db
}

// SqlDB 获取原生SQL数据库实例
func (m *Manager) SqlDB() *sql.DB {
	return m.sqlDB
}

// Ping 检查数据库连接
func (m *Manager) Ping(ctx context.Context) error {
	if m.sqlDB == nil {
		return fmt.Errorf("database not connected")
	}
	return m.sqlDB.PingContext(ctx)
}

// Stats 获取连接池统计信息
func (m *Manager) Stats() sql.DBStats {
	if m.sqlDB == nil {
		return sql.DBStats{}
	}
	return m.sqlDB.Stats()
}

// AutoMigrate 自动迁移数据库表
func (m *Manager) AutoMigrate() error {
	if !m.config.AutoMigrate {
		m.logger.Info("Auto migration is disabled")
		return nil
	}

	m.logger.Info("Starting database auto migration")

	// 定义需要迁移的模型
	models := []interface{}{
		&models.User{},
		&models.Category{},
		&models.Movie{},
		&models.Rating{},
		&models.MovieCategory{},
	}

	// 执行迁移
	for _, model := range models {
		if err := m.db.AutoMigrate(model); err != nil {
			return fmt.Errorf("failed to migrate %T: %w", model, err)
		}
	}

	m.logger.Info("Database auto migration completed successfully")
	return nil
}

// Transaction 执行事务
func (m *Manager) Transaction(fn func(*gorm.DB) error) error {
	return m.db.Transaction(fn)
}

// WithContext 创建带上下文的数据库实例
func (m *Manager) WithContext(ctx context.Context) *gorm.DB {
	return m.db.WithContext(ctx)
}

// createGormLogger 创建GORM日志器
func (m *Manager) createGormLogger() logger.Interface {
	return &gormLogger{
		logger:        m.logger,
		slowThreshold: m.config.SlowThreshold,
		logLevel:      logger.LogLevel(m.config.LogLevel),
	}
}

// gormLogger GORM日志器实现
type gormLogger struct {
	logger        logpkg.Logger
	slowThreshold time.Duration
	logLevel      logger.LogLevel
}

// LogMode 设置日志级别
func (l *gormLogger) LogMode(level logger.LogLevel) logger.Interface {
	newLogger := *l
	newLogger.logLevel = level
	return &newLogger
}

// Info 记录信息日志
func (l *gormLogger) Info(ctx context.Context, msg string, data ...interface{}) {
	if l.logLevel >= logger.Info {
		l.logger.Info(fmt.Sprintf(msg, data...))
	}
}

// Warn 记录警告日志
func (l *gormLogger) Warn(ctx context.Context, msg string, data ...interface{}) {
	if l.logLevel >= logger.Warn {
		l.logger.Warn(fmt.Sprintf(msg, data...))
	}
}

// Error 记录错误日志
func (l *gormLogger) Error(ctx context.Context, msg string, data ...interface{}) {
	if l.logLevel >= logger.Error {
		l.logger.Error(fmt.Sprintf(msg, data...))
	}
}

// Trace 记录SQL跟踪日志
func (l *gormLogger) Trace(ctx context.Context, begin time.Time, fc func() (string, int64), err error) {
	if l.logLevel <= logger.Silent {
		return
	}

	elapsed := time.Since(begin)
	sql, rows := fc()

	fields := []interface{}{
		"elapsed", elapsed,
		"rows", rows,
		"sql", sql,
	}

	switch {
	case err != nil && l.logLevel >= logger.Error:
		l.logger.Error("SQL execution failed", append(fields, "error", err)...)
	case elapsed > l.slowThreshold && l.slowThreshold != 0 && l.logLevel >= logger.Warn:
		l.logger.Warn("Slow SQL detected", fields...)
	case l.logLevel == logger.Info:
		l.logger.Debug("SQL executed", fields...)
	}
}
```

### 步骤3：创建缓存管理器

#### 3.1 创建缓存配置

```go
// internal/cache/manager.go
package cache

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/go-redis/redis/v8"

	logpkg "movieinfo/pkg/logger"
)

// Manager 缓存管理器
type Manager struct {
	config *Config
	client *redis.Client
	logger logpkg.Logger
}

// NewManager 创建缓存管理器
func NewManager(config *Config, logger logpkg.Logger) (*Manager, error) {
	if err := config.Validate(); err != nil {
		return nil, fmt.Errorf("invalid cache config: %w", err)
	}

	return &Manager{
		config: config,
		logger: logger,
	}, nil
}

// Connect 连接Redis
func (m *Manager) Connect() error {
	if !m.config.Enabled {
		m.logger.Info("Cache is disabled")
		return nil
	}

	// 创建Redis客户端
	m.client = redis.NewClient(&redis.Options{
		Addr:         m.config.Address(),
		Password:     m.config.Password,
		DB:           m.config.DB,
		PoolSize:     m.config.PoolSize,
		MinIdleConns: m.config.MinIdleConns,
		MaxConnAge:   m.config.MaxConnAge,
		PoolTimeout:  m.config.PoolTimeout,
		IdleTimeout:  m.config.IdleTimeout,
		DialTimeout:  m.config.DialTimeout,
		ReadTimeout:  m.config.ReadTimeout,
		WriteTimeout: m.config.WriteTimeout,
	})

	// 测试连接
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := m.client.Ping(ctx).Err(); err != nil {
		return fmt.Errorf("failed to connect to redis: %w", err)
	}

	m.logger.Info("Cache connected successfully",
		"host", m.config.Host,
		"port", m.config.Port,
		"db", m.config.DB,
	)

	return nil
}

// Close 关闭Redis连接
func (m *Manager) Close() error {
	if m.client != nil {
		m.logger.Info("Closing cache connection")
		return m.client.Close()
	}
	return nil
}

// Client 获取Redis客户端
func (m *Manager) Client() *redis.Client {
	return m.client
}

// IsEnabled 检查缓存是否启用
func (m *Manager) IsEnabled() bool {
	return m.config.Enabled && m.client != nil
}

// buildKey 构建缓存键
func (m *Manager) buildKey(key string) string {
	return m.config.KeyPrefix + key
}

// Set 设置缓存
func (m *Manager) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error {
	if !m.IsEnabled() {
		return nil
	}

	data, err := json.Marshal(value)
	if err != nil {
		return fmt.Errorf("failed to marshal value: %w", err)
	}

	if ttl == 0 {
		ttl = m.config.DefaultTTL
	}

	return m.client.Set(ctx, m.buildKey(key), data, ttl).Err()
}

// Get 获取缓存
func (m *Manager) Get(ctx context.Context, key string, dest interface{}) error {
	if !m.IsEnabled() {
		return redis.Nil
	}

	data, err := m.client.Get(ctx, m.buildKey(key)).Result()
	if err != nil {
		return err
	}

	return json.Unmarshal([]byte(data), dest)
}

// Delete 删除缓存
func (m *Manager) Delete(ctx context.Context, keys ...string) error {
	if !m.IsEnabled() {
		return nil
	}

	if len(keys) == 0 {
		return nil
	}

	// 构建完整的键名
	fullKeys := make([]string, len(keys))
	for i, key := range keys {
		fullKeys[i] = m.buildKey(key)
	}

	return m.client.Del(ctx, fullKeys...).Err()
}

// Exists 检查缓存是否存在
func (m *Manager) Exists(ctx context.Context, key string) (bool, error) {
	if !m.IsEnabled() {
		return false, nil
	}

	count, err := m.client.Exists(ctx, m.buildKey(key)).Result()
	return count > 0, err
}

// Expire 设置过期时间
func (m *Manager) Expire(ctx context.Context, key string, ttl time.Duration) error {
	if !m.IsEnabled() {
		return nil
	}

	return m.client.Expire(ctx, m.buildKey(key), ttl).Err()
}

// TTL 获取剩余过期时间
func (m *Manager) TTL(ctx context.Context, key string) (time.Duration, error) {
	if !m.IsEnabled() {
		return 0, nil
	}

	return m.client.TTL(ctx, m.buildKey(key)).Result()
}

// Increment 递增
func (m *Manager) Increment(ctx context.Context, key string, value int64) (int64, error) {
	if !m.IsEnabled() {
		return 0, nil
	}

	return m.client.IncrBy(ctx, m.buildKey(key), value).Result()
}

// Decrement 递减
func (m *Manager) Decrement(ctx context.Context, key string, value int64) (int64, error) {
	if !m.IsEnabled() {
		return 0, nil
	}

	return m.client.DecrBy(ctx, m.buildKey(key), value).Result()
}

// FlushDB 清空当前数据库
func (m *Manager) FlushDB(ctx context.Context) error {
	if !m.IsEnabled() {
		return nil
	}

	return m.client.FlushDB(ctx).Err()
}

// FlushAll 清空所有数据库
func (m *Manager) FlushAll(ctx context.Context) error {
	if !m.IsEnabled() {
		return nil
	}

	return m.client.FlushAll(ctx).Err()
}

// Keys 获取匹配的键
func (m *Manager) Keys(ctx context.Context, pattern string) ([]string, error) {
	if !m.IsEnabled() {
		return nil, nil
	}

	keys, err := m.client.Keys(ctx, m.buildKey(pattern)).Result()
	if err != nil {
		return nil, err
	}

	// 移除键前缀
	prefixLen := len(m.config.KeyPrefix)
	for i, key := range keys {
		if len(key) > prefixLen {
			keys[i] = key[prefixLen:]
		}
	}

	return keys, nil
}

// Pipeline 创建管道
func (m *Manager) Pipeline() redis.Pipeliner {
	if !m.IsEnabled() {
		return nil
	}

	return m.client.Pipeline()
}

// TxPipeline 创建事务管道
func (m *Manager) TxPipeline() redis.Pipeliner {
	if !m.IsEnabled() {
		return nil
	}

	return m.client.TxPipeline()
}

// Stats 获取连接池统计信息
func (m *Manager) Stats() *redis.PoolStats {
	if !m.IsEnabled() {
		return nil
	}

	return m.client.PoolStats()
}

// Ping 检查连接
func (m *Manager) Ping(ctx context.Context) error {
	if !m.IsEnabled() {
		return nil
	}

	return m.client.Ping(ctx).Err()
}
```

### 步骤4：创建数据访问层接口

#### 4.1 创建基础仓储接口

```go
// internal/repository/interfaces.go
package repository

import (
	"context"

	"movieinfo/internal/models"
)

// BaseRepository 基础仓储接口
type BaseRepository[T any] interface {
	// 基础CRUD操作
	Create(ctx context.Context, entity *T) error
	GetByID(ctx context.Context, id uint) (*T, error)
	Update(ctx context.Context, entity *T) error
	Delete(ctx context.Context, id uint) error
	SoftDelete(ctx context.Context, id uint) error

	// 批量操作
	BatchCreate(ctx context.Context, entities []*T) error
	BatchUpdate(ctx context.Context, entities []*T) error
	BatchDelete(ctx context.Context, ids []uint) error

	// 查询操作
	Exists(ctx context.Context, id uint) (bool, error)
	Count(ctx context.Context, conditions map[string]interface{}) (int64, error)
}

// UserRepository 用户仓储接口
type UserRepository interface {
	BaseRepository[models.User]

	// 用户特定查询
	GetByUsername(ctx context.Context, username string) (*models.User, error)
	GetByEmail(ctx context.Context, email string) (*models.User, error)
	GetByUsernameOrEmail(ctx context.Context, usernameOrEmail string) (*models.User, error)

	// 用户列表查询
	List(ctx context.Context, params *UserListParams) ([]*models.User, int64, error)
	GetActiveUsers(ctx context.Context, limit int) ([]*models.User, error)
	GetUsersByStatus(ctx context.Context, status models.UserStatus, limit, offset int) ([]*models.User, error)

	// 用户统计
	GetUserStats(ctx context.Context, userID uint) (*UserStats, error)
	GetRegistrationStats(ctx context.Context, days int) ([]DailyStats, error)

	// 用户操作
	UpdateLastLogin(ctx context.Context, userID uint) error
	UpdatePassword(ctx context.Context, userID uint, hashedPassword string) error
	VerifyUser(ctx context.Context, userID uint) error
	ChangeStatus(ctx context.Context, userID uint, status models.UserStatus) error
}

// CategoryRepository 分类仓储接口
type CategoryRepository interface {
	BaseRepository[models.Category]

	// 分类特定查询
	GetBySlug(ctx context.Context, slug string) (*models.Category, error)
	GetByName(ctx context.Context, name string) (*models.Category, error)

	// 分类列表查询
	List(ctx context.Context, params *CategoryListParams) ([]*models.Category, int64, error)
	GetActiveCategories(ctx context.Context) ([]*models.Category, error)
	GetCategoriesWithMovieCount(ctx context.Context) ([]*CategoryWithCount, error)

	// 分类操作
	UpdateSortOrder(ctx context.Context, categoryID uint, sortOrder int) error
	ToggleStatus(ctx context.Context, categoryID uint) error
}

// MovieRepository 电影仓储接口
type MovieRepository interface {
	BaseRepository[models.Movie]

	// 电影特定查询
	GetBySlug(ctx context.Context, slug string) (*models.Movie, error)
	GetByIMDbID(ctx context.Context, imdbID string) (*models.Movie, error)
	GetByTMDbID(ctx context.Context, tmdbID int64) (*models.Movie, error)

	// 电影列表查询
	List(ctx context.Context, params *MovieListParams) ([]*models.Movie, int64, error)
	GetPublishedMovies(ctx context.Context, limit, offset int) ([]*models.Movie, error)
	GetMoviesByCategory(ctx context.Context, categoryID uint, limit, offset int) ([]*models.Movie, error)
	GetMoviesByGenre(ctx context.Context, genre string, limit, offset int) ([]*models.Movie, error)
	GetMoviesByYear(ctx context.Context, year int, limit, offset int) ([]*models.Movie, error)
	GetPopularMovies(ctx context.Context, limit int) ([]*models.Movie, error)
	GetTopRatedMovies(ctx context.Context, limit int) ([]*models.Movie, error)
	GetRecentMovies(ctx context.Context, limit int) ([]*models.Movie, error)

	// 电影搜索
	Search(ctx context.Context, params *MovieSearchParams) ([]*models.Movie, int64, error)
	SearchByTitle(ctx context.Context, title string, limit, offset int) ([]*models.Movie, error)

	// 电影统计
	GetMovieStats(ctx context.Context, movieID uint) (*MovieStats, error)
	GetGenreStats(ctx context.Context) ([]GenreStats, error)
	GetYearStats(ctx context.Context) ([]YearStats, error)

	// 电影操作
	Publish(ctx context.Context, movieID uint) error
	Unpublish(ctx context.Context, movieID uint) error
	IncrementViewCount(ctx context.Context, movieID uint) error
	UpdateRating(ctx context.Context, movieID uint, rating float64, count int64) error

	// 电影关联
	AddCategories(ctx context.Context, movieID uint, categoryIDs []uint) error
	RemoveCategories(ctx context.Context, movieID uint, categoryIDs []uint) error
	GetMovieCategories(ctx context.Context, movieID uint) ([]*models.Category, error)
}

// RatingRepository 评分仓储接口
type RatingRepository interface {
	BaseRepository[models.Rating]

	// 评分特定查询
	GetByUserAndMovie(ctx context.Context, userID, movieID uint) (*models.Rating, error)
	GetUserRatings(ctx context.Context, userID uint, limit, offset int) ([]*models.Rating, error)
	GetMovieRatings(ctx context.Context, movieID uint, limit, offset int) ([]*models.Rating, error)

	// 评分列表查询
	List(ctx context.Context, params *RatingListParams) ([]*models.Rating, int64, error)
	GetPublicRatings(ctx context.Context, limit, offset int) ([]*models.Rating, error)
	GetPendingRatings(ctx context.Context, limit, offset int) ([]*models.Rating, error)
	GetTopRatings(ctx context.Context, limit int) ([]*models.Rating, error)

	// 评分统计
	GetMovieRatingStats(ctx context.Context, movieID uint) (*MovieRatingStats, error)
	GetUserRatingStats(ctx context.Context, userID uint) (*UserRatingStats, error)
	GetRatingDistribution(ctx context.Context, movieID uint) ([]RatingDistribution, error)

	// 评分操作
	Approve(ctx context.Context, ratingID uint) error
	Reject(ctx context.Context, ratingID uint) error
	ToggleVisibility(ctx context.Context, ratingID uint) error
	IncrementLikeCount(ctx context.Context, ratingID uint) error
	DecrementLikeCount(ctx context.Context, ratingID uint) error

	// 评分验证
	HasUserRated(ctx context.Context, userID, movieID uint) (bool, error)
	CanUserRate(ctx context.Context, userID, movieID uint) (bool, error)
}

// 查询参数结构体
type UserListParams struct {
	Keyword  string             `json:"keyword"`
	Status   *models.UserStatus `json:"status"`
	Verified *bool              `json:"verified"`
	Limit    int                `json:"limit"`
	Offset   int                `json:"offset"`
	SortBy   string             `json:"sort_by"`
	SortDesc bool               `json:"sort_desc"`
}

type CategoryListParams struct {
	Keyword  string `json:"keyword"`
	Active   *bool  `json:"active"`
	Limit    int    `json:"limit"`
	Offset   int    `json:"offset"`
	SortBy   string `json:"sort_by"`
	SortDesc bool   `json:"sort_desc"`
}

type MovieListParams struct {
	Keyword     string              `json:"keyword"`
	Status      *models.MovieStatus `json:"status"`
	Published   *bool               `json:"published"`
	CategoryID  *uint               `json:"category_id"`
	Genre       string              `json:"genre"`
	Year        *int                `json:"year"`
	MinRating   *float64            `json:"min_rating"`
	MaxRating   *float64            `json:"max_rating"`
	MinRuntime  *int                `json:"min_runtime"`
	MaxRuntime  *int                `json:"max_runtime"`
	Limit       int                 `json:"limit"`
	Offset      int                 `json:"offset"`
	SortBy      string              `json:"sort_by"`
	SortDesc    bool                `json:"sort_desc"`
}

type MovieSearchParams struct {
	Query       string   `json:"query"`
	Genres      []string `json:"genres"`
	YearFrom    *int     `json:"year_from"`
	YearTo      *int     `json:"year_to"`
	MinRating   *float64 `json:"min_rating"`
	MaxRating   *float64 `json:"max_rating"`
	MinRuntime  *int     `json:"min_runtime"`
	MaxRuntime  *int     `json:"max_runtime"`
	Limit       int      `json:"limit"`
	Offset      int      `json:"offset"`
}

type RatingListParams struct {
	UserID   *uint                `json:"user_id"`
	MovieID  *uint                `json:"movie_id"`
	Status   *models.RatingStatus `json:"status"`
	Public   *bool                `json:"public"`
	MinScore *float64             `json:"min_score"`
	MaxScore *float64             `json:"max_score"`
	Limit    int                  `json:"limit"`
	Offset   int                  `json:"offset"`
	SortBy   string               `json:"sort_by"`
	SortDesc bool                 `json:"sort_desc"`
}

// 统计结构体
type UserStats struct {
	TotalRatings   int64   `json:"total_ratings"`
	AverageRating  float64 `json:"average_rating"`
	FavoriteGenres []string `json:"favorite_genres"`
	TotalMovies    int64   `json:"total_movies"`
}

type MovieStats struct {
	TotalRatings    int64   `json:"total_ratings"`
	AverageRating   float64 `json:"average_rating"`
	TotalViews      int64   `json:"total_views"`
	TotalComments   int64   `json:"total_comments"`
	PopularityScore float64 `json:"popularity_score"`
}

type MovieRatingStats struct {
	TotalRatings  int64   `json:"total_ratings"`
	AverageRating float64 `json:"average_rating"`
	RatingSum     float64 `json:"rating_sum"`
	Distribution  []RatingDistribution `json:"distribution"`
}

type UserRatingStats struct {
	TotalRatings   int64   `json:"total_ratings"`
	AverageRating  float64 `json:"average_rating"`
	HighestRating  float64 `json:"highest_rating"`
	LowestRating   float64 `json:"lowest_rating"`
	FavoriteGenres []string `json:"favorite_genres"`
}

type CategoryWithCount struct {
	*models.Category
	MovieCount int64 `json:"movie_count"`
}

type DailyStats struct {
	Date  string `json:"date"`
	Count int64  `json:"count"`
}

type GenreStats struct {
	Genre      string  `json:"genre"`
	Count      int64   `json:"count"`
	AvgRating  float64 `json:"avg_rating"`
	TotalViews int64   `json:"total_views"`
}

type YearStats struct {
	Year       int     `json:"year"`
	Count      int64   `json:"count"`
	AvgRating  float64 `json:"avg_rating"`
	TotalViews int64   `json:"total_views"`
}

type RatingDistribution struct {
	Score float64 `json:"score"`
	Count int64   `json:"count"`
}
```

### 步骤5：创建数据模型层配置文件

#### 5.1 创建数据库配置文件

```yaml
# configs/database.yaml
database:
  # 基础连接配置
  host: "localhost"
  port: 3306
  username: "root"
  password: "your_password"
  database: "movieinfo"
  charset: "utf8mb4"
  timezone: "Asia/Shanghai"

  # 连接池配置
  max_open_conns: 100
  max_idle_conns: 10
  conn_max_lifetime: "1h"
  conn_max_idle_time: "10m"

  # GORM配置
  log_level: 1  # 1=Silent, 2=Error, 3=Warn, 4=Info
  slow_threshold: "200ms"
  skip_default_transaction: false
  disable_foreign_key_constraint: false

  # 迁移配置
  auto_migrate: true

  # SSL配置
  ssl_mode: "disable"
  ssl_cert: ""
  ssl_key: ""
  ssl_ca: ""
```

#### 5.2 创建缓存配置文件

```yaml
# configs/cache.yaml
cache:
  # Redis连接配置
  host: "localhost"
  port: 6379
  password: ""
  db: 0

  # 连接池配置
  pool_size: 10
  min_idle_conns: 3
  max_conn_age: "30m"
  pool_timeout: "4s"
  idle_timeout: "5m"

  # 超时配置
  dial_timeout: "5s"
  read_timeout: "3s"
  write_timeout: "3s"

  # 缓存配置
  default_ttl: "1h"
  key_prefix: "movieinfo:"

  # 功能开关
  enabled: true
```

#### 5.3 创建数据模型层初始化脚本

```go
// internal/models/init.go
package models

import (
	"context"
	"fmt"

	"movieinfo/internal/cache"
	"movieinfo/internal/database"
	"movieinfo/pkg/config"
	"movieinfo/pkg/logger"
)

// DataLayer 数据层结构
type DataLayer struct {
	DB    *database.Manager
	Cache *cache.Manager
}

// InitDataLayer 初始化数据层
func InitDataLayer(cfg *config.Config, logger logger.Logger) (*DataLayer, error) {
	// 初始化数据库
	dbConfig := &database.Config{
		Host:                        cfg.Database.Host,
		Port:                        cfg.Database.Port,
		Username:                    cfg.Database.Username,
		Password:                    cfg.Database.Password,
		Database:                    cfg.Database.Database,
		Charset:                     cfg.Database.Charset,
		TimeZone:                    cfg.Database.TimeZone,
		MaxOpenConns:                cfg.Database.MaxOpenConns,
		MaxIdleConns:                cfg.Database.MaxIdleConns,
		ConnMaxLifetime:             cfg.Database.ConnMaxLifetime,
		ConnMaxIdleTime:             cfg.Database.ConnMaxIdleTime,
		LogLevel:                    cfg.Database.LogLevel,
		SlowThreshold:               cfg.Database.SlowThreshold,
		SkipDefaultTransaction:      cfg.Database.SkipDefaultTransaction,
		DisableForeignKeyConstraint: cfg.Database.DisableForeignKeyConstraint,
		AutoMigrate:                 cfg.Database.AutoMigrate,
		SSLMode:                     cfg.Database.SSLMode,
		SSLCert:                     cfg.Database.SSLCert,
		SSLKey:                      cfg.Database.SSLKey,
		SSLCA:                       cfg.Database.SSLCA,
	}

	dbManager, err := database.NewManager(dbConfig, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to create database manager: %w", err)
	}

	if err := dbManager.Connect(); err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	// 执行数据库迁移
	if err := dbManager.AutoMigrate(); err != nil {
		return nil, fmt.Errorf("failed to migrate database: %w", err)
	}

	// 初始化缓存
	cacheConfig := &cache.Config{
		Host:         cfg.Cache.Host,
		Port:         cfg.Cache.Port,
		Password:     cfg.Cache.Password,
		DB:           cfg.Cache.DB,
		PoolSize:     cfg.Cache.PoolSize,
		MinIdleConns: cfg.Cache.MinIdleConns,
		MaxConnAge:   cfg.Cache.MaxConnAge,
		PoolTimeout:  cfg.Cache.PoolTimeout,
		IdleTimeout:  cfg.Cache.IdleTimeout,
		DialTimeout:  cfg.Cache.DialTimeout,
		ReadTimeout:  cfg.Cache.ReadTimeout,
		WriteTimeout: cfg.Cache.WriteTimeout,
		DefaultTTL:   cfg.Cache.DefaultTTL,
		KeyPrefix:    cfg.Cache.KeyPrefix,
		Enabled:      cfg.Cache.Enabled,
	}

	cacheManager, err := cache.NewManager(cacheConfig, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to create cache manager: %w", err)
	}

	if err := cacheManager.Connect(); err != nil {
		return nil, fmt.Errorf("failed to connect to cache: %w", err)
	}

	return &DataLayer{
		DB:    dbManager,
		Cache: cacheManager,
	}, nil
}

// Close 关闭数据层连接
func (dl *DataLayer) Close() error {
	var errs []error

	if dl.Cache != nil {
		if err := dl.Cache.Close(); err != nil {
			errs = append(errs, fmt.Errorf("failed to close cache: %w", err))
		}
	}

	if dl.DB != nil {
		if err := dl.DB.Close(); err != nil {
			errs = append(errs, fmt.Errorf("failed to close database: %w", err))
		}
	}

	if len(errs) > 0 {
		return fmt.Errorf("errors closing data layer: %v", errs)
	}

	return nil
}

// HealthCheck 健康检查
func (dl *DataLayer) HealthCheck(ctx context.Context) error {
	// 检查数据库连接
	if err := dl.DB.Ping(ctx); err != nil {
		return fmt.Errorf("database health check failed: %w", err)
	}

	// 检查缓存连接
	if dl.Cache.IsEnabled() {
		if err := dl.Cache.Ping(ctx); err != nil {
			return fmt.Errorf("cache health check failed: %w", err)
		}
	}

	return nil
}
```

## 测试验证

### 单元测试

#### 1. 数据模型测试

```go
// internal/models/user_test.go
package models

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestUser_HashPassword(t *testing.T) {
	user := &User{
		Username: "testuser",
		Email:    "test@example.com",
		Password: "password123",
	}

	err := user.HashPassword()
	require.NoError(t, err)
	assert.NotEqual(t, "password123", user.Password)
	assert.True(t, user.CheckPassword("password123"))
	assert.False(t, user.CheckPassword("wrongpassword"))
}

func TestUser_IsActive(t *testing.T) {
	tests := []struct {
		name     string
		status   UserStatus
		expected bool
	}{
		{"Active user", UserStatusActive, true},
		{"Inactive user", UserStatusInactive, false},
		{"Suspended user", UserStatusSuspended, false},
		{"Banned user", UserStatusBanned, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			user := &User{Status: tt.status}
			assert.Equal(t, tt.expected, user.IsActive())
		})
	}
}

func TestUser_UpdateLoginInfo(t *testing.T) {
	user := &User{LoginCount: 5}
	before := time.Now()

	user.UpdateLoginInfo()

	assert.Equal(t, int64(6), user.LoginCount)
	assert.NotNil(t, user.LastLoginAt)
	assert.True(t, user.LastLoginAt.After(before))
}

func TestUser_Verify(t *testing.T) {
	user := &User{
		Status:     UserStatusInactive,
		IsVerified: false,
	}
	before := time.Now()

	user.Verify()

	assert.True(t, user.IsVerified)
	assert.NotNil(t, user.VerifiedAt)
	assert.True(t, user.VerifiedAt.After(before))
	assert.Equal(t, UserStatusActive, user.Status)
}
```

#### 2. 数据库管理器测试

```go
// internal/database/manager_test.go
package database

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"movieinfo/pkg/logger"
)

func TestManager_Connect(t *testing.T) {
	config := DefaultConfig()
	config.Database = "test_movieinfo"

	logger := logger.NewNopLogger()
	manager, err := NewManager(config, logger)
	require.NoError(t, err)

	err = manager.Connect()
	require.NoError(t, err)
	defer manager.Close()

	// 测试连接
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	err = manager.Ping(ctx)
	assert.NoError(t, err)

	// 测试统计信息
	stats := manager.Stats()
	assert.GreaterOrEqual(t, stats.MaxOpenConnections, 0)
}

func TestManager_Transaction(t *testing.T) {
	config := DefaultConfig()
	config.Database = "test_movieinfo"

	logger := logger.NewNopLogger()
	manager, err := NewManager(config, logger)
	require.NoError(t, err)

	err = manager.Connect()
	require.NoError(t, err)
	defer manager.Close()

	// 测试事务
	err = manager.Transaction(func(tx *gorm.DB) error {
		// 在事务中执行一些操作
		return nil
	})
	assert.NoError(t, err)
}
```

#### 3. 缓存管理器测试

```go
// internal/cache/manager_test.go
package cache

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"movieinfo/pkg/logger"
)

func TestManager_SetGet(t *testing.T) {
	config := DefaultConfig()
	config.DB = 1 // 使用测试数据库

	logger := logger.NewNopLogger()
	manager, err := NewManager(config, logger)
	require.NoError(t, err)

	err = manager.Connect()
	require.NoError(t, err)
	defer manager.Close()

	ctx := context.Background()

	// 测试设置和获取
	testData := map[string]interface{}{
		"name": "test",
		"age":  25,
	}

	err = manager.Set(ctx, "test:user:1", testData, time.Minute)
	require.NoError(t, err)

	var result map[string]interface{}
	err = manager.Get(ctx, "test:user:1", &result)
	require.NoError(t, err)
	assert.Equal(t, "test", result["name"])
	assert.Equal(t, float64(25), result["age"])

	// 测试删除
	err = manager.Delete(ctx, "test:user:1")
	require.NoError(t, err)

	err = manager.Get(ctx, "test:user:1", &result)
	assert.Error(t, err)
}

func TestManager_Increment(t *testing.T) {
	config := DefaultConfig()
	config.DB = 1

	logger := logger.NewNopLogger()
	manager, err := NewManager(config, logger)
	require.NoError(t, err)

	err = manager.Connect()
	require.NoError(t, err)
	defer manager.Close()

	ctx := context.Background()

	// 测试递增
	value, err := manager.Increment(ctx, "test:counter", 1)
	require.NoError(t, err)
	assert.Equal(t, int64(1), value)

	value, err = manager.Increment(ctx, "test:counter", 5)
	require.NoError(t, err)
	assert.Equal(t, int64(6), value)

	// 清理
	manager.Delete(ctx, "test:counter")
}
```

### 集成测试

```go
// tests/integration/data_layer_test.go
package integration

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"

	"movieinfo/internal/models"
	"movieinfo/pkg/config"
	"movieinfo/pkg/logger"
)

type DataLayerTestSuite struct {
	suite.Suite
	dataLayer *models.DataLayer
	ctx       context.Context
}

func (suite *DataLayerTestSuite) SetupSuite() {
	// 加载测试配置
	cfg := config.LoadTestConfig()
	logger := logger.NewNopLogger()

	// 初始化数据层
	dataLayer, err := models.InitDataLayer(cfg, logger)
	suite.Require().NoError(err)

	suite.dataLayer = dataLayer
	suite.ctx = context.Background()
}

func (suite *DataLayerTestSuite) TearDownSuite() {
	if suite.dataLayer != nil {
		suite.dataLayer.Close()
	}
}

func (suite *DataLayerTestSuite) TestHealthCheck() {
	err := suite.dataLayer.HealthCheck(suite.ctx)
	suite.NoError(err)
}

func (suite *DataLayerTestSuite) TestUserCRUD() {
	db := suite.dataLayer.DB.DB()

	// 创建用户
	user := &models.User{
		Username: "testuser",
		Email:    "test@example.com",
		Password: "password123",
		Nickname: "Test User",
	}

	err := db.Create(user).Error
	suite.NoError(err)
	suite.NotZero(user.ID)

	// 读取用户
	var foundUser models.User
	err = db.First(&foundUser, user.ID).Error
	suite.NoError(err)
	suite.Equal(user.Username, foundUser.Username)
	suite.Equal(user.Email, foundUser.Email)

	// 更新用户
	foundUser.Nickname = "Updated User"
	err = db.Save(&foundUser).Error
	suite.NoError(err)

	// 验证更新
	var updatedUser models.User
	err = db.First(&updatedUser, user.ID).Error
	suite.NoError(err)
	suite.Equal("Updated User", updatedUser.Nickname)

	// 删除用户
	err = db.Delete(&updatedUser).Error
	suite.NoError(err)
}

func (suite *DataLayerTestSuite) TestCacheIntegration() {
	cache := suite.dataLayer.Cache

	if !cache.IsEnabled() {
		suite.T().Skip("Cache is disabled")
	}

	// 测试缓存操作
	testData := map[string]interface{}{
		"id":   1,
		"name": "Test Movie",
	}

	err := cache.Set(suite.ctx, "movie:1", testData, time.Minute)
	suite.NoError(err)

	var result map[string]interface{}
	err = cache.Get(suite.ctx, "movie:1", &result)
	suite.NoError(err)
	suite.Equal(testData["name"], result["name"])

	// 清理
	cache.Delete(suite.ctx, "movie:1")
}

func TestDataLayerTestSuite(t *testing.T) {
	suite.Run(t, new(DataLayerTestSuite))
}
```

## 预期结果

完成本步骤后，您应该拥有：

1. **完整的数据模型定义**：
   - 用户模型（User）
   - 电影分类模型（Category）
   - 电影模型（Movie）
   - 评分模型（Rating）
   - 关联模型（MovieCategory）

2. **数据库管理器**：
   - 数据库连接管理
   - 连接池配置
   - 事务支持
   - 自动迁移
   - 日志集成

3. **缓存管理器**：
   - Redis连接管理
   - 缓存操作接口
   - 连接池配置
   - 管道支持

4. **数据访问层接口**：
   - 基础仓储接口
   - 特定业务接口
   - 查询参数结构
   - 统计结构定义

5. **配置文件**：
   - 数据库配置
   - 缓存配置
   - 环境隔离

6. **测试覆盖**：
   - 单元测试
   - 集成测试
   - 健康检查

## 注意事项

### 安全性

1. **密码安全**：
   - 使用bcrypt加密密码
   - 密码字段不在JSON中序列化
   - 密码复杂度验证

2. **SQL注入防护**：
   - 使用GORM的参数化查询
   - 输入验证和清理
   - 避免动态SQL拼接

3. **数据验证**：
   - 模型字段验证
   - 业务规则验证
   - 数据完整性约束

### 性能优化

1. **数据库优化**：
   - 合理的索引设计
   - 连接池配置优化
   - 慢查询监控
   - 查询优化

2. **缓存策略**：
   - 合理的TTL设置
   - 缓存键命名规范
   - 缓存穿透防护
   - 缓存雪崩防护

3. **内存管理**：
   - 避免内存泄漏
   - 合理的批量操作大小
   - 连接资源及时释放

### 维护性

1. **代码组织**：
   - 清晰的目录结构
   - 接口与实现分离
   - 统一的错误处理

2. **日志记录**：
   - 详细的操作日志
   - 错误日志记录
   - 性能监控日志

3. **测试覆盖**：
   - 完整的单元测试
   - 集成测试
   - 性能测试

## 下一步骤

完成数据模型层开发后，接下来将进行：

1. **用户服务开发**（07-用户服务开发.md）
   - 用户仓储实现
   - 用户业务逻辑
   - 用户gRPC服务
   - 用户认证授权

2. **关键检查点**：
   - [ ] 所有数据模型定义完成
   - [ ] 数据库连接正常
   - [ ] 缓存连接正常
   - [ ] 数据模型测试通过
   - [ ] 数据库迁移成功
   - [ ] 配置文件完整
   - [ ] 日志记录正常
   - [ ] 健康检查通过

请确保所有检查点都已完成，然后继续下一个开发步骤。
	"fmt"
	"time"
)

// Config 缓存配置
type Config struct {
	// Redis连接配置
	Host     string `mapstructure:"host" json:"host"`
	Port     int    `mapstructure:"port" json:"port"`
	Password string `mapstructure:"password" json:"-"`
	DB       int    `mapstructure:"db" json:"db"`

	// 连接池配置
	PoolSize     int           `mapstructure:"pool_size" json:"pool_size"`
	MinIdleConns int           `mapstructure:"min_idle_conns" json:"min_idle_conns"`
	MaxConnAge   time.Duration `mapstructure:"max_conn_age" json:"max_conn_age"`
	PoolTimeout  time.Duration `mapstructure:"pool_timeout" json:"pool_timeout"`
	IdleTimeout  time.Duration `mapstructure:"idle_timeout" json:"idle_timeout"`

	// 超时配置
	DialTimeout  time.Duration `mapstructure:"dial_timeout" json:"dial_timeout"`
	ReadTimeout  time.Duration `mapstructure:"read_timeout" json:"read_timeout"`
	WriteTimeout time.Duration `mapstructure:"write_timeout" json:"write_timeout"`

	// 缓存配置
	DefaultTTL time.Duration `mapstructure:"default_ttl" json:"default_ttl"`
	KeyPrefix  string        `mapstructure:"key_prefix" json:"key_prefix"`

	// 功能开关
	Enabled bool `mapstructure:"enabled" json:"enabled"`
}

// DefaultConfig 返回默认配置
func DefaultConfig() *Config {
	return &Config{
		Host:     "localhost",
		Port:     6379,
		Password: "",
		DB:       0,

		PoolSize:     10,
		MinIdleConns: 3,
		MaxConnAge:   30 * time.Minute,
		PoolTimeout:  4 * time.Second,
		IdleTimeout:  5 * time.Minute,

		DialTimeout:  5 * time.Second,
		ReadTimeout:  3 * time.Second,
		WriteTimeout: 3 * time.Second,

		DefaultTTL: 1 * time.Hour,
		KeyPrefix:  "movieinfo:",

		Enabled: true,
	}
}

// Address 返回Redis地址
func (c *Config) Address() string {
	return fmt.Sprintf("%s:%d", c.Host, c.Port)
}

// Validate 验证配置
func (c *Config) Validate() error {
	if !c.Enabled {
		return nil
	}

	if c.Host == "" {
		return fmt.Errorf("redis host is required")
	}
	if c.Port <= 0 || c.Port > 65535 {
		return fmt.Errorf("redis port must be between 1 and 65535")
	}
	if c.DB < 0 || c.DB > 15 {
		return fmt.Errorf("redis db must be between 0 and 15")
	}
	if c.PoolSize <= 0 {
		return fmt.Errorf("pool_size must be greater than 0")
	}
	if c.MinIdleConns < 0 {
		return fmt.Errorf("min_idle_conns cannot be negative")
	}
	if c.MinIdleConns > c.PoolSize {
		return fmt.Errorf("min_idle_conns cannot be greater than pool_size")
	}
	return nil
}
```

#### 3.2 创建缓存管理器

```go
// internal/cache