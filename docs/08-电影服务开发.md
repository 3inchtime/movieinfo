# 08-电影服务开发

## 目标说明

本步骤将实现 MovieInfo 项目的电影服务，包括电影数据访问层、业务逻辑层和 gRPC 服务层。电影服务是系统的核心功能模块，负责管理电影信息、分类、搜索、推荐等功能。

### 主要功能

1. **电影管理**：
   - 电影CRUD操作
   - 电影信息维护
   - 电影状态管理
   - 批量操作支持

2. **分类管理**：
   - 分类CRUD操作
   - 分类层级管理
   - 电影分类关联
   - 分类统计

3. **搜索功能**：
   - 电影搜索
   - 分类筛选
   - 排序功能
   - 分页支持

4. **统计功能**：
   - 电影统计
   - 分类统计
   - 热门电影
   - 推荐算法

## 前置条件

在开始本步骤之前，请确保已完成：

1. ✅ 项目初始化（01-项目初始化.md）
2. ✅ 数据库设计（02-数据库设计.md）
3. ✅ 配置管理系统（03-配置管理系统.md）
4. ✅ 日志系统（04-日志系统.md）
5. ✅ gRPC协议定义（05-gRPC协议定义.md）
6. ✅ 数据模型层（06-数据模型层.md）
7. ✅ 用户服务开发（07-用户服务开发.md）

## 技术要点

### 设计原则

1. **分层架构**：
   - Repository层：数据访问抽象
   - Service层：业务逻辑处理
   - Handler层：gRPC接口实现
   - 清晰的职责分离

2. **缓存策略**：
   - 热门电影缓存
   - 分类信息缓存
   - 搜索结果缓存
   - 统计数据缓存

3. **性能优化**：
   - 数据库索引优化
   - 查询优化
   - 分页处理
   - 并发控制

4. **扩展性设计**：
   - 接口抽象
   - 插件化架构
   - 微服务友好
   - 水平扩展支持

### 技术选型

1. **数据访问**：
   - GORM：ORM框架
   - MySQL：主数据库
   - Redis：缓存层

2. **搜索引擎**：
   - 全文搜索支持
   - 模糊匹配
   - 权重排序

3. **缓存策略**：
   - 多级缓存
   - 缓存预热
   - 缓存更新策略

### 架构设计

```
电影服务架构
├── gRPC Handler层
│   ├── 电影处理器
│   ├── 分类处理器
│   └── 搜索处理器
├── Service层
│   ├── 电影服务
│   ├── 分类服务
│   └── 搜索服务
├── Repository层
│   ├── 电影仓储
│   ├── 分类仓储
│   └── 关联仓储
└── 缓存层
    ├── 电影缓存
    ├── 分类缓存
    └── 搜索缓存
```

## 实现步骤

### 步骤1：实现电影仓储层

#### 1.1 创建电影仓储实现

```go
// internal/repository/movie_repository.go
package repository

import (
	"context"
	"fmt"
	"strings"
	"time"

	"gorm.io/gorm"

	"movieinfo/internal/models"
	"movieinfo/pkg/cache"
	"movieinfo/pkg/logger"
)

// movieRepository 电影仓储实现
type movieRepository struct {
	db     *gorm.DB
	cache  cache.Manager
	logger logger.Logger
}

// NewMovieRepository 创建电影仓储
func NewMovieRepository(
	db *gorm.DB,
	cache cache.Manager,
	logger logger.Logger,
) models.MovieRepository {
	return &movieRepository{
		db:     db,
		cache:  cache,
		logger: logger,
	}
}

// Create 创建电影
func (r *movieRepository) Create(ctx context.Context, movie *models.Movie) error {
	if err := r.db.WithContext(ctx).Create(movie).Error; err != nil {
		r.logger.Error("Failed to create movie", "error", err)
		return err
	}

	// 清除相关缓存
	r.invalidateMovieCache(ctx, movie.ID)
	r.invalidateMovieListCache(ctx)

	r.logger.Info("Movie created successfully", "movie_id", movie.ID, "title", movie.Title)
	return nil
}

// GetByID 根据ID获取电影
func (r *movieRepository) GetByID(ctx context.Context, id uint64) (*models.Movie, error) {
	// 尝试从缓存获取
	cacheKey := fmt.Sprintf("movie:%d", id)
	var movie models.Movie
	if r.cache.IsEnabled() {
		if err := r.cache.Get(ctx, cacheKey, &movie); err == nil {
			return &movie, nil
		}
	}

	// 从数据库获取
	if err := r.db.WithContext(ctx).
		Preload("Categories").
		First(&movie, id).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, models.ErrMovieNotFound
		}
		r.logger.Error("Failed to get movie by ID", "id", id, "error", err)
		return nil, err
	}

	// 缓存结果
	if r.cache.IsEnabled() {
		r.cache.Set(ctx, cacheKey, &movie, 30*time.Minute)
	}

	return &movie, nil
}

// GetByTitle 根据标题获取电影
func (r *movieRepository) GetByTitle(ctx context.Context, title string) (*models.Movie, error) {
	var movie models.Movie
	if err := r.db.WithContext(ctx).
		Preload("Categories").
		Where("title = ?", title).
		First(&movie).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, models.ErrMovieNotFound
		}
		r.logger.Error("Failed to get movie by title", "title", title, "error", err)
		return nil, err
	}

	return &movie, nil
}

// Update 更新电影
func (r *movieRepository) Update(ctx context.Context, movie *models.Movie) error {
	if err := r.db.WithContext(ctx).Save(movie).Error; err != nil {
		r.logger.Error("Failed to update movie", "movie_id", movie.ID, "error", err)
		return err
	}

	// 清除相关缓存
	r.invalidateMovieCache(ctx, movie.ID)
	r.invalidateMovieListCache(ctx)

	r.logger.Info("Movie updated successfully", "movie_id", movie.ID)
	return nil
}

// Delete 删除电影
func (r *movieRepository) Delete(ctx context.Context, id uint64) error {
	// 开始事务
	tx := r.db.WithContext(ctx).Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// 删除电影分类关联
	if err := tx.Where("movie_id = ?", id).Delete(&models.MovieCategory{}).Error; err != nil {
		tx.Rollback()
		r.logger.Error("Failed to delete movie categories", "movie_id", id, "error", err)
		return err
	}

	// 删除电影
	if err := tx.Delete(&models.Movie{}, id).Error; err != nil {
		tx.Rollback()
		r.logger.Error("Failed to delete movie", "movie_id", id, "error", err)
		return err
	}

	// 提交事务
	if err := tx.Commit().Error; err != nil {
		r.logger.Error("Failed to commit transaction", "error", err)
		return err
	}

	// 清除相关缓存
	r.invalidateMovieCache(ctx, id)
	r.invalidateMovieListCache(ctx)

	r.logger.Info("Movie deleted successfully", "movie_id", id)
	return nil
}

// List 获取电影列表
func (r *movieRepository) List(ctx context.Context, params *models.MovieQueryParams) ([]*models.Movie, error) {
	query := r.db.WithContext(ctx).Model(&models.Movie{})

	// 应用过滤条件
	query = r.applyMovieFilters(query, params)

	// 预加载关联数据
	query = query.Preload("Categories")

	// 应用排序
	if params.OrderBy != "" {
		orderDirection := "ASC"
		if params.OrderDesc {
			orderDirection = "DESC"
		}
		query = query.Order(fmt.Sprintf("%s %s", params.OrderBy, orderDirection))
	} else {
		query = query.Order("created_at DESC")
	}

	// 应用分页
	if params.Limit > 0 {
		query = query.Limit(params.Limit)
	}
	if params.Offset > 0 {
		query = query.Offset(params.Offset)
	}

	var movies []*models.Movie
	if err := query.Find(&movies).Error; err != nil {
		r.logger.Error("Failed to list movies", "error", err)
		return nil, err
	}

	return movies, nil
}

// Count 统计电影数量
func (r *movieRepository) Count(ctx context.Context, params *models.MovieQueryParams) (int64, error) {
	query := r.db.WithContext(ctx).Model(&models.Movie{})

	// 应用过滤条件
	query = r.applyMovieFilters(query, params)

	var count int64
	if err := query.Count(&count).Error; err != nil {
		r.logger.Error("Failed to count movies", "error", err)
		return 0, err
	}

	return count, nil
}

// ExistsByTitle 检查标题是否存在
func (r *movieRepository) ExistsByTitle(ctx context.Context, title string) (bool, error) {
	var count int64
	if err := r.db.WithContext(ctx).
		Model(&models.Movie{}).
		Where("title = ?", title).
		Count(&count).Error; err != nil {
		r.logger.Error("Failed to check movie title existence", "title", title, "error", err)
		return false, err
	}

	return count > 0, nil
}

// GetByCategory 根据分类获取电影
func (r *movieRepository) GetByCategory(ctx context.Context, categoryID uint64, params *models.MovieQueryParams) ([]*models.Movie, error) {
	query := r.db.WithContext(ctx).
		Model(&models.Movie{}).
		Joins("JOIN movie_categories ON movies.id = movie_categories.movie_id").
		Where("movie_categories.category_id = ?", categoryID)

	// 应用过滤条件
	query = r.applyMovieFilters(query, params)

	// 预加载关联数据
	query = query.Preload("Categories")

	// 应用排序
	if params.OrderBy != "" {
		orderDirection := "ASC"
		if params.OrderDesc {
			orderDirection = "DESC"
		}
		query = query.Order(fmt.Sprintf("movies.%s %s", params.OrderBy, orderDirection))
	} else {
		query = query.Order("movies.created_at DESC")
	}

	// 应用分页
	if params.Limit > 0 {
		query = query.Limit(params.Limit)
	}
	if params.Offset > 0 {
		query = query.Offset(params.Offset)
	}

	var movies []*models.Movie
	if err := query.Find(&movies).Error; err != nil {
		r.logger.Error("Failed to get movies by category", "category_id", categoryID, "error", err)
		return nil, err
	}

	return movies, nil
}

// Search 搜索电影
func (r *movieRepository) Search(ctx context.Context, keyword string, params *models.MovieQueryParams) ([]*models.Movie, error) {
	query := r.db.WithContext(ctx).Model(&models.Movie{})

	// 应用搜索条件
	if keyword != "" {
		searchPattern := "%" + keyword + "%"
		query = query.Where(
			"title LIKE ? OR description LIKE ? OR director LIKE ? OR actors LIKE ?",
			searchPattern, searchPattern, searchPattern, searchPattern,
		)
	}

	// 应用过滤条件
	query = r.applyMovieFilters(query, params)

	// 预加载关联数据
	query = query.Preload("Categories")

	// 应用排序
	if params.OrderBy != "" {
		orderDirection := "ASC"
		if params.OrderDesc {
			orderDirection = "DESC"
		}
		query = query.Order(fmt.Sprintf("%s %s", params.OrderBy, orderDirection))
	} else {
		// 搜索结果按相关性排序
		query = query.Order("rating DESC, created_at DESC")
	}

	// 应用分页
	if params.Limit > 0 {
		query = query.Limit(params.Limit)
	}
	if params.Offset > 0 {
		query = query.Offset(params.Offset)
	}

	var movies []*models.Movie
	if err := query.Find(&movies).Error; err != nil {
		r.logger.Error("Failed to search movies", "keyword", keyword, "error", err)
		return nil, err
	}

	return movies, nil
}

// GetPopular 获取热门电影
func (r *movieRepository) GetPopular(ctx context.Context, limit int) ([]*models.Movie, error) {
	// 尝试从缓存获取
	cacheKey := fmt.Sprintf("movies:popular:%d", limit)
	var movies []*models.Movie
	if r.cache.IsEnabled() {
		if err := r.cache.Get(ctx, cacheKey, &movies); err == nil {
			return movies, nil
		}
	}

	// 从数据库获取
	if err := r.db.WithContext(ctx).
		Model(&models.Movie{}).
		Preload("Categories").
		Where("status = ?", models.MovieStatusPublished).
		Order("rating DESC, view_count DESC").
		Limit(limit).
		Find(&movies).Error; err != nil {
		r.logger.Error("Failed to get popular movies", "error", err)
		return nil, err
	}

	// 缓存结果（10分钟）
	if r.cache.IsEnabled() {
		r.cache.Set(ctx, cacheKey, &movies, 10*time.Minute)
	}

	return movies, nil
}

// GetRecent 获取最新电影
func (r *movieRepository) GetRecent(ctx context.Context, limit int) ([]*models.Movie, error) {
	// 尝试从缓存获取
	cacheKey := fmt.Sprintf("movies:recent:%d", limit)
	var movies []*models.Movie
	if r.cache.IsEnabled() {
		if err := r.cache.Get(ctx, cacheKey, &movies); err == nil {
			return movies, nil
		}
	}

	// 从数据库获取
	if err := r.db.WithContext(ctx).
		Model(&models.Movie{}).
		Preload("Categories").
		Where("status = ?", models.MovieStatusPublished).
		Order("created_at DESC").
		Limit(limit).
		Find(&movies).Error; err != nil {
		r.logger.Error("Failed to get recent movies", "error", err)
		return nil, err
	}

	// 缓存结果（5分钟）
	if r.cache.IsEnabled() {
		r.cache.Set(ctx, cacheKey, &movies, 5*time.Minute)
	}

	return movies, nil
}

// UpdateStatus 更新电影状态
func (r *movieRepository) UpdateStatus(ctx context.Context, id uint64, status models.MovieStatus) error {
	if err := r.db.WithContext(ctx).
		Model(&models.Movie{}).
		Where("id = ?", id).
		Update("status", status).Error; err != nil {
		r.logger.Error("Failed to update movie status", "movie_id", id, "status", status, "error", err)
		return err
	}

	// 清除相关缓存
	r.invalidateMovieCache(ctx, id)
	r.invalidateMovieListCache(ctx)

	r.logger.Info("Movie status updated successfully", "movie_id", id, "status", status)
	return nil
}

// UpdateRating 更新电影评分
func (r *movieRepository) UpdateRating(ctx context.Context, id uint64, rating float64, ratingCount int) error {
	if err := r.db.WithContext(ctx).
		Model(&models.Movie{}).
		Where("id = ?", id).
		Updates(map[string]interface{}{
			"rating":       rating,
			"rating_count": ratingCount,
		}).Error; err != nil {
		r.logger.Error("Failed to update movie rating", "movie_id", id, "error", err)
		return err
	}

	// 清除相关缓存
	r.invalidateMovieCache(ctx, id)
	r.invalidateMovieListCache(ctx)

	r.logger.Info("Movie rating updated successfully", "movie_id", id, "rating", rating)
	return nil
}

// IncrementViewCount 增加观看次数
func (r *movieRepository) IncrementViewCount(ctx context.Context, id uint64) error {
	if err := r.db.WithContext(ctx).
		Model(&models.Movie{}).
		Where("id = ?", id).
		Update("view_count", gorm.Expr("view_count + 1")).Error; err != nil {
		r.logger.Error("Failed to increment movie view count", "movie_id", id, "error", err)
		return err
	}

	// 清除相关缓存
	r.invalidateMovieCache(ctx, id)
	r.invalidateMovieListCache(ctx)

	return nil
}

// BatchUpdate 批量更新电影
func (r *movieRepository) BatchUpdate(ctx context.Context, ids []uint64, updates map[string]interface{}) error {
	if err := r.db.WithContext(ctx).
		Model(&models.Movie{}).
		Where("id IN ?", ids).
		Updates(updates).Error; err != nil {
		r.logger.Error("Failed to batch update movies", "ids", ids, "error", err)
		return err
	}

	// 清除相关缓存
	for _, id := range ids {
		r.invalidateMovieCache(ctx, id)
	}
	r.invalidateMovieListCache(ctx)

	r.logger.Info("Movies batch updated successfully", "count", len(ids))
	return nil
}

// GetStats 获取电影统计
func (r *movieRepository) GetStats(ctx context.Context) (*models.MovieStats, error) {
	// 尝试从缓存获取
	cacheKey := "movies:stats"
	var stats models.MovieStats
	if r.cache.IsEnabled() {
		if err := r.cache.Get(ctx, cacheKey, &stats); err == nil {
			return &stats, nil
		}
	}

	// 从数据库获取统计信息
	var totalMovies, publishedMovies, draftMovies int64

	// 总电影数
	if err := r.db.WithContext(ctx).Model(&models.Movie{}).Count(&totalMovies).Error; err != nil {
		return nil, err
	}

	// 已发布电影数
	if err := r.db.WithContext(ctx).
		Model(&models.Movie{}).
		Where("status = ?", models.MovieStatusPublished).
		Count(&publishedMovies).Error; err != nil {
		return nil, err
	}

	// 草稿电影数
	if err := r.db.WithContext(ctx).
		Model(&models.Movie{}).
		Where("status = ?", models.MovieStatusDraft).
		Count(&draftMovies).Error; err != nil {
		return nil, err
	}

	// 今日新增电影数
	var newMoviesToday int64
	today := time.Now().Format("2006-01-02")
	if err := r.db.WithContext(ctx).
		Model(&models.Movie{}).
		Where("DATE(created_at) = ?", today).
		Count(&newMoviesToday).Error; err != nil {
		return nil, err
	}

	// 本月新增电影数
	var newMoviesThisMonth int64
	thisMonth := time.Now().Format("2006-01")
	if err := r.db.WithContext(ctx).
		Model(&models.Movie{}).
		Where("DATE_FORMAT(created_at, '%Y-%m') = ?", thisMonth).
		Count(&newMoviesThisMonth).Error; err != nil {
		return nil, err
	}

	stats = models.MovieStats{
		TotalMovies:        totalMovies,
		PublishedMovies:    publishedMovies,
		DraftMovies:        draftMovies,
		NewMoviesToday:     newMoviesToday,
		NewMoviesThisMonth: newMoviesThisMonth,
	}

	// 缓存结果（5分钟）
	if r.cache.IsEnabled() {
		r.cache.Set(ctx, cacheKey, &stats, 5*time.Minute)
	}

	return &stats, nil
}

// 应用电影过滤条件
func (r *movieRepository) applyMovieFilters(query *gorm.DB, params *models.MovieQueryParams) *gorm.DB {
	if params == nil {
		return query
	}

	// 状态过滤
	if params.Status != nil {
		query = query.Where("status = ?", *params.Status)
	}

	// 分类过滤
	if len(params.CategoryIDs) > 0 {
		query = query.Joins("JOIN movie_categories ON movies.id = movie_categories.movie_id").
			Where("movie_categories.category_id IN ?", params.CategoryIDs)
	}

	// 年份过滤
	if params.Year != nil {
		query = query.Where("year = ?", *params.Year)
	}

	// 评分过滤
	if params.MinRating != nil {
		query = query.Where("rating >= ?", *params.MinRating)
	}
	if params.MaxRating != nil {
		query = query.Where("rating <= ?", *params.MaxRating)
	}

	// 时长过滤
	if params.MinDuration != nil {
		query = query.Where("duration >= ?", *params.MinDuration)
	}
	if params.MaxDuration != nil {
		query = query.Where("duration <= ?", *params.MaxDuration)
	}

	// 创建时间过滤
	if params.CreatedAfter != nil {
		query = query.Where("created_at >= ?", *params.CreatedAfter)
	}
	if params.CreatedBefore != nil {
		query = query.Where("created_at <= ?", *params.CreatedBefore)
	}

	// 搜索关键词
	if params.Search != "" {
		searchPattern := "%" + params.Search + "%"
		query = query.Where(
			"title LIKE ? OR description LIKE ? OR director LIKE ? OR actors LIKE ?",
			searchPattern, searchPattern, searchPattern, searchPattern,
		)
	}

	return query
}

// 清除电影缓存
func (r *movieRepository) invalidateMovieCache(ctx context.Context, movieID uint64) {
	if !r.cache.IsEnabled() {
		return
	}

	cacheKey := fmt.Sprintf("movie:%d", movieID)
	r.cache.Delete(ctx, cacheKey)
}

// 清除电影列表缓存
func (r *movieRepository) invalidateMovieListCache(ctx context.Context) {
	if !r.cache.IsEnabled() {
		return
	}

	// 清除相关的列表缓存
	patterns := []string{
		"movies:popular:*",
		"movies:recent:*",
		"movies:stats",
	}

	for _, pattern := range patterns {
		keys, _ := r.cache.Keys(ctx, pattern)
		for _, key := range keys {
			r.cache.Delete(ctx, key)
		}
	}
}
```

#### 1.2 创建分类仓储实现

```go
// internal/repository/category_repository.go
package repository

import (
	"context"
	"fmt"
	"time"

	"gorm.io/gorm"

	"movieinfo/internal/models"
	"movieinfo/pkg/cache"
	"movieinfo/pkg/logger"
)

// categoryRepository 分类仓储实现
type categoryRepository struct {
	db     *gorm.DB
	cache  cache.Manager
	logger logger.Logger
}

// NewCategoryRepository 创建分类仓储
func NewCategoryRepository(
	db *gorm.DB,
	cache cache.Manager,
	logger logger.Logger,
) models.CategoryRepository {
	return &categoryRepository{
		db:     db,
		cache:  cache,
		logger: logger,
	}
}

// Create 创建分类
func (r *categoryRepository) Create(ctx context.Context, category *models.Category) error {
	if err := r.db.WithContext(ctx).Create(category).Error; err != nil {
		r.logger.Error("Failed to create category", "error", err)
		return err
	}

	// 清除相关缓存
	r.invalidateCategoryCache(ctx)

	r.logger.Info("Category created successfully", "category_id", category.ID, "name", category.Name)
	return nil
}

// GetByID 根据ID获取分类
func (r *categoryRepository) GetByID(ctx context.Context, id uint64) (*models.Category, error) {
	// 尝试从缓存获取
	cacheKey := fmt.Sprintf("category:%d", id)
	var category models.Category
	if r.cache.IsEnabled() {
		if err := r.cache.Get(ctx, cacheKey, &category); err == nil {
			return &category, nil
		}
	}

	// 从数据库获取
	if err := r.db.WithContext(ctx).
		Preload("Parent").
		Preload("Children").
		First(&category, id).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, models.ErrCategoryNotFound
		}
		r.logger.Error("Failed to get category by ID", "id", id, "error", err)
		return nil, err
	}

	// 缓存结果
	if r.cache.IsEnabled() {
		r.cache.Set(ctx, cacheKey, &category, 30*time.Minute)
	}

	return &category, nil
}

// GetByName 根据名称获取分类
func (r *categoryRepository) GetByName(ctx context.Context, name string) (*models.Category, error) {
	var category models.Category
	if err := r.db.WithContext(ctx).
		Preload("Parent").
		Preload("Children").
		Where("name = ?", name).
		First(&category).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, models.ErrCategoryNotFound
		}
		r.logger.Error("Failed to get category by name", "name", name, "error", err)
		return nil, err
	}

	return &category, nil
}

// Update 更新分类
func (r *categoryRepository) Update(ctx context.Context, category *models.Category) error {
	if err := r.db.WithContext(ctx).Save(category).Error; err != nil {
		r.logger.Error("Failed to update category", "category_id", category.ID, "error", err)
		return err
	}

	// 清除相关缓存
	r.invalidateCategoryCache(ctx)

	r.logger.Info("Category updated successfully", "category_id", category.ID)
	return nil
}

// Delete 删除分类
func (r *categoryRepository) Delete(ctx context.Context, id uint64) error {
	// 检查是否有子分类
	var childCount int64
	if err := r.db.WithContext(ctx).
		Model(&models.Category{}).
		Where("parent_id = ?", id).
		Count(&childCount).Error; err != nil {
		r.logger.Error("Failed to check child categories", "category_id", id, "error", err)
		return err
	}

	if childCount > 0 {
		return models.ErrCategoryHasChildren
	}

	// 检查是否有关联的电影
	var movieCount int64
	if err := r.db.WithContext(ctx).
		Model(&models.MovieCategory{}).
		Where("category_id = ?", id).
		Count(&movieCount).Error; err != nil {
		r.logger.Error("Failed to check category movies", "category_id", id, "error", err)
		return err
	}

	if movieCount > 0 {
		return models.ErrCategoryHasMovies
	}

	// 删除分类
	if err := r.db.WithContext(ctx).Delete(&models.Category{}, id).Error; err != nil {
		r.logger.Error("Failed to delete category", "category_id", id, "error", err)
		return err
	}

	// 清除相关缓存
	r.invalidateCategoryCache(ctx)

	r.logger.Info("Category deleted successfully", "category_id", id)
	return nil
}

// List 获取分类列表
func (r *categoryRepository) List(ctx context.Context, params *models.CategoryQueryParams) ([]*models.Category, error) {
	query := r.db.WithContext(ctx).Model(&models.Category{})

	// 应用过滤条件
	query = r.applyCategoryFilters(query, params)

	// 预加载关联数据
	query = query.Preload("Parent").Preload("Children")

	// 应用排序
	if params != nil && params.OrderBy != "" {
		orderDirection := "ASC"
		if params.OrderDesc {
			orderDirection = "DESC"
		}
		query = query.Order(fmt.Sprintf("%s %s", params.OrderBy, orderDirection))
	} else {
		query = query.Order("sort_order ASC, created_at ASC")
	}

	// 应用分页
	if params != nil {
		if params.Limit > 0 {
			query = query.Limit(params.Limit)
		}
		if params.Offset > 0 {
			query = query.Offset(params.Offset)
		}
	}

	var categories []*models.Category
	if err := query.Find(&categories).Error; err != nil {
		r.logger.Error("Failed to list categories", "error", err)
		return nil, err
	}

	return categories, nil
}

// Count 统计分类数量
func (r *categoryRepository) Count(ctx context.Context, params *models.CategoryQueryParams) (int64, error) {
	query := r.db.WithContext(ctx).Model(&models.Category{})

	// 应用过滤条件
	query = r.applyCategoryFilters(query, params)

	var count int64
	if err := query.Count(&count).Error; err != nil {
		r.logger.Error("Failed to count categories", "error", err)
		return 0, err
	}

	return count, nil
}

// ExistsByName 检查名称是否存在
func (r *categoryRepository) ExistsByName(ctx context.Context, name string) (bool, error) {
	var count int64
	if err := r.db.WithContext(ctx).
		Model(&models.Category{}).
		Where("name = ?", name).
		Count(&count).Error; err != nil {
		r.logger.Error("Failed to check category name existence", "name", name, "error", err)
		return false, err
	}

	return count > 0, nil
}

// GetRootCategories 获取根分类
func (r *categoryRepository) GetRootCategories(ctx context.Context) ([]*models.Category, error) {
	// 尝试从缓存获取
	cacheKey := "categories:root"
	var categories []*models.Category
	if r.cache.IsEnabled() {
		if err := r.cache.Get(ctx, cacheKey, &categories); err == nil {
			return categories, nil
		}
	}

	// 从数据库获取
	if err := r.db.WithContext(ctx).
		Model(&models.Category{}).
		Preload("Children").
		Where("parent_id IS NULL").
		Order("sort_order ASC, created_at ASC").
		Find(&categories).Error; err != nil {
		r.logger.Error("Failed to get root categories", "error", err)
		return nil, err
	}

	// 缓存结果（30分钟）
	if r.cache.IsEnabled() {
		r.cache.Set(ctx, cacheKey, &categories, 30*time.Minute)
	}

	return categories, nil
}

// GetChildren 获取子分类
func (r *categoryRepository) GetChildren(ctx context.Context, parentID uint64) ([]*models.Category, error) {
	// 尝试从缓存获取
	cacheKey := fmt.Sprintf("categories:children:%d", parentID)
	var categories []*models.Category
	if r.cache.IsEnabled() {
		if err := r.cache.Get(ctx, cacheKey, &categories); err == nil {
			return categories, nil
		}
	}

	// 从数据库获取
	if err := r.db.WithContext(ctx).
		Model(&models.Category{}).
		Preload("Children").
		Where("parent_id = ?", parentID).
		Order("sort_order ASC, created_at ASC").
		Find(&categories).Error; err != nil {
		r.logger.Error("Failed to get child categories", "parent_id", parentID, "error", err)
		return nil, err
	}

	// 缓存结果（30分钟）
	if r.cache.IsEnabled() {
		r.cache.Set(ctx, cacheKey, &categories, 30*time.Minute)
	}

	return categories, nil
}

// GetTree 获取分类树
func (r *categoryRepository) GetTree(ctx context.Context) ([]*models.Category, error) {
	// 尝试从缓存获取
	cacheKey := "categories:tree"
	var categories []*models.Category
	if r.cache.IsEnabled() {
		if err := r.cache.Get(ctx, cacheKey, &categories); err == nil {
			return categories, nil
		}
	}

	// 获取所有分类
	var allCategories []*models.Category
	if err := r.db.WithContext(ctx).
		Model(&models.Category{}).
		Order("sort_order ASC, created_at ASC").
		Find(&allCategories).Error; err != nil {
		r.logger.Error("Failed to get all categories", "error", err)
		return nil, err
	}

	// 构建分类树
	categories = r.buildCategoryTree(allCategories, nil)

	// 缓存结果（30分钟）
	if r.cache.IsEnabled() {
		r.cache.Set(ctx, cacheKey, &categories, 30*time.Minute)
	}

	return categories, nil
}

// UpdateSortOrder 更新排序
func (r *categoryRepository) UpdateSortOrder(ctx context.Context, id uint64, sortOrder int) error {
	if err := r.db.WithContext(ctx).
		Model(&models.Category{}).
		Where("id = ?", id).
		Update("sort_order", sortOrder).Error; err != nil {
		r.logger.Error("Failed to update category sort order", "category_id", id, "error", err)
		return err
	}

	// 清除相关缓存
	r.invalidateCategoryCache(ctx)

	r.logger.Info("Category sort order updated successfully", "category_id", id, "sort_order", sortOrder)
	return nil
}

// GetStats 获取分类统计
func (r *categoryRepository) GetStats(ctx context.Context) (*models.CategoryStats, error) {
	// 尝试从缓存获取
	cacheKey := "categories:stats"
	var stats models.CategoryStats
	if r.cache.IsEnabled() {
		if err := r.cache.Get(ctx, cacheKey, &stats); err == nil {
			return &stats, nil
		}
	}

	// 从数据库获取统计信息
	var totalCategories, rootCategories int64

	// 总分类数
	if err := r.db.WithContext(ctx).Model(&models.Category{}).Count(&totalCategories).Error; err != nil {
		return nil, err
	}

	// 根分类数
	if err := r.db.WithContext(ctx).
		Model(&models.Category{}).
		Where("parent_id IS NULL").
		Count(&rootCategories).Error; err != nil {
		return nil, err
	}

	stats = models.CategoryStats{
		TotalCategories: totalCategories,
		RootCategories:  rootCategories,
	}

	// 缓存结果（10分钟）
	if r.cache.IsEnabled() {
		r.cache.Set(ctx, cacheKey, &stats, 10*time.Minute)
	}

	return &stats, nil
}

// 应用分类过滤条件
func (r *categoryRepository) applyCategoryFilters(query *gorm.DB, params *models.CategoryQueryParams) *gorm.DB {
	if params == nil {
		return query
	}

	// 父分类过滤
	if params.ParentID != nil {
		if *params.ParentID == 0 {
			// 获取根分类
			query = query.Where("parent_id IS NULL")
		} else {
			query = query.Where("parent_id = ?", *params.ParentID)
		}
	}

	// 搜索关键词
	if params.Search != "" {
		searchPattern := "%" + params.Search + "%"
		query = query.Where("name LIKE ? OR description LIKE ?", searchPattern, searchPattern)
	}

	return query
}

// 构建分类树
func (r *categoryRepository) buildCategoryTree(categories []*models.Category, parentID *uint64) []*models.Category {
	var result []*models.Category

	for _, category := range categories {
		if (parentID == nil && category.ParentID == nil) ||
			(parentID != nil && category.ParentID != nil && *category.ParentID == *parentID) {
			// 递归构建子分类
			category.Children = r.buildCategoryTree(categories, &category.ID)
			result = append(result, category)
		}
	}

	return result
}

// 清除分类缓存
func (r *categoryRepository) invalidateCategoryCache(ctx context.Context) {
	if !r.cache.IsEnabled() {
		return
	}

	// 清除相关的缓存
	patterns := []string{
		"category:*",
		"categories:*",
	}

	for _, pattern := range patterns {
		keys, _ := r.cache.Keys(ctx, pattern)
		for _, key := range keys {
			r.cache.Delete(ctx, key)
		}
	}
}
```

### 步骤2：实现电影业务逻辑层

#### 2.1 创建电影服务

```go
// internal/service/movie_service.go
package service

import (
	"context"
	"fmt"
	"time"

	"movieinfo/internal/models"
	"movieinfo/pkg/cache"
	"movieinfo/pkg/logger"
)

// MovieService 电影服务接口
type MovieService interface {
	// 电影管理
	CreateMovie(ctx context.Context, req *CreateMovieRequest) (*MovieResponse, error)
	GetMovie(ctx context.Context, id uint64) (*MovieResponse, error)
	UpdateMovie(ctx context.Context, id uint64, req *UpdateMovieRequest) (*MovieResponse, error)
	DeleteMovie(ctx context.Context, id uint64) error

	// 电影列表
	GetMovieList(ctx context.Context, req *GetMovieListRequest) (*MovieListResponse, error)
	SearchMovies(ctx context.Context, req *SearchMoviesRequest) (*MovieListResponse, error)
	GetMoviesByCategory(ctx context.Context, req *GetMoviesByCategoryRequest) (*MovieListResponse, error)

	// 热门和推荐
	GetPopularMovies(ctx context.Context, limit int) (*MovieListResponse, error)
	GetRecentMovies(ctx context.Context, limit int) (*MovieListResponse, error)
	GetRecommendedMovies(ctx context.Context, userID uint64, limit int) (*MovieListResponse, error)

	// 电影操作
	IncrementViewCount(ctx context.Context, id uint64) error
	UpdateMovieStatus(ctx context.Context, id uint64, status models.MovieStatus) error
	BatchUpdateMovies(ctx context.Context, req *BatchUpdateMoviesRequest) error

	// 统计
	GetMovieStats(ctx context.Context) (*MovieStatsResponse, error)
}

// 请求和响应结构体
type CreateMovieRequest struct {
	Title       string    `json:"title" validate:"required,min=1,max=200"`
	Description string    `json:"description" validate:"max=2000"`
	Director    string    `json:"director" validate:"required,max=100"`
	Actors      string    `json:"actors" validate:"max=500"`
	Year        int       `json:"year" validate:"required,min=1900,max=2100"`
	Duration    int       `json:"duration" validate:"required,min=1"`
	PosterURL   string    `json:"poster_url" validate:"url"`
	TrailerURL  string    `json:"trailer_url" validate:"url"`
	ReleaseDate time.Time `json:"release_date"`
	CategoryIDs []uint64  `json:"category_ids" validate:"required,min=1"`
	Status      models.MovieStatus `json:"status"`
}

type UpdateMovieRequest struct {
	Title       *string    `json:"title,omitempty" validate:"omitempty,min=1,max=200"`
	Description *string    `json:"description,omitempty" validate:"omitempty,max=2000"`
	Director    *string    `json:"director,omitempty" validate:"omitempty,max=100"`
	Actors      *string    `json:"actors,omitempty" validate:"omitempty,max=500"`
	Year        *int       `json:"year,omitempty" validate:"omitempty,min=1900,max=2100"`
	Duration    *int       `json:"duration,omitempty" validate:"omitempty,min=1"`
	PosterURL   *string    `json:"poster_url,omitempty" validate:"omitempty,url"`
	TrailerURL  *string    `json:"trailer_url,omitempty" validate:"omitempty,url"`
	ReleaseDate *time.Time `json:"release_date,omitempty"`
	CategoryIDs []uint64   `json:"category_ids,omitempty"`
	Status      *models.MovieStatus `json:"status,omitempty"`
}

type GetMovieListRequest struct {
	Page        int                 `json:"page" validate:"min=1"`
	PageSize    int                 `json:"page_size" validate:"min=1,max=100"`
	Status      *models.MovieStatus `json:"status,omitempty"`
	CategoryIDs []uint64            `json:"category_ids,omitempty"`
	Year        *int                `json:"year,omitempty"`
	MinRating   *float64            `json:"min_rating,omitempty" validate:"omitempty,min=0,max=10"`
	MaxRating   *float64            `json:"max_rating,omitempty" validate:"omitempty,min=0,max=10"`
	OrderBy     string              `json:"order_by,omitempty"`
	OrderDesc   bool                `json:"order_desc,omitempty"`
}

type SearchMoviesRequest struct {
	Keyword  string `json:"keyword" validate:"required,min=1"`
	Page     int    `json:"page" validate:"min=1"`
	PageSize int    `json:"page_size" validate:"min=1,max=100"`
	OrderBy  string `json:"order_by,omitempty"`
	OrderDesc bool  `json:"order_desc,omitempty"`
}

type GetMoviesByCategoryRequest struct {
	CategoryID uint64 `json:"category_id" validate:"required"`
	Page       int    `json:"page" validate:"min=1"`
	PageSize   int    `json:"page_size" validate:"min=1,max=100"`
	OrderBy    string `json:"order_by,omitempty"`
	OrderDesc  bool   `json:"order_desc,omitempty"`
}

type BatchUpdateMoviesRequest struct {
	MovieIDs []uint64               `json:"movie_ids" validate:"required,min=1"`
	Updates  map[string]interface{} `json:"updates" validate:"required"`
}

type MovieResponse struct {
	ID          uint64                `json:"id"`
	Title       string                `json:"title"`
	Description string                `json:"description"`
	Director    string                `json:"director"`
	Actors      string                `json:"actors"`
	Year        int                   `json:"year"`
	Duration    int                   `json:"duration"`
	PosterURL   string                `json:"poster_url"`
	TrailerURL  string                `json:"trailer_url"`
	Rating      float64               `json:"rating"`
	RatingCount int                   `json:"rating_count"`
	ViewCount   int64                 `json:"view_count"`
	Status      models.MovieStatus    `json:"status"`
	ReleaseDate time.Time             `json:"release_date"`
	Categories  []*CategoryResponse   `json:"categories"`
	CreatedAt   time.Time             `json:"created_at"`
	UpdatedAt   time.Time             `json:"updated_at"`
}

type MovieListResponse struct {
	Movies     []*MovieResponse `json:"movies"`
	Total      int64            `json:"total"`
	Page       int              `json:"page"`
	PageSize   int              `json:"page_size"`
	TotalPages int              `json:"total_pages"`
}

type MovieStatsResponse struct {
	TotalMovies        int64 `json:"total_movies"`
	PublishedMovies    int64 `json:"published_movies"`
	DraftMovies        int64 `json:"draft_movies"`
	NewMoviesToday     int64 `json:"new_movies_today"`
	NewMoviesThisMonth int64 `json:"new_movies_this_month"`
}

// movieService 电影服务实现
type movieService struct {
	movieRepo    models.MovieRepository
	categoryRepo models.CategoryRepository
	cache        cache.Manager
	logger       logger.Logger
}

// NewMovieService 创建电影服务
func NewMovieService(
	movieRepo models.MovieRepository,
	categoryRepo models.CategoryRepository,
	cache cache.Manager,
	logger logger.Logger,
) MovieService {
	return &movieService{
		movieRepo:    movieRepo,
		categoryRepo: categoryRepo,
		cache:        cache,
		logger:       logger,
	}
}

// CreateMovie 创建电影
func (s *movieService) CreateMovie(ctx context.Context, req *CreateMovieRequest) (*MovieResponse, error) {
	// 验证分类是否存在
	for _, categoryID := range req.CategoryIDs {
		if _, err := s.categoryRepo.GetByID(ctx, categoryID); err != nil {
			s.logger.Error("Category not found", "category_id", categoryID, "error", err)
			return nil, fmt.Errorf("category %d not found", categoryID)
		}
	}

	// 检查电影标题是否已存在
	if exists, err := s.movieRepo.ExistsByTitle(ctx, req.Title); err != nil {
		return nil, err
	} else if exists {
		return nil, models.ErrMovieTitleExists
	}

	// 创建电影模型
	movie := &models.Movie{
		Title:       req.Title,
		Description: req.Description,
		Director:    req.Director,
		Actors:      req.Actors,
		Year:        req.Year,
		Duration:    req.Duration,
		PosterURL:   req.PosterURL,
		TrailerURL:  req.TrailerURL,
		ReleaseDate: req.ReleaseDate,
		Status:      req.Status,
		Rating:      0.0,
		RatingCount: 0,
		ViewCount:   0,
	}

	// 创建电影
	if err := s.movieRepo.Create(ctx, movie); err != nil {
		s.logger.Error("Failed to create movie", "error", err)
		return nil, err
	}

	// 关联分类
	for _, categoryID := range req.CategoryIDs {
		movieCategory := &models.MovieCategory{
			MovieID:    movie.ID,
			CategoryID: categoryID,
		}
		// 这里需要MovieCategory的仓储方法，暂时省略具体实现
	}

	// 获取完整的电影信息（包含分类）
	movieWithCategories, err := s.movieRepo.GetByID(ctx, movie.ID)
	if err != nil {
		return nil, err
	}

	s.logger.Info("Movie created successfully", "movie_id", movie.ID, "title", movie.Title)
	return s.convertToMovieResponse(movieWithCategories), nil
}

// GetMovie 获取电影
func (s *movieService) GetMovie(ctx context.Context, id uint64) (*MovieResponse, error) {
	movie, err := s.movieRepo.GetByID(ctx, id)
	if err != nil {
		s.logger.Error("Failed to get movie", "movie_id", id, "error", err)
		return nil, err
	}

	return s.convertToMovieResponse(movie), nil
}

// UpdateMovie 更新电影
func (s *movieService) UpdateMovie(ctx context.Context, id uint64, req *UpdateMovieRequest) (*MovieResponse, error) {
	// 获取现有电影
	movie, err := s.movieRepo.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	// 更新字段
	if req.Title != nil {
		// 检查新标题是否已存在（排除当前电影）
		if existingMovie, err := s.movieRepo.GetByTitle(ctx, *req.Title); err == nil && existingMovie.ID != id {
			return nil, models.ErrMovieTitleExists
		}
		movie.Title = *req.Title
	}
	if req.Description != nil {
		movie.Description = *req.Description
	}
	if req.Director != nil {
		movie.Director = *req.Director
	}
	if req.Actors != nil {
		movie.Actors = *req.Actors
	}
	if req.Year != nil {
		movie.Year = *req.Year
	}
	if req.Duration != nil {
		movie.Duration = *req.Duration
	}
	if req.PosterURL != nil {
		movie.PosterURL = *req.PosterURL
	}
	if req.TrailerURL != nil {
		movie.TrailerURL = *req.TrailerURL
	}
	if req.ReleaseDate != nil {
		movie.ReleaseDate = *req.ReleaseDate
	}
	if req.Status != nil {
		movie.Status = *req.Status
	}

	// 更新电影
	if err := s.movieRepo.Update(ctx, movie); err != nil {
		s.logger.Error("Failed to update movie", "movie_id", id, "error", err)
		return nil, err
	}

	// 更新分类关联（如果提供了新的分类）
	if len(req.CategoryIDs) > 0 {
		// 验证分类是否存在
		for _, categoryID := range req.CategoryIDs {
			if _, err := s.categoryRepo.GetByID(ctx, categoryID); err != nil {
				return nil, fmt.Errorf("category %d not found", categoryID)
			}
		}
		// 这里需要更新MovieCategory关联，暂时省略具体实现
	}

	// 获取更新后的电影信息
	updatedMovie, err := s.movieRepo.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	s.logger.Info("Movie updated successfully", "movie_id", id)
	return s.convertToMovieResponse(updatedMovie), nil
}

// DeleteMovie 删除电影
func (s *movieService) DeleteMovie(ctx context.Context, id uint64) error {
	// 检查电影是否存在
	if _, err := s.movieRepo.GetByID(ctx, id); err != nil {
		return err
	}

	// 删除电影
	if err := s.movieRepo.Delete(ctx, id); err != nil {
		s.logger.Error("Failed to delete movie", "movie_id", id, "error", err)
		return err
	}

	s.logger.Info("Movie deleted successfully", "movie_id", id)
	return nil
}

// GetMovieList 获取电影列表
func (s *movieService) GetMovieList(ctx context.Context, req *GetMovieListRequest) (*MovieListResponse, error) {
	// 构建查询参数
	params := &models.MovieQueryParams{
		Status:      req.Status,
		CategoryIDs: req.CategoryIDs,
		Year:        req.Year,
		MinRating:   req.MinRating,
		MaxRating:   req.MaxRating,
		OrderBy:     req.OrderBy,
		OrderDesc:   req.OrderDesc,
		Limit:       req.PageSize,
		Offset:      (req.Page - 1) * req.PageSize,
	}

	// 获取电影列表
	movies, err := s.movieRepo.List(ctx, params)
	if err != nil {
		s.logger.Error("Failed to get movie list", "error", err)
		return nil, err
	}

	// 获取总数
	total, err := s.movieRepo.Count(ctx, params)
	if err != nil {
		s.logger.Error("Failed to count movies", "error", err)
		return nil, err
	}

	// 转换响应
	movieResponses := make([]*MovieResponse, len(movies))
	for i, movie := range movies {
		movieResponses[i] = s.convertToMovieResponse(movie)
	}

	totalPages := int((total + int64(req.PageSize) - 1) / int64(req.PageSize))

	return &MovieListResponse{
		Movies:     movieResponses,
		Total:      total,
		Page:       req.Page,
		PageSize:   req.PageSize,
		TotalPages: totalPages,
	}, nil
}

// SearchMovies 搜索电影
func (s *movieService) SearchMovies(ctx context.Context, req *SearchMoviesRequest) (*MovieListResponse, error) {
	// 构建查询参数
	params := &models.MovieQueryParams{
		OrderBy:   req.OrderBy,
		OrderDesc: req.OrderDesc,
		Limit:     req.PageSize,
		Offset:    (req.Page - 1) * req.PageSize,
	}

	// 搜索电影
	movies, err := s.movieRepo.Search(ctx, req.Keyword, params)
	if err != nil {
		s.logger.Error("Failed to search movies", "keyword", req.Keyword, "error", err)
		return nil, err
	}

	// 获取搜索结果总数（需要重新搜索计数）
	params.Limit = 0
	params.Offset = 0
	allResults, err := s.movieRepo.Search(ctx, req.Keyword, params)
	if err != nil {
		return nil, err
	}
	total := int64(len(allResults))

	// 转换响应
	movieResponses := make([]*MovieResponse, len(movies))
	for i, movie := range movies {
		movieResponses[i] = s.convertToMovieResponse(movie)
	}

	totalPages := int((total + int64(req.PageSize) - 1) / int64(req.PageSize))

	return &MovieListResponse{
		Movies:     movieResponses,
		Total:      total,
		Page:       req.Page,
		PageSize:   req.PageSize,
		TotalPages: totalPages,
	}, nil
}

// GetMoviesByCategory 根据分类获取电影
func (s *movieService) GetMoviesByCategory(ctx context.Context, req *GetMoviesByCategoryRequest) (*MovieListResponse, error) {
	// 验证分类是否存在
	if _, err := s.categoryRepo.GetByID(ctx, req.CategoryID); err != nil {
		return nil, err
	}

	// 构建查询参数
	params := &models.MovieQueryParams{
		OrderBy:   req.OrderBy,
		OrderDesc: req.OrderDesc,
		Limit:     req.PageSize,
		Offset:    (req.Page - 1) * req.PageSize,
	}

	// 获取分类下的电影
	movies, err := s.movieRepo.GetByCategory(ctx, req.CategoryID, params)
	if err != nil {
		s.logger.Error("Failed to get movies by category", "category_id", req.CategoryID, "error", err)
		return nil, err
	}

	// 获取总数（需要重新查询计数）
	params.Limit = 0
	params.Offset = 0
	allResults, err := s.movieRepo.GetByCategory(ctx, req.CategoryID, params)
	if err != nil {
		return nil, err
	}
	total := int64(len(allResults))

	// 转换响应
	movieResponses := make([]*MovieResponse, len(movies))
	for i, movie := range movies {
		movieResponses[i] = s.convertToMovieResponse(movie)
	}

	totalPages := int((total + int64(req.PageSize) - 1) / int64(req.PageSize))

	return &MovieListResponse{
		Movies:     movieResponses,
		Total:      total,
		Page:       req.Page,
		PageSize:   req.PageSize,
		TotalPages: totalPages,
	}, nil
}

// GetPopularMovies 获取热门电影
func (s *movieService) GetPopularMovies(ctx context.Context, limit int) (*MovieListResponse, error) {
	movies, err := s.movieRepo.GetPopular(ctx, limit)
	if err != nil {
		s.logger.Error("Failed to get popular movies", "error", err)
		return nil, err
	}

	// 转换响应
	movieResponses := make([]*MovieResponse, len(movies))
	for i, movie := range movies {
		movieResponses[i] = s.convertToMovieResponse(movie)
	}

	return &MovieListResponse{
		Movies:     movieResponses,
		Total:      int64(len(movies)),
		Page:       1,
		PageSize:   limit,
		TotalPages: 1,
	}, nil
}

// GetRecentMovies 获取最新电影
func (s *movieService) GetRecentMovies(ctx context.Context, limit int) (*MovieListResponse, error) {
	movies, err := s.movieRepo.GetRecent(ctx, limit)
	if err != nil {
		s.logger.Error("Failed to get recent movies", "error", err)
		return nil, err
	}

	// 转换响应
	movieResponses := make([]*MovieResponse, len(movies))
	for i, movie := range movies {
		movieResponses[i] = s.convertToMovieResponse(movie)
	}

	return &MovieListResponse{
		Movies:     movieResponses,
		Total:      int64(len(movies)),
		Page:       1,
		PageSize:   limit,
		TotalPages: 1,
	}, nil
}

// GetRecommendedMovies 获取推荐电影
func (s *movieService) GetRecommendedMovies(ctx context.Context, userID uint64, limit int) (*MovieListResponse, error) {
	// 这里可以实现复杂的推荐算法
	// 暂时返回热门电影作为推荐
	return s.GetPopularMovies(ctx, limit)
}

// IncrementViewCount 增加观看次数
func (s *movieService) IncrementViewCount(ctx context.Context, id uint64) error {
	if err := s.movieRepo.IncrementViewCount(ctx, id); err != nil {
		s.logger.Error("Failed to increment view count", "movie_id", id, "error", err)
		return err
	}

	return nil
}

// UpdateMovieStatus 更新电影状态
func (s *movieService) UpdateMovieStatus(ctx context.Context, id uint64, status models.MovieStatus) error {
	// 检查电影是否存在
	if _, err := s.movieRepo.GetByID(ctx, id); err != nil {
		return err
	}

	if err := s.movieRepo.UpdateStatus(ctx, id, status); err != nil {
		s.logger.Error("Failed to update movie status", "movie_id", id, "status", status, "error", err)
		return err
	}

	s.logger.Info("Movie status updated successfully", "movie_id", id, "status", status)
	return nil
}

// BatchUpdateMovies 批量更新电影
func (s *movieService) BatchUpdateMovies(ctx context.Context, req *BatchUpdateMoviesRequest) error {
	// 验证所有电影是否存在
	for _, movieID := range req.MovieIDs {
		if _, err := s.movieRepo.GetByID(ctx, movieID); err != nil {
			return fmt.Errorf("movie %d not found", movieID)
		}
	}

	if err := s.movieRepo.BatchUpdate(ctx, req.MovieIDs, req.Updates); err != nil {
		s.logger.Error("Failed to batch update movies", "movie_ids", req.MovieIDs, "error", err)
		return err
	}

	s.logger.Info("Movies batch updated successfully", "count", len(req.MovieIDs))
	return nil
}

// GetMovieStats 获取电影统计
func (s *movieService) GetMovieStats(ctx context.Context) (*MovieStatsResponse, error) {
	stats, err := s.movieRepo.GetStats(ctx)
	if err != nil {
		s.logger.Error("Failed to get movie stats", "error", err)
		return nil, err
	}

	return &MovieStatsResponse{
		TotalMovies:        stats.TotalMovies,
		PublishedMovies:    stats.PublishedMovies,
		DraftMovies:        stats.DraftMovies,
		NewMoviesToday:     stats.NewMoviesToday,
		NewMoviesThisMonth: stats.NewMoviesThisMonth,
	}, nil
}

// convertToMovieResponse 转换为电影响应
func (s *movieService) convertToMovieResponse(movie *models.Movie) *MovieResponse {
	categories := make([]*CategoryResponse, len(movie.Categories))
	for i, category := range movie.Categories {
		categories[i] = &CategoryResponse{
			ID:          category.ID,
			Name:        category.Name,
			Description: category.Description,
			ParentID:    category.ParentID,
			SortOrder:   category.SortOrder,
			CreatedAt:   category.CreatedAt,
			UpdatedAt:   category.UpdatedAt,
		}
	}

	return &MovieResponse{
		ID:          movie.ID,
		Title:       movie.Title,
		Description: movie.Description,
		Director:    movie.Director,
		Actors:      movie.Actors,
		Year:        movie.Year,
		Duration:    movie.Duration,
		PosterURL:   movie.PosterURL,
		TrailerURL:  movie.TrailerURL,
		Rating:      movie.Rating,
		RatingCount: movie.RatingCount,
		ViewCount:   movie.ViewCount,
		Status:      movie.Status,
		ReleaseDate: movie.ReleaseDate,
		Categories:  categories,
		CreatedAt:   movie.CreatedAt,
		UpdatedAt:   movie.UpdatedAt,
	}
}
```

#### 2.2 创建分类服务

```go
// internal/service/category_service.go
package service

import (
	"context"
	"fmt"

	"movieinfo/internal/models"
	"movieinfo/pkg/cache"
	"movieinfo/pkg/logger"
)

// CategoryService 分类服务接口
type CategoryService interface {
	// 分类管理
	CreateCategory(ctx context.Context, req *CreateCategoryRequest) (*CategoryResponse, error)
	GetCategory(ctx context.Context, id uint64) (*CategoryResponse, error)
	UpdateCategory(ctx context.Context, id uint64, req *UpdateCategoryRequest) (*CategoryResponse, error)
	DeleteCategory(ctx context.Context, id uint64) error

	// 分类列表
	GetCategoryList(ctx context.Context, req *GetCategoryListRequest) (*CategoryListResponse, error)
	GetCategoryTree(ctx context.Context) (*CategoryTreeResponse, error)
	GetRootCategories(ctx context.Context) (*CategoryListResponse, error)
	GetChildCategories(ctx context.Context, parentID uint64) (*CategoryListResponse, error)

	// 分类操作
	UpdateSortOrder(ctx context.Context, id uint64, sortOrder int) error

	// 统计
	GetCategoryStats(ctx context.Context) (*CategoryStatsResponse, error)
}

// 请求和响应结构体
type CreateCategoryRequest struct {
	Name        string  `json:"name" validate:"required,min=1,max=50"`
	Description string  `json:"description" validate:"max=200"`
	ParentID    *uint64 `json:"parent_id,omitempty"`
	SortOrder   int     `json:"sort_order"`
}

type UpdateCategoryRequest struct {
	Name        *string `json:"name,omitempty" validate:"omitempty,min=1,max=50"`
	Description *string `json:"description,omitempty" validate:"omitempty,max=200"`
	ParentID    *uint64 `json:"parent_id,omitempty"`
	SortOrder   *int    `json:"sort_order,omitempty"`
}

type GetCategoryListRequest struct {
	Page      int     `json:"page" validate:"min=1"`
	PageSize  int     `json:"page_size" validate:"min=1,max=100"`
	ParentID  *uint64 `json:"parent_id,omitempty"`
	Search    string  `json:"search,omitempty"`
	OrderBy   string  `json:"order_by,omitempty"`
	OrderDesc bool    `json:"order_desc,omitempty"`
}

type CategoryResponse struct {
	ID          uint64              `json:"id"`
	Name        string              `json:"name"`
	Description string              `json:"description"`
	ParentID    *uint64             `json:"parent_id"`
	SortOrder   int                 `json:"sort_order"`
	Children    []*CategoryResponse `json:"children,omitempty"`
	CreatedAt   time.Time           `json:"created_at"`
	UpdatedAt   time.Time           `json:"updated_at"`
}

type CategoryListResponse struct {
	Categories []*CategoryResponse `json:"categories"`
	Total      int64               `json:"total"`
	Page       int                 `json:"page"`
	PageSize   int                 `json:"page_size"`
	TotalPages int                 `json:"total_pages"`
}

type CategoryTreeResponse struct {
	Categories []*CategoryResponse `json:"categories"`
}

type CategoryStatsResponse struct {
	TotalCategories int64 `json:"total_categories"`
	RootCategories  int64 `json:"root_categories"`
}

// categoryService 分类服务实现
type categoryService struct {
	categoryRepo models.CategoryRepository
	cache        cache.Manager
	logger       logger.Logger
}

// NewCategoryService 创建分类服务
func NewCategoryService(
	categoryRepo models.CategoryRepository,
	cache cache.Manager,
	logger logger.Logger,
) CategoryService {
	return &categoryService{
		categoryRepo: categoryRepo,
		cache:        cache,
		logger:       logger,
	}
}

// CreateCategory 创建分类
func (s *categoryService) CreateCategory(ctx context.Context, req *CreateCategoryRequest) (*CategoryResponse, error) {
	// 验证父分类是否存在
	if req.ParentID != nil {
		if _, err := s.categoryRepo.GetByID(ctx, *req.ParentID); err != nil {
			s.logger.Error("Parent category not found", "parent_id", *req.ParentID, "error", err)
			return nil, fmt.Errorf("parent category %d not found", *req.ParentID)
		}
	}

	// 检查分类名称是否已存在
	if exists, err := s.categoryRepo.ExistsByName(ctx, req.Name); err != nil {
		return nil, err
	} else if exists {
		return nil, models.ErrCategoryNameExists
	}

	// 创建分类模型
	category := &models.Category{
		Name:        req.Name,
		Description: req.Description,
		ParentID:    req.ParentID,
		SortOrder:   req.SortOrder,
	}

	// 创建分类
	if err := s.categoryRepo.Create(ctx, category); err != nil {
		s.logger.Error("Failed to create category", "error", err)
		return nil, err
	}

	// 获取完整的分类信息
	categoryWithRelations, err := s.categoryRepo.GetByID(ctx, category.ID)
	if err != nil {
		return nil, err
	}

	s.logger.Info("Category created successfully", "category_id", category.ID, "name", category.Name)
	return s.convertToCategoryResponse(categoryWithRelations), nil
}

// GetCategory 获取分类
func (s *categoryService) GetCategory(ctx context.Context, id uint64) (*CategoryResponse, error) {
	category, err := s.categoryRepo.GetByID(ctx, id)
	if err != nil {
		s.logger.Error("Failed to get category", "category_id", id, "error", err)
		return nil, err
	}

	return s.convertToCategoryResponse(category), nil
}

// UpdateCategory 更新分类
func (s *categoryService) UpdateCategory(ctx context.Context, id uint64, req *UpdateCategoryRequest) (*CategoryResponse, error) {
	// 获取现有分类
	category, err := s.categoryRepo.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	// 更新字段
	if req.Name != nil {
		// 检查新名称是否已存在（排除当前分类）
		if existingCategory, err := s.categoryRepo.GetByName(ctx, *req.Name); err == nil && existingCategory.ID != id {
			return nil, models.ErrCategoryNameExists
		}
		category.Name = *req.Name
	}
	if req.Description != nil {
		category.Description = *req.Description
	}
	if req.ParentID != nil {
		// 验证父分类是否存在
		if _, err := s.categoryRepo.GetByID(ctx, *req.ParentID); err != nil {
			return nil, fmt.Errorf("parent category %d not found", *req.ParentID)
		}
		// 检查是否会形成循环引用
		if *req.ParentID == id {
			return nil, models.ErrCategoryCircularReference
		}
		category.ParentID = req.ParentID
	}
	if req.SortOrder != nil {
		category.SortOrder = *req.SortOrder
	}

	// 更新分类
	if err := s.categoryRepo.Update(ctx, category); err != nil {
		s.logger.Error("Failed to update category", "category_id", id, "error", err)
		return nil, err
	}

	// 获取更新后的分类信息
	updatedCategory, err := s.categoryRepo.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	s.logger.Info("Category updated successfully", "category_id", id)
	return s.convertToCategoryResponse(updatedCategory), nil
}

// DeleteCategory 删除分类
func (s *categoryService) DeleteCategory(ctx context.Context, id uint64) error {
	// 检查分类是否存在
	if _, err := s.categoryRepo.GetByID(ctx, id); err != nil {
		return err
	}

	// 删除分类
	if err := s.categoryRepo.Delete(ctx, id); err != nil {
		s.logger.Error("Failed to delete category", "category_id", id, "error", err)
		return err
	}

	s.logger.Info("Category deleted successfully", "category_id", id)
	return nil
}

// GetCategoryList 获取分类列表
func (s *categoryService) GetCategoryList(ctx context.Context, req *GetCategoryListRequest) (*CategoryListResponse, error) {
	// 构建查询参数
	params := &models.CategoryQueryParams{
		ParentID:  req.ParentID,
		Search:    req.Search,
		OrderBy:   req.OrderBy,
		OrderDesc: req.OrderDesc,
		Limit:     req.PageSize,
		Offset:    (req.Page - 1) * req.PageSize,
	}

	// 获取分类列表
	categories, err := s.categoryRepo.List(ctx, params)
	if err != nil {
		s.logger.Error("Failed to get category list", "error", err)
		return nil, err
	}

	// 获取总数
	total, err := s.categoryRepo.Count(ctx, params)
	if err != nil {
		s.logger.Error("Failed to count categories", "error", err)
		return nil, err
	}

	// 转换响应
	categoryResponses := make([]*CategoryResponse, len(categories))
	for i, category := range categories {
		categoryResponses[i] = s.convertToCategoryResponse(category)
	}

	totalPages := int((total + int64(req.PageSize) - 1) / int64(req.PageSize))

	return &CategoryListResponse{
		Categories: categoryResponses,
		Total:      total,
		Page:       req.Page,
		PageSize:   req.PageSize,
		TotalPages: totalPages,
	}, nil
}

// GetCategoryTree 获取分类树
func (s *categoryService) GetCategoryTree(ctx context.Context) (*CategoryTreeResponse, error) {
	categories, err := s.categoryRepo.GetTree(ctx)
	if err != nil {
		s.logger.Error("Failed to get category tree", "error", err)
		return nil, err
	}

	// 转换响应
	categoryResponses := make([]*CategoryResponse, len(categories))
	for i, category := range categories {
		categoryResponses[i] = s.convertToCategoryResponseWithChildren(category)
	}

	return &CategoryTreeResponse{
		Categories: categoryResponses,
	}, nil
}

// GetRootCategories 获取根分类
func (s *categoryService) GetRootCategories(ctx context.Context) (*CategoryListResponse, error) {
	categories, err := s.categoryRepo.GetRootCategories(ctx)
	if err != nil {
		s.logger.Error("Failed to get root categories", "error", err)
		return nil, err
	}

	// 转换响应
	categoryResponses := make([]*CategoryResponse, len(categories))
	for i, category := range categories {
		categoryResponses[i] = s.convertToCategoryResponse(category)
	}

	return &CategoryListResponse{
		Categories: categoryResponses,
		Total:      int64(len(categories)),
		Page:       1,
		PageSize:   len(categories),
		TotalPages: 1,
	}, nil
}

// GetChildCategories 获取子分类
func (s *categoryService) GetChildCategories(ctx context.Context, parentID uint64) (*CategoryListResponse, error) {
	// 验证父分类是否存在
	if _, err := s.categoryRepo.GetByID(ctx, parentID); err != nil {
		return nil, err
	}

	categories, err := s.categoryRepo.GetChildren(ctx, parentID)
	if err != nil {
		s.logger.Error("Failed to get child categories", "parent_id", parentID, "error", err)
		return nil, err
	}

	// 转换响应
	categoryResponses := make([]*CategoryResponse, len(categories))
	for i, category := range categories {
		categoryResponses[i] = s.convertToCategoryResponse(category)
	}

	return &CategoryListResponse{
		Categories: categoryResponses,
		Total:      int64(len(categories)),
		Page:       1,
		PageSize:   len(categories),
		TotalPages: 1,
	}, nil
}

// UpdateSortOrder 更新排序
func (s *categoryService) UpdateSortOrder(ctx context.Context, id uint64, sortOrder int) error {
	// 检查分类是否存在
	if _, err := s.categoryRepo.GetByID(ctx, id); err != nil {
		return err
	}

	if err := s.categoryRepo.UpdateSortOrder(ctx, id, sortOrder); err != nil {
		s.logger.Error("Failed to update category sort order", "category_id", id, "error", err)
		return err
	}

	s.logger.Info("Category sort order updated successfully", "category_id", id, "sort_order", sortOrder)
	return nil
}

// GetCategoryStats 获取分类统计
func (s *categoryService) GetCategoryStats(ctx context.Context) (*CategoryStatsResponse, error) {
	stats, err := s.categoryRepo.GetStats(ctx)
	if err != nil {
		s.logger.Error("Failed to get category stats", "error", err)
		return nil, err
	}

	return &CategoryStatsResponse{
		TotalCategories: stats.TotalCategories,
		RootCategories:  stats.RootCategories,
	}, nil
}

// convertToCategoryResponse 转换为分类响应
func (s *categoryService) convertToCategoryResponse(category *models.Category) *CategoryResponse {
	return &CategoryResponse{
		ID:          category.ID,
		Name:        category.Name,
		Description: category.Description,
		ParentID:    category.ParentID,
		SortOrder:   category.SortOrder,
		CreatedAt:   category.CreatedAt,
		UpdatedAt:   category.UpdatedAt,
	}
}

// convertToCategoryResponseWithChildren 转换为带子分类的分类响应
func (s *categoryService) convertToCategoryResponseWithChildren(category *models.Category) *CategoryResponse {
	children := make([]*CategoryResponse, len(category.Children))
	for i, child := range category.Children {
		children[i] = s.convertToCategoryResponseWithChildren(child)
	}

	return &CategoryResponse{
		ID:          category.ID,
		Name:        category.Name,
		Description: category.Description,
		ParentID:    category.ParentID,
		SortOrder:   category.SortOrder,
		Children:    children,
		CreatedAt:   category.CreatedAt,
		UpdatedAt:   category.UpdatedAt,
	}
}
```

### 步骤3：实现gRPC服务层

#### 3.1 创建电影gRPC处理器

```go
// internal/handler/grpc/movie_handler.go
package grpc

import (
	"context"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/timestamppb"

	movieinfopb "movieinfo/api/proto/movieinfo/v1"
	"movieinfo/internal/service"
	"movieinfo/pkg/logger"
	"movieinfo/pkg/validator"
)

// MovieHandler 电影gRPC处理器
type MovieHandler struct {
	movieinfopb.UnimplementedMovieServiceServer
	movieService service.MovieService
	validator    validator.Validator
	logger       logger.Logger
}

// NewMovieHandler 创建电影处理器
func NewMovieHandler(
	movieService service.MovieService,
	validator validator.Validator,
	logger logger.Logger,
) *MovieHandler {
	return &MovieHandler{
		movieService: movieService,
		validator:    validator,
		logger:       logger,
	}
}

// CreateMovie 创建电影
func (h *MovieHandler) CreateMovie(ctx context.Context, req *movieinfopb.CreateMovieRequest) (*movieinfopb.CreateMovieResponse, error) {
	// 参数验证
	if err := h.validator.ValidateStruct(req); err != nil {
		h.logger.Error("Invalid create movie request", "error", err)
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	// 转换请求
	serviceReq := &service.CreateMovieRequest{
		Title:       req.Title,
		Description: req.Description,
		Director:    req.Director,
		Actors:      req.Actors,
		Year:        int(req.Year),
		Duration:    int(req.Duration),
		PosterUrl:   req.PosterUrl,
		TrailerUrl:  req.TrailerUrl,
		ReleaseDate: req.ReleaseDate.AsTime(),
		CategoryIds: req.CategoryIds,
		Status:      convertMovieStatusFromProto(req.Status),
	}

	// 调用服务
	movie, err := h.movieService.CreateMovie(ctx, serviceReq)
	if err != nil {
		h.logger.Error("Failed to create movie", "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	return &movieinfopb.CreateMovieResponse{
		Movie: h.convertMovieToProto(movie),
	}, nil
}

// GetMovie 获取电影
func (h *MovieHandler) GetMovie(ctx context.Context, req *movieinfopb.GetMovieRequest) (*movieinfopb.GetMovieResponse, error) {
	// 参数验证
	if req.Id == 0 {
		return nil, status.Error(codes.InvalidArgument, "movie id is required")
	}

	// 调用服务
	movie, err := h.movieService.GetMovie(ctx, req.Id)
	if err != nil {
		h.logger.Error("Failed to get movie", "movie_id", req.Id, "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	return &movieinfopb.GetMovieResponse{
		Movie: h.convertMovieToProto(movie),
	}, nil
}

// UpdateMovie 更新电影
func (h *MovieHandler) UpdateMovie(ctx context.Context, req *movieinfopb.UpdateMovieRequest) (*movieinfopb.UpdateMovieResponse, error) {
	// 参数验证
	if req.Id == 0 {
		return nil, status.Error(codes.InvalidArgument, "movie id is required")
	}

	if err := h.validator.ValidateStruct(req); err != nil {
		h.logger.Error("Invalid update movie request", "error", err)
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	// 转换请求
	serviceReq := &service.UpdateMovieRequest{}
	if req.Title != nil {
		serviceReq.Title = &req.Title.Value
	}
	if req.Description != nil {
		serviceReq.Description = &req.Description.Value
	}
	if req.Director != nil {
		serviceReq.Director = &req.Director.Value
	}
	if req.Actors != nil {
		serviceReq.Actors = &req.Actors.Value
	}
	if req.Year != nil {
		year := int(req.Year.Value)
		serviceReq.Year = &year
	}
	if req.Duration != nil {
		duration := int(req.Duration.Value)
		serviceReq.Duration = &duration
	}
	if req.PosterUrl != nil {
		serviceReq.PosterUrl = &req.PosterUrl.Value
	}
	if req.TrailerUrl != nil {
		serviceReq.TrailerUrl = &req.TrailerUrl.Value
	}
	if req.ReleaseDate != nil {
		releaseDate := req.ReleaseDate.AsTime()
		serviceReq.ReleaseDate = &releaseDate
	}
	if len(req.CategoryIds) > 0 {
		serviceReq.CategoryIds = req.CategoryIds
	}
	if req.Status != nil {
		status := convertMovieStatusFromProto(req.Status.Value)
		serviceReq.Status = &status
	}

	// 调用服务
	movie, err := h.movieService.UpdateMovie(ctx, req.Id, serviceReq)
	if err != nil {
		h.logger.Error("Failed to update movie", "movie_id", req.Id, "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	return &movieinfopb.UpdateMovieResponse{
		Movie: h.convertMovieToProto(movie),
	}, nil
}

// DeleteMovie 删除电影
func (h *MovieHandler) DeleteMovie(ctx context.Context, req *movieinfopb.DeleteMovieRequest) (*movieinfopb.DeleteMovieResponse, error) {
	// 参数验证
	if req.Id == 0 {
		return nil, status.Error(codes.InvalidArgument, "movie id is required")
	}

	// 调用服务
	if err := h.movieService.DeleteMovie(ctx, req.Id); err != nil {
		h.logger.Error("Failed to delete movie", "movie_id", req.Id, "error", err)
		return nil, h.handleServiceError(err)
	}

	return &movieinfopb.DeleteMovieResponse{}, nil
}

// GetMovieList 获取电影列表
func (h *MovieHandler) GetMovieList(ctx context.Context, req *movieinfopb.GetMovieListRequest) (*movieinfopb.GetMovieListResponse, error) {
	// 参数验证
	if req.Page <= 0 {
		req.Page = 1
	}
	if req.PageSize <= 0 || req.PageSize > 100 {
		req.PageSize = 20
	}

	// 转换请求
	serviceReq := &service.GetMovieListRequest{
		Page:        int(req.Page),
		PageSize:    int(req.PageSize),
		CategoryIds: req.CategoryIds,
		OrderBy:     req.OrderBy,
		OrderDesc:   req.OrderDesc,
	}

	if req.Status != nil {
		status := convertMovieStatusFromProto(*req.Status)
		serviceReq.Status = &status
	}
	if req.Year != nil {
		year := int(*req.Year)
		serviceReq.Year = &year
	}
	if req.MinRating != nil {
		serviceReq.MinRating = req.MinRating
	}
	if req.MaxRating != nil {
		serviceReq.MaxRating = req.MaxRating
	}

	// 调用服务
	movieList, err := h.movieService.GetMovieList(ctx, serviceReq)
	if err != nil {
		h.logger.Error("Failed to get movie list", "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	movies := make([]*movieinfopb.Movie, len(movieList.Movies))
	for i, movie := range movieList.Movies {
		movies[i] = h.convertMovieToProto(movie)
	}

	return &movieinfopb.GetMovieListResponse{
		Movies:     movies,
		Total:      movieList.Total,
		Page:       int32(movieList.Page),
		PageSize:   int32(movieList.PageSize),
		TotalPages: int32(movieList.TotalPages),
	}, nil
}

// SearchMovies 搜索电影
func (h *MovieHandler) SearchMovies(ctx context.Context, req *movieinfopb.SearchMoviesRequest) (*movieinfopb.SearchMoviesResponse, error) {
	// 参数验证
	if req.Keyword == "" {
		return nil, status.Error(codes.InvalidArgument, "search keyword is required")
	}

	if req.Page <= 0 {
		req.Page = 1
	}
	if req.PageSize <= 0 || req.PageSize > 100 {
		req.PageSize = 20
	}

	// 转换请求
	serviceReq := &service.SearchMoviesRequest{
		Keyword:   req.Keyword,
		Page:      int(req.Page),
		PageSize:  int(req.PageSize),
		OrderBy:   req.OrderBy,
		OrderDesc: req.OrderDesc,
	}

	// 调用服务
	movieList, err := h.movieService.SearchMovies(ctx, serviceReq)
	if err != nil {
		h.logger.Error("Failed to search movies", "keyword", req.Keyword, "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	movies := make([]*movieinfopb.Movie, len(movieList.Movies))
	for i, movie := range movieList.Movies {
		movies[i] = h.convertMovieToProto(movie)
	}

	return &movieinfopb.SearchMoviesResponse{
		Movies:     movies,
		Total:      movieList.Total,
		Page:       int32(movieList.Page),
		PageSize:   int32(movieList.PageSize),
		TotalPages: int32(movieList.TotalPages),
	}, nil
}

// GetPopularMovies 获取热门电影
func (h *MovieHandler) GetPopularMovies(ctx context.Context, req *movieinfopb.GetPopularMoviesRequest) (*movieinfopb.GetPopularMoviesResponse, error) {
	// 参数验证
	if req.Limit <= 0 || req.Limit > 100 {
		req.Limit = 10
	}

	// 调用服务
	movieList, err := h.movieService.GetPopularMovies(ctx, int(req.Limit))
	if err != nil {
		h.logger.Error("Failed to get popular movies", "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	movies := make([]*movieinfopb.Movie, len(movieList.Movies))
	for i, movie := range movieList.Movies {
		movies[i] = h.convertMovieToProto(movie)
	}

	return &movieinfopb.GetPopularMoviesResponse{
		Movies: movies,
	}, nil
}

// GetRecentMovies 获取最新电影
func (h *MovieHandler) GetRecentMovies(ctx context.Context, req *movieinfopb.GetRecentMoviesRequest) (*movieinfopb.GetRecentMoviesResponse, error) {
	// 参数验证
	if req.Limit <= 0 || req.Limit > 100 {
		req.Limit = 10
	}

	// 调用服务
	movieList, err := h.movieService.GetRecentMovies(ctx, int(req.Limit))
	if err != nil {
		h.logger.Error("Failed to get recent movies", "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	movies := make([]*movieinfopb.Movie, len(movieList.Movies))
	for i, movie := range movieList.Movies {
		movies[i] = h.convertMovieToProto(movie)
	}

	return &movieinfopb.GetRecentMoviesResponse{
		Movies: movies,
	}, nil
}

// IncrementViewCount 增加观看次数
func (h *MovieHandler) IncrementViewCount(ctx context.Context, req *movieinfopb.IncrementViewCountRequest) (*movieinfopb.IncrementViewCountResponse, error) {
	// 参数验证
	if req.Id == 0 {
		return nil, status.Error(codes.InvalidArgument, "movie id is required")
	}

	// 调用服务
	if err := h.movieService.IncrementViewCount(ctx, req.Id); err != nil {
		h.logger.Error("Failed to increment view count", "movie_id", req.Id, "error", err)
		return nil, h.handleServiceError(err)
	}

	return &movieinfopb.IncrementViewCountResponse{}, nil
}

// GetMovieStats 获取电影统计
func (h *MovieHandler) GetMovieStats(ctx context.Context, req *movieinfopb.GetMovieStatsRequest) (*movieinfopb.GetMovieStatsResponse, error) {
	// 调用服务
	stats, err := h.movieService.GetMovieStats(ctx)
	if err != nil {
		h.logger.Error("Failed to get movie stats", "error", err)
		return nil, h.handleServiceError(err)
	}

	return &movieinfopb.GetMovieStatsResponse{
		TotalMovies:        stats.TotalMovies,
		PublishedMovies:    stats.PublishedMovies,
		DraftMovies:        stats.DraftMovies,
		NewMoviesToday:     stats.NewMoviesToday,
		NewMoviesThisMonth: stats.NewMoviesThisMonth,
	}, nil
}

// convertMovieToProto 转换电影为Proto格式
func (h *MovieHandler) convertMovieToProto(movie *service.MovieResponse) *movieinfopb.Movie {
	categories := make([]*movieinfopb.Category, len(movie.Categories))
	for i, category := range movie.Categories {
		categories[i] = &movieinfopb.Category{
			Id:          category.ID,
			Name:        category.Name,
			Description: category.Description,
			ParentId:    category.ParentID,
			SortOrder:   int32(category.SortOrder),
			CreatedAt:   timestamppb.New(category.CreatedAt),
			UpdatedAt:   timestamppb.New(category.UpdatedAt),
		}
	}

	return &movieinfopb.Movie{
		Id:          movie.ID,
		Title:       movie.Title,
		Description: movie.Description,
		Director:    movie.Director,
		Actors:      movie.Actors,
		Year:        int32(movie.Year),
		Duration:    int32(movie.Duration),
		PosterUrl:   movie.PosterURL,
		TrailerUrl:  movie.TrailerURL,
		Rating:      movie.Rating,
		RatingCount: int32(movie.RatingCount),
		ViewCount:   movie.ViewCount,
		Status:      convertMovieStatusToProto(movie.Status),
		ReleaseDate: timestamppb.New(movie.ReleaseDate),
		Categories:  categories,
		CreatedAt:   timestamppb.New(movie.CreatedAt),
		UpdatedAt:   timestamppb.New(movie.UpdatedAt),
	}
}

// handleServiceError 处理服务错误
func (h *MovieHandler) handleServiceError(err error) error {
	// 根据错误类型返回相应的gRPC状态码
	switch err {
	case models.ErrMovieNotFound:
		return status.Error(codes.NotFound, "movie not found")
	case models.ErrMovieTitleExists:
		return status.Error(codes.AlreadyExists, "movie title already exists")
	default:
		return status.Error(codes.Internal, "internal server error")
	}
}

// convertMovieStatusFromProto 从Proto转换电影状态
func convertMovieStatusFromProto(status movieinfopb.MovieStatus) models.MovieStatus {
	switch status {
	case movieinfopb.MovieStatus_MOVIE_STATUS_DRAFT:
		return models.MovieStatusDraft
	case movieinfopb.MovieStatus_MOVIE_STATUS_PUBLISHED:
		return models.MovieStatusPublished
	case movieinfopb.MovieStatus_MOVIE_STATUS_ARCHIVED:
		return models.MovieStatusArchived
	default:
		return models.MovieStatusDraft
	}
}

// convertMovieStatusToProto 转换电影状态为Proto格式
func convertMovieStatusToProto(status models.MovieStatus) movieinfopb.MovieStatus {
	switch status {
	case models.MovieStatusDraft:
		return movieinfopb.MovieStatus_MOVIE_STATUS_DRAFT
	case models.MovieStatusPublished:
		return movieinfopb.MovieStatus_MOVIE_STATUS_PUBLISHED
	case models.MovieStatusArchived:
		return movieinfopb.MovieStatus_MOVIE_STATUS_ARCHIVED
	default:
		return movieinfopb.MovieStatus_MOVIE_STATUS_DRAFT
	}
}
```

#### 3.2 创建分类gRPC处理器

```go
// internal/handler/grpc/category_handler.go
package grpc

import (
	"context"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/timestamppb"

	movieinfopb "movieinfo/api/proto/movieinfo/v1"
	"movieinfo/internal/service"
	"movieinfo/pkg/logger"
	"movieinfo/pkg/validator"
)

// CategoryHandler 分类gRPC处理器
type CategoryHandler struct {
	movieinfopb.UnimplementedCategoryServiceServer
	categoryService service.CategoryService
	validator       validator.Validator
	logger          logger.Logger
}

// NewCategoryHandler 创建分类处理器
func NewCategoryHandler(
	categoryService service.CategoryService,
	validator validator.Validator,
	logger logger.Logger,
) *CategoryHandler {
	return &CategoryHandler{
		categoryService: categoryService,
		validator:       validator,
		logger:          logger,
	}
}

// CreateCategory 创建分类
func (h *CategoryHandler) CreateCategory(ctx context.Context, req *movieinfopb.CreateCategoryRequest) (*movieinfopb.CreateCategoryResponse, error) {
	// 参数验证
	if err := h.validator.ValidateStruct(req); err != nil {
		h.logger.Error("Invalid create category request", "error", err)
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	// 转换请求
	serviceReq := &service.CreateCategoryRequest{
		Name:        req.Name,
		Description: req.Description,
		SortOrder:   int(req.SortOrder),
	}

	if req.ParentId != nil {
		parentID := *req.ParentId
		serviceReq.ParentID = &parentID
	}

	// 调用服务
	category, err := h.categoryService.CreateCategory(ctx, serviceReq)
	if err != nil {
		h.logger.Error("Failed to create category", "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	return &movieinfopb.CreateCategoryResponse{
		Category: h.convertCategoryToProto(category),
	}, nil
}

// GetCategory 获取分类
func (h *CategoryHandler) GetCategory(ctx context.Context, req *movieinfopb.GetCategoryRequest) (*movieinfopb.GetCategoryResponse, error) {
	// 参数验证
	if req.Id == 0 {
		return nil, status.Error(codes.InvalidArgument, "category id is required")
	}

	// 调用服务
	category, err := h.categoryService.GetCategory(ctx, req.Id)
	if err != nil {
		h.logger.Error("Failed to get category", "category_id", req.Id, "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	return &movieinfopb.GetCategoryResponse{
		Category: h.convertCategoryToProto(category),
	}, nil
}

// UpdateCategory 更新分类
func (h *CategoryHandler) UpdateCategory(ctx context.Context, req *movieinfopb.UpdateCategoryRequest) (*movieinfopb.UpdateCategoryResponse, error) {
	// 参数验证
	if req.Id == 0 {
		return nil, status.Error(codes.InvalidArgument, "category id is required")
	}

	if err := h.validator.ValidateStruct(req); err != nil {
		h.logger.Error("Invalid update category request", "error", err)
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	// 转换请求
	serviceReq := &service.UpdateCategoryRequest{}
	if req.Name != nil {
		serviceReq.Name = &req.Name.Value
	}
	if req.Description != nil {
		serviceReq.Description = &req.Description.Value
	}
	if req.ParentId != nil {
		parentID := req.ParentId.Value
		serviceReq.ParentID = &parentID
	}
	if req.SortOrder != nil {
		sortOrder := int(req.SortOrder.Value)
		serviceReq.SortOrder = &sortOrder
	}

	// 调用服务
	category, err := h.categoryService.UpdateCategory(ctx, req.Id, serviceReq)
	if err != nil {
		h.logger.Error("Failed to update category", "category_id", req.Id, "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	return &movieinfopb.UpdateCategoryResponse{
		Category: h.convertCategoryToProto(category),
	}, nil
}

// DeleteCategory 删除分类
func (h *CategoryHandler) DeleteCategory(ctx context.Context, req *movieinfopb.DeleteCategoryRequest) (*movieinfopb.DeleteCategoryResponse, error) {
	// 参数验证
	if req.Id == 0 {
		return nil, status.Error(codes.InvalidArgument, "category id is required")
	}

	// 调用服务
	if err := h.categoryService.DeleteCategory(ctx, req.Id); err != nil {
		h.logger.Error("Failed to delete category", "category_id", req.Id, "error", err)
		return nil, h.handleServiceError(err)
	}

	return &movieinfopb.DeleteCategoryResponse{}, nil
}

// GetCategoryList 获取分类列表
func (h *CategoryHandler) GetCategoryList(ctx context.Context, req *movieinfopb.GetCategoryListRequest) (*movieinfopb.GetCategoryListResponse, error) {
	// 参数验证
	if req.Page <= 0 {
		req.Page = 1
	}
	if req.PageSize <= 0 || req.PageSize > 100 {
		req.PageSize = 20
	}

	// 转换请求
	serviceReq := &service.GetCategoryListRequest{
		Page:      int(req.Page),
		PageSize:  int(req.PageSize),
		Search:    req.Search,
		OrderBy:   req.OrderBy,
		OrderDesc: req.OrderDesc,
	}

	if req.ParentId != nil {
		parentID := *req.ParentId
		serviceReq.ParentID = &parentID
	}

	// 调用服务
	categoryList, err := h.categoryService.GetCategoryList(ctx, serviceReq)
	if err != nil {
		h.logger.Error("Failed to get category list", "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	categories := make([]*movieinfopb.Category, len(categoryList.Categories))
	for i, category := range categoryList.Categories {
		categories[i] = h.convertCategoryToProto(category)
	}

	return &movieinfopb.GetCategoryListResponse{
		Categories: categories,
		Total:      categoryList.Total,
		Page:       int32(categoryList.Page),
		PageSize:   int32(categoryList.PageSize),
		TotalPages: int32(categoryList.TotalPages),
	}, nil
}

// GetCategoryTree 获取分类树
func (h *CategoryHandler) GetCategoryTree(ctx context.Context, req *movieinfopb.GetCategoryTreeRequest) (*movieinfopb.GetCategoryTreeResponse, error) {
	// 调用服务
	categoryTree, err := h.categoryService.GetCategoryTree(ctx)
	if err != nil {
		h.logger.Error("Failed to get category tree", "error", err)
		return nil, h.handleServiceError(err)
	}

	// 转换响应
	categories := make([]*movieinfopb.Category, len(categoryTree.Categories))
	for i, category := range categoryTree.Categories {
		categories[i] = h.convertCategoryToProtoWithChildren(category)
	}

	return &movieinfopb.GetCategoryTreeResponse{
		Categories: categories,
	}, nil
}

// GetCategoryStats 获取分类统计
func (h *CategoryHandler) GetCategoryStats(ctx context.Context, req *movieinfopb.GetCategoryStatsRequest) (*movieinfopb.GetCategoryStatsResponse, error) {
	// 调用服务
	stats, err := h.categoryService.GetCategoryStats(ctx)
	if err != nil {
		h.logger.Error("Failed to get category stats", "error", err)
		return nil, h.handleServiceError(err)
	}

	return &movieinfopb.GetCategoryStatsResponse{
		TotalCategories: stats.TotalCategories,
		RootCategories:  stats.RootCategories,
	}, nil
}

// convertCategoryToProto 转换分类为Proto格式
func (h *CategoryHandler) convertCategoryToProto(category *service.CategoryResponse) *movieinfopb.Category {
	return &movieinfopb.Category{
		Id:          category.ID,
		Name:        category.Name,
		Description: category.Description,
		ParentId:    category.ParentID,
		SortOrder:   int32(category.SortOrder),
		CreatedAt:   timestamppb.New(category.CreatedAt),
		UpdatedAt:   timestamppb.New(category.UpdatedAt),
	}
}

// convertCategoryToProtoWithChildren 转换带子分类的分类为Proto格式
func (h *CategoryHandler) convertCategoryToProtoWithChildren(category *service.CategoryResponse) *movieinfopb.Category {
	children := make([]*movieinfopb.Category, len(category.Children))
	for i, child := range category.Children {
		children[i] = h.convertCategoryToProtoWithChildren(child)
	}

	return &movieinfopb.Category{
		Id:          category.ID,
		Name:        category.Name,
		Description: category.Description,
		ParentId:    category.ParentID,
		SortOrder:   int32(category.SortOrder),
		Children:    children,
		CreatedAt:   timestamppb.New(category.CreatedAt),
		UpdatedAt:   timestamppb.New(category.UpdatedAt),
	}
}

// handleServiceError 处理服务错误
func (h *CategoryHandler) handleServiceError(err error) error {
	// 根据错误类型返回相应的gRPC状态码
	switch err {
	case models.ErrCategoryNotFound:
		return status.Error(codes.NotFound, "category not found")
	case models.ErrCategoryNameExists:
		return status.Error(codes.AlreadyExists, "category name already exists")
	case models.ErrCategoryCircularReference:
		return status.Error(codes.InvalidArgument, "circular reference detected")
	default:
		return status.Error(codes.Internal, "internal server error")
	}
}
```

### 步骤4：创建配置文件

#### 4.1 电影服务配置

```yaml
# configs/movie.yaml
movie:
  # 电影配置
  default_page_size: 20
  max_page_size: 100
  max_search_results: 1000
  
  # 缓存配置
  cache:
    enabled: true
    ttl: 3600  # 1小时
    popular_movies_ttl: 1800  # 30分钟
    recent_movies_ttl: 900    # 15分钟
    
  # 搜索配置
  search:
    min_keyword_length: 2
    max_keyword_length: 100
    highlight_enabled: true
    
  # 文件上传配置
  upload:
    poster:
      max_size: 5242880  # 5MB
      allowed_types: ["image/jpeg", "image/png", "image/webp"]
      path: "uploads/posters"
    trailer:
      max_size: 104857600  # 100MB
      allowed_types: ["video/mp4", "video/webm"]
      path: "uploads/trailers"
      
  # 评分配置
  rating:
    min_rating: 0.0
    max_rating: 10.0
    precision: 1  # 小数位数
    
  # 统计配置
  stats:
    cache_ttl: 300  # 5分钟
    popular_threshold: 1000  # 热门电影观看次数阈值
    recent_days: 30  # 最新电影天数
```

#### 4.2 分类服务配置

```yaml
# configs/category.yaml
category:
  # 分类配置
  max_depth: 5  # 最大层级深度
  default_sort_order: 0
  
  # 缓存配置
  cache:
    enabled: true
    tree_ttl: 7200  # 分类树缓存2小时
    list_ttl: 3600  # 分类列表缓存1小时
    
  # 验证配置
  validation:
    name:
      min_length: 1
      max_length: 50
    description:
      max_length: 200
      
  # 排序配置
  sort:
    default_order: "sort_order"
    allowed_fields: ["id", "name", "sort_order", "created_at"]
```

### 步骤5：创建初始化脚本

#### 5.1 电影模块初始化

```go
// internal/movie/init.go
package movie

import (
	"context"
	"fmt"

	"movieinfo/internal/models"
	"movieinfo/internal/service"
	"movieinfo/pkg/cache"
	"movieinfo/pkg/config"
	"movieinfo/pkg/logger"
)

// MovieModule 电影模块
type MovieModule struct {
	movieRepo    models.MovieRepository
	categoryRepo models.CategoryRepository
	movieService service.MovieService
	categoryService service.CategoryService
	logger       logger.Logger
}

// NewMovieModule 创建电影模块
func NewMovieModule(
	movieRepo models.MovieRepository,
	categoryRepo models.CategoryRepository,
	cache cache.Manager,
	logger logger.Logger,
) *MovieModule {
	// 创建服务
	movieService := service.NewMovieService(movieRepo, categoryRepo, cache, logger)
	categoryService := service.NewCategoryService(categoryRepo, cache, logger)

	return &MovieModule{
		movieRepo:       movieRepo,
		categoryRepo:    categoryRepo,
		movieService:    movieService,
		categoryService: categoryService,
		logger:          logger,
	}
}

// GetMovieService 获取电影服务
func (m *MovieModule) GetMovieService() service.MovieService {
	return m.movieService
}

// GetCategoryService 获取分类服务
func (m *MovieModule) GetCategoryService() service.CategoryService {
	return m.categoryService
}

// HealthCheck 健康检查
func (m *MovieModule) HealthCheck(ctx context.Context) error {
	// 检查数据库连接
	if err := m.movieRepo.HealthCheck(ctx); err != nil {
		return fmt.Errorf("movie repository health check failed: %w", err)
	}

	if err := m.categoryRepo.HealthCheck(ctx); err != nil {
		return fmt.Errorf("category repository health check failed: %w", err)
	}

	m.logger.Info("Movie module health check passed")
	return nil
}

// Close 关闭模块
func (m *MovieModule) Close() error {
	m.logger.Info("Closing movie module")
	return nil
}

// InitMovieModule 初始化电影模块
func InitMovieModule(
	cfg *config.Config,
	movieRepo models.MovieRepository,
	categoryRepo models.CategoryRepository,
	cache cache.Manager,
	logger logger.Logger,
) (*MovieModule, error) {
	// 创建电影模块
	module := NewMovieModule(movieRepo, categoryRepo, cache, logger)

	// 健康检查
	ctx := context.Background()
	if err := module.HealthCheck(ctx); err != nil {
		return nil, fmt.Errorf("movie module initialization failed: %w", err)
	}

	logger.Info("Movie module initialized successfully")
	return module, nil
}
```

### 步骤6：测试验证

#### 6.1 电影仓储测试

```go
// internal/repository/movie_repository_test.go
package repository

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"movieinfo/internal/models"
	"movieinfo/pkg/testutil"
)

func TestMovieRepository_Create(t *testing.T) {
	// 设置测试环境
	db := testutil.SetupTestDB(t)
	defer testutil.CleanupTestDB(t, db)

	repo := NewMovieRepository(db)
	ctx := context.Background()

	// 创建测试数据
	movie := &models.Movie{
		Title:       "Test Movie",
		Description: "Test Description",
		Director:    "Test Director",
		Actors:      "Test Actors",
		Year:        2023,
		Duration:    120,
		PosterURL:   "https://example.com/poster.jpg",
		TrailerURL:  "https://example.com/trailer.mp4",
		ReleaseDate: time.Now(),
		Status:      models.MovieStatusPublished,
	}

	// 执行创建
	err := repo.Create(ctx, movie)
	require.NoError(t, err)
	assert.NotZero(t, movie.ID)
	assert.NotZero(t, movie.CreatedAt)
	assert.NotZero(t, movie.UpdatedAt)
}

func TestMovieRepository_GetByID(t *testing.T) {
	// 设置测试环境
	db := testutil.SetupTestDB(t)
	defer testutil.CleanupTestDB(t, db)

	repo := NewMovieRepository(db)
	ctx := context.Background()

	// 创建测试数据
	movie := testutil.CreateTestMovie(t, db)

	// 执行查询
	found, err := repo.GetByID(ctx, movie.ID)
	require.NoError(t, err)
	assert.Equal(t, movie.ID, found.ID)
	assert.Equal(t, movie.Title, found.Title)
}

func TestMovieRepository_List(t *testing.T) {
	// 设置测试环境
	db := testutil.SetupTestDB(t)
	defer testutil.CleanupTestDB(t, db)

	repo := NewMovieRepository(db)
	ctx := context.Background()

	// 创建测试数据
	testutil.CreateTestMovies(t, db, 5)

	// 执行查询
	params := &models.MovieQueryParams{
		Limit:  10,
		Offset: 0,
	}

	movies, err := repo.List(ctx, params)
	require.NoError(t, err)
	assert.Len(t, movies, 5)
}

func TestMovieRepository_Search(t *testing.T) {
	// 设置测试环境
	db := testutil.SetupTestDB(t)
	defer testutil.CleanupTestDB(t, db)

	repo := NewMovieRepository(db)
	ctx := context.Background()

	// 创建测试数据
	movie := testutil.CreateTestMovie(t, db)
	movie.Title = "Unique Test Movie"
	db.Save(movie)

	// 执行搜索
	params := &models.MovieSearchParams{
		Keyword: "Unique",
		Limit:   10,
		Offset:  0,
	}

	movies, err := repo.Search(ctx, params)
	require.NoError(t, err)
	assert.Len(t, movies, 1)
	assert.Equal(t, movie.ID, movies[0].ID)
}
```

#### 6.2 电影服务测试

```go
// internal/service/movie_service_test.go
package service

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"

	"movieinfo/internal/models"
	"movieinfo/pkg/testutil"
)

func TestMovieService_CreateMovie(t *testing.T) {
	// 创建模拟对象
	mockMovieRepo := &testutil.MockMovieRepository{}
	mockCategoryRepo := &testutil.MockCategoryRepository{}
	mockCache := &testutil.MockCacheManager{}
	mockLogger := &testutil.MockLogger{}

	// 创建服务
	service := NewMovieService(mockMovieRepo, mockCategoryRepo, mockCache, mockLogger)
	ctx := context.Background()

	// 设置模拟期望
	mockMovieRepo.On("ExistsByTitle", ctx, "Test Movie").Return(false, nil)
	mockCategoryRepo.On("GetByIDs", ctx, []uint64{1, 2}).Return([]*models.Category{
		{ID: 1, Name: "Action"},
		{ID: 2, Name: "Drama"},
	}, nil)
	mockMovieRepo.On("Create", ctx, mock.AnythingOfType("*models.Movie")).Return(nil)
	mockMovieRepo.On("GetByID", ctx, mock.AnythingOfType("uint64")).Return(&models.Movie{
		ID:    1,
		Title: "Test Movie",
	}, nil)

	// 执行测试
	req := &CreateMovieRequest{
		Title:       "Test Movie",
		Description: "Test Description",
		Director:    "Test Director",
		Actors:      "Test Actors",
		Year:        2023,
		Duration:    120,
		ReleaseDate: time.Now(),
		CategoryIds: []uint64{1, 2},
		Status:      models.MovieStatusPublished,
	}

	movie, err := service.CreateMovie(ctx, req)
	require.NoError(t, err)
	assert.NotNil(t, movie)
	assert.Equal(t, "Test Movie", movie.Title)

	// 验证模拟调用
	mockMovieRepo.AssertExpectations(t)
	mockCategoryRepo.AssertExpectations(t)
}

func TestMovieService_GetMovieList(t *testing.T) {
	// 创建模拟对象
	mockMovieRepo := &testutil.MockMovieRepository{}
	mockCategoryRepo := &testutil.MockCategoryRepository{}
	mockCache := &testutil.MockCacheManager{}
	mockLogger := &testutil.MockLogger{}

	// 创建服务
	service := NewMovieService(mockMovieRepo, mockCategoryRepo, mockCache, mockLogger)
	ctx := context.Background()

	// 设置模拟期望
	mockMovieRepo.On("List", ctx, mock.AnythingOfType("*models.MovieQueryParams")).Return([]*models.Movie{
		{ID: 1, Title: "Movie 1"},
		{ID: 2, Title: "Movie 2"},
	}, nil)
	mockMovieRepo.On("Count", ctx, mock.AnythingOfType("*models.MovieQueryParams")).Return(int64(2), nil)

	// 执行测试
	req := &GetMovieListRequest{
		Page:     1,
		PageSize: 10,
	}

	movieList, err := service.GetMovieList(ctx, req)
	require.NoError(t, err)
	assert.NotNil(t, movieList)
	assert.Len(t, movieList.Movies, 2)
	assert.Equal(t, int64(2), movieList.Total)

	// 验证模拟调用
	mockMovieRepo.AssertExpectations(t)
}
```

#### 6.3 集成测试

```go
// test/integration/movie_integration_test.go
package integration

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"movieinfo/internal/models"
	"movieinfo/internal/service"
	"movieinfo/pkg/testutil"
)

func TestMovieIntegration(t *testing.T) {
	// 设置测试环境
	db := testutil.SetupTestDB(t)
	defer testutil.CleanupTestDB(t, db)

	cache := testutil.SetupTestCache(t)
	defer testutil.CleanupTestCache(t, cache)

	logger := testutil.SetupTestLogger(t)

	// 创建仓储和服务
	movieRepo := repository.NewMovieRepository(db)
	categoryRepo := repository.NewCategoryRepository(db)
	movieService := service.NewMovieService(movieRepo, categoryRepo, cache, logger)
	categoryService := service.NewCategoryService(categoryRepo, cache, logger)

	ctx := context.Background()

	// 创建分类
	categoryReq := &service.CreateCategoryRequest{
		Name:        "Action",
		Description: "Action movies",
	}
	category, err := categoryService.CreateCategory(ctx, categoryReq)
	require.NoError(t, err)

	// 创建电影
	movieReq := &service.CreateMovieRequest{
		Title:       "Test Movie",
		Description: "Test Description",
		Director:    "Test Director",
		Actors:      "Test Actors",
		Year:        2023,
		Duration:    120,
		ReleaseDate: time.Now(),
		CategoryIds: []uint64{category.ID},
		Status:      models.MovieStatusPublished,
	}

	movie, err := movieService.CreateMovie(ctx, movieReq)
	require.NoError(t, err)
	assert.NotNil(t, movie)
	assert.Equal(t, "Test Movie", movie.Title)
	assert.Len(t, movie.Categories, 1)
	assert.Equal(t, category.ID, movie.Categories[0].ID)

	// 获取电影
	foundMovie, err := movieService.GetMovie(ctx, movie.ID)
	require.NoError(t, err)
	assert.Equal(t, movie.ID, foundMovie.ID)

	// 搜索电影
	searchReq := &service.SearchMoviesRequest{
		Keyword:  "Test",
		Page:     1,
		PageSize: 10,
	}

	searchResult, err := movieService.SearchMovies(ctx, searchReq)
	require.NoError(t, err)
	assert.Len(t, searchResult.Movies, 1)
	assert.Equal(t, movie.ID, searchResult.Movies[0].ID)

	// 增加观看次数
	err = movieService.IncrementViewCount(ctx, movie.ID)
	require.NoError(t, err)

	// 验证观看次数
	updatedMovie, err := movieService.GetMovie(ctx, movie.ID)
	require.NoError(t, err)
	assert.Equal(t, uint64(1), updatedMovie.ViewCount)
}
```

## 预期结果

完成本文档后，您将拥有：

1. **完整的电影服务**：包含电影的CRUD、搜索、统计等功能
2. **完整的分类服务**：包含分类的管理、树形结构、排序等功能
3. **gRPC接口层**：提供标准化的API接口
4. **缓存支持**：提高系统性能
5. **完整的测试覆盖**：确保代码质量

## 注意事项

### 安全性
- 实现输入验证和参数校验
- 防止SQL注入和XSS攻击
- 实现适当的权限控制
- 敏感信息加密存储

### 性能优化
- 合理使用数据库索引
- 实现查询缓存策略
- 优化数据库查询语句
- 实现分页和限流

### 维护性
- 保持代码结构清晰
- 添加详细的注释和文档
- 实现完整的错误处理
- 定期进行代码重构

## 下一步骤

完成电影服务开发后，下一步将进行：

1. **评分服务开发**：实现用户评分功能
2. **推荐系统开发**：基于用户行为的电影推荐
3. **搜索优化**：实现全文搜索和智能推荐
4. **API网关开发**：统一的API入口和路由

## 检查清单

- [ ] 电影仓储层实现完成
- [ ] 分类仓储层实现完成
- [ ] 电影服务层实现完成
- [ ] 分类服务层实现完成
- [ ] gRPC处理器实现完成
- [ ] 配置文件创建完成
- [ ] 初始化脚本创建完成
- [ ] 单元测试编写完成
- [ ] 集成测试编写完成
- [ ] 文档更新完成
```