# 03-配置管理系统

## 目标说明

本步骤的目标是构建一个完整的配置管理系统，为 MovieInfo 项目提供统一的配置管理能力：
- 设计灵活的配置文件结构
- 实现多环境配置支持（开发、测试、生产）
- 支持配置文件热更新
- 集成环境变量和命令行参数
- 提供配置验证和默认值机制
- 实现配置的安全管理

完成本步骤后，将拥有一套完整的配置管理系统，为后续的服务开发提供统一的配置基础。

## 前置条件

- 已完成项目初始化（01-项目初始化.md）
- 已完成数据库设计（02-数据库设计.md）
- 熟悉 Go 语言的结构体和接口
- 了解 YAML 和 JSON 配置文件格式
- 理解环境变量和命令行参数的使用

## 技术要点

### 配置管理原则
- **分层配置**：支持默认配置、环境配置、用户配置的分层覆盖
- **环境隔离**：不同环境使用不同的配置文件
- **安全性**：敏感信息使用环境变量，不写入配置文件
- **可扩展性**：配置结构易于扩展和维护

### 技术选型
- **配置格式**：使用 YAML 作为主要配置格式
- **配置库**：使用 Viper 库进行配置管理
- **验证库**：使用 validator 库进行配置验证
- **环境变量**：支持通过环境变量覆盖配置

### 配置结构设计
- **服务配置**：各个微服务的基础配置
- **数据库配置**：数据库连接和池配置
- **日志配置**：日志级别和输出配置
- **安全配置**：JWT、加密等安全相关配置

## 实现步骤

### 步骤1：创建配置文件结构

#### 1.1 创建配置目录结构

```bash
# 在项目根目录下创建配置目录
mkdir -p configs/environments
mkdir -p configs/templates
```

#### 1.2 设计主配置文件结构

```yaml
# configs/config.yaml - 主配置文件模板
# MovieInfo 项目配置文件

# 应用基础配置
app:
  name: "movieinfo"
  version: "1.0.0"
  environment: "development"  # development, testing, production
  debug: true
  timezone: "Asia/Shanghai"

# 服务配置
services:
  # 用户服务
  user:
    host: "localhost"
    port: 8081
    timeout: "30s"
    
  # 电影服务
  movie:
    host: "localhost"
    port: 8082
    timeout: "30s"
    
  # 评分服务
  rating:
    host: "localhost"
    port: 8083
    timeout: "30s"
    
  # Web服务
  web:
    host: "localhost"
    port: 8080
    timeout: "30s"
    read_timeout: "10s"
    write_timeout: "10s"
    idle_timeout: "60s"

# 数据库配置
database:
  driver: "mysql"
  host: "localhost"
  port: 3306
  username: "movieinfo_user"
  password: ""  # 通过环境变量设置
  database: "movieinfo"
  charset: "utf8mb4"
  parse_time: true
  loc: "Local"
  
  # 连接池配置
  max_open_conns: 100
  max_idle_conns: 10
  conn_max_lifetime: "1h"
  conn_max_idle_time: "30m"
  
  # 日志配置
  log_level: "info"
  slow_threshold: "200ms"

# Redis配置
redis:
  host: "localhost"
  port: 6379
  password: ""  # 通过环境变量设置
  database: 0
  pool_size: 10
  min_idle_conns: 5
  dial_timeout: "5s"
  read_timeout: "3s"
  write_timeout: "3s"
  pool_timeout: "4s"
  idle_timeout: "5m"

# 日志配置
log:
  level: "info"  # debug, info, warn, error
  format: "json"  # json, text
  output: "stdout"  # stdout, stderr, file
  file_path: "logs/app.log"
  max_size: 100  # MB
  max_backups: 10
  max_age: 30  # days
  compress: true

# JWT配置
jwt:
  secret: ""  # 通过环境变量设置
  expire_time: "24h"
  refresh_expire_time: "168h"  # 7 days
  issuer: "movieinfo"

# 文件上传配置
upload:
  max_size: "10MB"
  allowed_types:
    - "image/jpeg"
    - "image/png"
    - "image/gif"
  upload_path: "uploads"
  url_prefix: "/static/uploads"

# 邮件配置
email:
  smtp_host: "smtp.gmail.com"
  smtp_port: 587
  username: ""  # 通过环境变量设置
  password: ""  # 通过环境变量设置
  from_email: "noreply@movieinfo.com"
  from_name: "MovieInfo"

# 缓存配置
cache:
  default_expire: "1h"
  cleanup_interval: "10m"
  
# 限流配置
rate_limit:
  enabled: true
  requests_per_minute: 60
  burst: 10

# 监控配置
monitoring:
  metrics:
    enabled: true
    path: "/metrics"
  health:
    enabled: true
    path: "/health"
  pprof:
    enabled: false  # 仅在开发环境启用
    path: "/debug/pprof"
```

#### 1.3 创建环境特定配置

```yaml
# configs/environments/development.yaml - 开发环境配置
app:
  debug: true
  environment: "development"

services:
  web:
    host: "0.0.0.0"
    port: 8080

database:
  log_level: "debug"
  slow_threshold: "100ms"

log:
  level: "debug"
  format: "text"
  output: "stdout"

monitoring:
  pprof:
    enabled: true

rate_limit:
  enabled: false
```

```yaml
# configs/environments/testing.yaml - 测试环境配置
app:
  debug: false
  environment: "testing"

database:
  database: "movieinfo_test"
  log_level: "warn"

log:
  level: "warn"
  format: "json"

rate_limit:
  requests_per_minute: 1000
```

```yaml
# configs/environments/production.yaml - 生产环境配置
app:
  debug: false
  environment: "production"

services:
  web:
    host: "0.0.0.0"
    port: 80
    read_timeout: "5s"
    write_timeout: "5s"

database:
  max_open_conns: 200
  max_idle_conns: 20
  log_level: "error"
  slow_threshold: "500ms"

log:
  level: "info"
  format: "json"
  output: "file"
  file_path: "/var/log/movieinfo/app.log"

monitoring:
  pprof:
    enabled: false

rate_limit:
  enabled: true
  requests_per_minute: 100
```

### 步骤2：实现配置管理代码

#### 2.1 创建配置结构体定义

```go
// pkg/config/types.go
package config

import "time"

// Config 应用配置结构
type Config struct {
	App        AppConfig        `yaml:"app" validate:"required"`
	Services   ServicesConfig   `yaml:"services" validate:"required"`
	Database   DatabaseConfig   `yaml:"database" validate:"required"`
	Redis      RedisConfig      `yaml:"redis"`
	Log        LogConfig        `yaml:"log" validate:"required"`
	JWT        JWTConfig        `yaml:"jwt" validate:"required"`
	Upload     UploadConfig     `yaml:"upload"`
	Email      EmailConfig      `yaml:"email"`
	Cache      CacheConfig      `yaml:"cache"`
	RateLimit  RateLimitConfig  `yaml:"rate_limit"`
	Monitoring MonitoringConfig `yaml:"monitoring"`
}

// AppConfig 应用基础配置
type AppConfig struct {
	Name        string `yaml:"name" validate:"required"`
	Version     string `yaml:"version" validate:"required"`
	Environment string `yaml:"environment" validate:"required,oneof=development testing production"`
	Debug       bool   `yaml:"debug"`
	Timezone    string `yaml:"timezone" validate:"required"`
}

// ServicesConfig 服务配置
type ServicesConfig struct {
	User   ServiceConfig `yaml:"user" validate:"required"`
	Movie  ServiceConfig `yaml:"movie" validate:"required"`
	Rating ServiceConfig `yaml:"rating" validate:"required"`
	Web    WebConfig     `yaml:"web" validate:"required"`
}

// ServiceConfig 单个服务配置
type ServiceConfig struct {
	Host    string        `yaml:"host" validate:"required"`
	Port    int           `yaml:"port" validate:"required,min=1,max=65535"`
	Timeout time.Duration `yaml:"timeout" validate:"required"`
}

// WebConfig Web服务配置
type WebConfig struct {
	ServiceConfig `yaml:",inline"`
	ReadTimeout   time.Duration `yaml:"read_timeout"`
	WriteTimeout  time.Duration `yaml:"write_timeout"`
	IdleTimeout   time.Duration `yaml:"idle_timeout"`
}

// DatabaseConfig 数据库配置
type DatabaseConfig struct {
	Driver          string        `yaml:"driver" validate:"required"`
	Host            string        `yaml:"host" validate:"required"`
	Port            int           `yaml:"port" validate:"required,min=1,max=65535"`
	Username        string        `yaml:"username" validate:"required"`
	Password        string        `yaml:"password"`
	Database        string        `yaml:"database" validate:"required"`
	Charset         string        `yaml:"charset"`
	ParseTime       bool          `yaml:"parse_time"`
	Loc             string        `yaml:"loc"`
	MaxOpenConns    int           `yaml:"max_open_conns" validate:"min=1"`
	MaxIdleConns    int           `yaml:"max_idle_conns" validate:"min=1"`
	ConnMaxLifetime time.Duration `yaml:"conn_max_lifetime"`
	ConnMaxIdleTime time.Duration `yaml:"conn_max_idle_time"`
	LogLevel        string        `yaml:"log_level" validate:"oneof=debug info warn error"`
	SlowThreshold   time.Duration `yaml:"slow_threshold"`
}

// RedisConfig Redis配置
type RedisConfig struct {
	Host         string        `yaml:"host" validate:"required"`
	Port         int           `yaml:"port" validate:"required,min=1,max=65535"`
	Password     string        `yaml:"password"`
	Database     int           `yaml:"database" validate:"min=0"`
	PoolSize     int           `yaml:"pool_size" validate:"min=1"`
	MinIdleConns int           `yaml:"min_idle_conns" validate:"min=0"`
	DialTimeout  time.Duration `yaml:"dial_timeout"`
	ReadTimeout  time.Duration `yaml:"read_timeout"`
	WriteTimeout time.Duration `yaml:"write_timeout"`
	PoolTimeout  time.Duration `yaml:"pool_timeout"`
	IdleTimeout  time.Duration `yaml:"idle_timeout"`
}

// LogConfig 日志配置
type LogConfig struct {
	Level      string `yaml:"level" validate:"required,oneof=debug info warn error"`
	Format     string `yaml:"format" validate:"required,oneof=json text"`
	Output     string `yaml:"output" validate:"required,oneof=stdout stderr file"`
	FilePath   string `yaml:"file_path"`
	MaxSize    int    `yaml:"max_size" validate:"min=1"`
	MaxBackups int    `yaml:"max_backups" validate:"min=0"`
	MaxAge     int    `yaml:"max_age" validate:"min=1"`
	Compress   bool   `yaml:"compress"`
}

// JWTConfig JWT配置
type JWTConfig struct {
	Secret            string        `yaml:"secret"`
	ExpireTime        time.Duration `yaml:"expire_time" validate:"required"`
	RefreshExpireTime time.Duration `yaml:"refresh_expire_time" validate:"required"`
	Issuer            string        `yaml:"issuer" validate:"required"`
}

// UploadConfig 文件上传配置
type UploadConfig struct {
	MaxSize      string   `yaml:"max_size" validate:"required"`
	AllowedTypes []string `yaml:"allowed_types" validate:"required,min=1"`
	UploadPath   string   `yaml:"upload_path" validate:"required"`
	URLPrefix    string   `yaml:"url_prefix" validate:"required"`
}

// EmailConfig 邮件配置
type EmailConfig struct {
	SMTPHost  string `yaml:"smtp_host" validate:"required"`
	SMTPPort  int    `yaml:"smtp_port" validate:"required,min=1,max=65535"`
	Username  string `yaml:"username"`
	Password  string `yaml:"password"`
	FromEmail string `yaml:"from_email" validate:"required,email"`
	FromName  string `yaml:"from_name" validate:"required"`
}

// CacheConfig 缓存配置
type CacheConfig struct {
	DefaultExpire   time.Duration `yaml:"default_expire" validate:"required"`
	CleanupInterval time.Duration `yaml:"cleanup_interval" validate:"required"`
}

// RateLimitConfig 限流配置
type RateLimitConfig struct {
	Enabled           bool `yaml:"enabled"`
	RequestsPerMinute int  `yaml:"requests_per_minute" validate:"min=1"`
	Burst             int  `yaml:"burst" validate:"min=1"`
}

// MonitoringConfig 监控配置
type MonitoringConfig struct {
	Metrics MetricsConfig `yaml:"metrics"`
	Health  HealthConfig  `yaml:"health"`
	Pprof   PprofConfig   `yaml:"pprof"`
}

// MetricsConfig 指标配置
type MetricsConfig struct {
	Enabled bool   `yaml:"enabled"`
	Path    string `yaml:"path" validate:"required"`
}

// HealthConfig 健康检查配置
type HealthConfig struct {
	Enabled bool   `yaml:"enabled"`
	Path    string `yaml:"path" validate:"required"`
}

// PprofConfig 性能分析配置
type PprofConfig struct {
	Enabled bool   `yaml:"enabled"`
	Path    string `yaml:"path" validate:"required"`
}
```

#### 2.2 实现配置加载器

```go
// pkg/config/loader.go
package config

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/go-playground/validator/v10"
	"github.com/spf13/viper"
)

// Loader 配置加载器
type Loader struct {
	validator *validator.Validate
}

// NewLoader 创建配置加载器
func NewLoader() *Loader {
	return &Loader{
		validator: validator.New(),
	}
}

// Load 加载配置
func (l *Loader) Load(configPath string) (*Config, error) {
	// 设置配置文件路径
	if configPath == "" {
		configPath = "configs"
	}

	// 初始化 Viper
	v := viper.New()
	v.SetConfigName("config")
	v.SetConfigType("yaml")
	v.AddConfigPath(configPath)

	// 设置环境变量前缀
	v.SetEnvPrefix("MOVIEINFO")
	v.AutomaticEnv()
	v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

	// 读取主配置文件
	if err := v.ReadInConfig(); err != nil {
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}

	// 获取环境
	env := v.GetString("app.environment")
	if envFromEnv := os.Getenv("MOVIEINFO_APP_ENVIRONMENT"); envFromEnv != "" {
		env = envFromEnv
	}

	// 加载环境特定配置
	if env != "" {
		envConfigPath := filepath.Join(configPath, "environments", env+".yaml")
		if _, err := os.Stat(envConfigPath); err == nil {
			v.SetConfigFile(envConfigPath)
			if err := v.MergeInConfig(); err != nil {
				return nil, fmt.Errorf("failed to merge environment config: %w", err)
			}
		}
	}

	// 绑定环境变量
	l.bindEnvVars(v)

	// 解析配置
	var config Config
	if err := v.Unmarshal(&config); err != nil {
		return nil, fmt.Errorf("failed to unmarshal config: %w", err)
	}

	// 处理敏感信息
	l.processSensitiveData(&config)

	// 验证配置
	if err := l.validator.Struct(&config); err != nil {
		return nil, fmt.Errorf("config validation failed: %w", err)
	}

	return &config, nil
}

// bindEnvVars 绑定环境变量
func (l *Loader) bindEnvVars(v *viper.Viper) {
	// 数据库密码
	v.BindEnv("database.password", "MOVIEINFO_DATABASE_PASSWORD")
	
	// Redis密码
	v.BindEnv("redis.password", "MOVIEINFO_REDIS_PASSWORD")
	
	// JWT密钥
	v.BindEnv("jwt.secret", "MOVIEINFO_JWT_SECRET")
	
	// 邮件配置
	v.BindEnv("email.username", "MOVIEINFO_EMAIL_USERNAME")
	v.BindEnv("email.password", "MOVIEINFO_EMAIL_PASSWORD")
}

// processSensitiveData 处理敏感数据
func (l *Loader) processSensitiveData(config *Config) {
	// 如果JWT密钥为空，生成一个警告
	if config.JWT.Secret == "" {
		fmt.Println("Warning: JWT secret is empty, please set MOVIEINFO_JWT_SECRET environment variable")
	}
	
	// 如果数据库密码为空，生成一个警告
	if config.Database.Password == "" {
		fmt.Println("Warning: Database password is empty, please set MOVIEINFO_DATABASE_PASSWORD environment variable")
	}
}

// LoadWithDefaults 加载配置并应用默认值
func (l *Loader) LoadWithDefaults(configPath string) (*Config, error) {
	config, err := l.Load(configPath)
	if err != nil {
		return nil, err
	}

	// 应用默认值
	l.applyDefaults(config)

	return config, nil
}

// applyDefaults 应用默认值
func (l *Loader) applyDefaults(config *Config) {
	// 数据库默认值
	if config.Database.Charset == "" {
		config.Database.Charset = "utf8mb4"
	}
	if config.Database.Loc == "" {
		config.Database.Loc = "Local"
	}
	if config.Database.MaxOpenConns == 0 {
		config.Database.MaxOpenConns = 100
	}
	if config.Database.MaxIdleConns == 0 {
		config.Database.MaxIdleConns = 10
	}

	// Redis默认值
	if config.Redis.PoolSize == 0 {
		config.Redis.PoolSize = 10
	}
	if config.Redis.MinIdleConns == 0 {
		config.Redis.MinIdleConns = 5
	}

	// 日志默认值
	if config.Log.MaxSize == 0 {
		config.Log.MaxSize = 100
	}
	if config.Log.MaxBackups == 0 {
		config.Log.MaxBackups = 10
	}
	if config.Log.MaxAge == 0 {
		config.Log.MaxAge = 30
	}
}
```

#### 2.3 实现配置管理器

```go
// pkg/config/manager.go
package config

import (
	"fmt"
	"sync"
	"time"

	"github.com/fsnotify/fsnotify"
)

// Manager 配置管理器
type Manager struct {
	config     *Config
	loader     *Loader
	configPath string
	mu         sync.RWMutex
	watcher    *fsnotify.Watcher
	callbacks  []func(*Config)
}

// NewManager 创建配置管理器
func NewManager(configPath string) (*Manager, error) {
	loader := NewLoader()
	config, err := loader.LoadWithDefaults(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load config: %w", err)
	}

	return &Manager{
		config:     config,
		loader:     loader,
		configPath: configPath,
		callbacks:  make([]func(*Config), 0),
	}, nil
}

// Get 获取配置
func (m *Manager) Get() *Config {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.config
}

// Reload 重新加载配置
func (m *Manager) Reload() error {
	newConfig, err := m.loader.LoadWithDefaults(m.configPath)
	if err != nil {
		return fmt.Errorf("failed to reload config: %w", err)
	}

	m.mu.Lock()
	oldConfig := m.config
	m.config = newConfig
	m.mu.Unlock()

	// 通知回调函数
	for _, callback := range m.callbacks {
		go callback(newConfig)
	}

	fmt.Printf("Config reloaded successfully at %s\n", time.Now().Format(time.RFC3339))
	_ = oldConfig // 避免未使用变量警告

	return nil
}

// OnConfigChange 注册配置变更回调
func (m *Manager) OnConfigChange(callback func(*Config)) {
	m.callbacks = append(m.callbacks, callback)
}

// StartWatching 开始监听配置文件变化
func (m *Manager) StartWatching() error {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		return fmt.Errorf("failed to create file watcher: %w", err)
	}

	m.watcher = watcher

	// 添加配置文件到监听列表
	err = watcher.Add(m.configPath)
	if err != nil {
		return fmt.Errorf("failed to watch config path: %w", err)
	}

	// 启动监听协程
	go m.watchLoop()

	fmt.Println("Started watching config files for changes")
	return nil
}

// StopWatching 停止监听配置文件变化
func (m *Manager) StopWatching() error {
	if m.watcher != nil {
		return m.watcher.Close()
	}
	return nil
}

// watchLoop 监听循环
func (m *Manager) watchLoop() {
	for {
		select {
		case event, ok := <-m.watcher.Events:
			if !ok {
				return
			}
			if event.Op&fsnotify.Write == fsnotify.Write {
				fmt.Printf("Config file modified: %s\n", event.Name)
				// 延迟重新加载，避免频繁更新
				time.Sleep(100 * time.Millisecond)
				if err := m.Reload(); err != nil {
					fmt.Printf("Failed to reload config: %v\n", err)
				}
			}
		case err, ok := <-m.watcher.Errors:
			if !ok {
				return
			}
			fmt.Printf("Config watcher error: %v\n", err)
		}
	}
}

// GetDSN 获取数据库连接字符串
func (m *Manager) GetDSN() string {
	config := m.Get()
	db := config.Database
	return fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=%s&parseTime=%t&loc=%s",
		db.Username,
		db.Password,
		db.Host,
		db.Port,
		db.Database,
		db.Charset,
		db.ParseTime,
		db.Loc,
	)
}

// GetRedisAddr 获取Redis地址
func (m *Manager) GetRedisAddr() string {
	config := m.Get()
	return fmt.Sprintf("%s:%d", config.Redis.Host, config.Redis.Port)
}

// IsProduction 判断是否为生产环境
func (m *Manager) IsProduction() bool {
	return m.Get().App.Environment == "production"
}

// IsDevelopment 判断是否为开发环境
func (m *Manager) IsDevelopment() bool {
	return m.Get().App.Environment == "development"
}

// IsTesting 判断是否为测试环境
func (m *Manager) IsTesting() bool {
	return m.Get().App.Environment == "testing"
}
```

### 步骤3：创建配置工具函数

#### 3.1 创建配置辅助函数

```go
// pkg/config/utils.go
package config

import (
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"
)

// GetEnvString 获取字符串环境变量
func GetEnvString(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

// GetEnvInt 获取整数环境变量
func GetEnvInt(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		if intValue, err := strconv.Atoi(value); err == nil {
			return intValue
		}
	}
	return defaultValue
}

// GetEnvBool 获取布尔环境变量
func GetEnvBool(key string, defaultValue bool) bool {
	if value := os.Getenv(key); value != "" {
		if boolValue, err := strconv.ParseBool(value); err == nil {
			return boolValue
		}
	}
	return defaultValue
}

// GetEnvDuration 获取时间间隔环境变量
func GetEnvDuration(key string, defaultValue time.Duration) time.Duration {
	if value := os.Getenv(key); value != "" {
		if duration, err := time.ParseDuration(value); err == nil {
			return duration
		}
	}
	return defaultValue
}

// GetEnvStringSlice 获取字符串切片环境变量
func GetEnvStringSlice(key string, defaultValue []string, separator string) []string {
	if value := os.Getenv(key); value != "" {
		return strings.Split(value, separator)
	}
	return defaultValue
}

// ValidateConfig 验证配置
func ValidateConfig(config *Config) error {
	var errors []string

	// 验证必需的环境变量
	if config.JWT.Secret == "" {
		errors = append(errors, "JWT secret is required")
	}

	if config.Database.Password == "" && !strings.Contains(config.App.Environment, "test") {
		errors = append(errors, "Database password is required for non-test environments")
	}

	// 验证端口范围
	ports := []int{
		config.Services.User.Port,
		config.Services.Movie.Port,
		config.Services.Rating.Port,
		config.Services.Web.Port,
		config.Database.Port,
		config.Redis.Port,
	}

	for _, port := range ports {
		if port < 1 || port > 65535 {
			errors = append(errors, fmt.Sprintf("Invalid port: %d", port))
		}
	}

	// 验证日志级别
	validLogLevels := []string{"debug", "info", "warn", "error"}
	if !contains(validLogLevels, config.Log.Level) {
		errors = append(errors, fmt.Sprintf("Invalid log level: %s", config.Log.Level))
	}

	if len(errors) > 0 {
		return fmt.Errorf("config validation errors: %s", strings.Join(errors, ", "))
	}

	return nil
}

// contains 检查切片是否包含指定元素
func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

// PrintConfig 打印配置信息（隐藏敏感信息）
func PrintConfig(config *Config) {
	fmt.Println("=== MovieInfo Configuration ===")
	fmt.Printf("App Name: %s\n", config.App.Name)
	fmt.Printf("Version: %s\n", config.App.Version)
	fmt.Printf("Environment: %s\n", config.App.Environment)
	fmt.Printf("Debug Mode: %t\n", config.App.Debug)
	fmt.Printf("Timezone: %s\n", config.App.Timezone)
	fmt.Println()

	fmt.Println("=== Services ===")
	fmt.Printf("User Service: %s:%d\n", config.Services.User.Host, config.Services.User.Port)
	fmt.Printf("Movie Service: %s:%d\n", config.Services.Movie.Host, config.Services.Movie.Port)
	fmt.Printf("Rating Service: %s:%d\n", config.Services.Rating.Host, config.Services.Rating.Port)
	fmt.Printf("Web Service: %s:%d\n", config.Services.Web.Host, config.Services.Web.Port)
	fmt.Println()

	fmt.Println("=== Database ===")
	fmt.Printf("Driver: %s\n", config.Database.Driver)
	fmt.Printf("Host: %s:%d\n", config.Database.Host, config.Database.Port)
	fmt.Printf("Database: %s\n", config.Database.Database)
	fmt.Printf("Username: %s\n", config.Database.Username)
	fmt.Printf("Password: %s\n", maskPassword(config.Database.Password))
	fmt.Println()

	fmt.Println("=== Redis ===")
	fmt.Printf("Host: %s:%d\n", config.Redis.Host, config.Redis.Port)
	fmt.Printf("Database: %d\n", config.Redis.Database)
	fmt.Printf("Password: %s\n", maskPassword(config.Redis.Password))
	fmt.Println()

	fmt.Println("=== Log ===")
	fmt.Printf("Level: %s\n", config.Log.Level)
	fmt.Printf("Format: %s\n", config.Log.Format)
	fmt.Printf("Output: %s\n", config.Log.Output)
	if config.Log.Output == "file" {
		fmt.Printf("File Path: %s\n", config.Log.FilePath)
	}
	fmt.Println()

	fmt.Println("=== JWT ===")
	fmt.Printf("Secret: %s\n", maskPassword(config.JWT.Secret))
	fmt.Printf("Expire Time: %s\n", config.JWT.ExpireTime)
	fmt.Printf("Refresh Expire Time: %s\n", config.JWT.RefreshExpireTime)
	fmt.Printf("Issuer: %s\n", config.JWT.Issuer)
	fmt.Println()
}

// maskPassword 隐藏密码
func maskPassword(password string) string {
	if password == "" {
		return "<empty>"
	}
	if len(password) <= 4 {
		return "****"
	}
	return password[:2] + "****" + password[len(password)-2:]
}
```

### 步骤4：创建配置初始化脚本

#### 4.1 创建环境变量模板

```bash
# configs/templates/.env.example
# MovieInfo 环境变量配置模板
# 复制此文件为 .env 并填入实际值

# 应用环境
MOVIEINFO_APP_ENVIRONMENT=development

# 数据库配置
MOVIEINFO_DATABASE_PASSWORD=your_database_password

# Redis配置
MOVIEINFO_REDIS_PASSWORD=your_redis_password

# JWT配置
MOVIEINFO_JWT_SECRET=your_jwt_secret_key_at_least_32_characters

# 邮件配置
MOVIEINFO_EMAIL_USERNAME=your_email@gmail.com
MOVIEINFO_EMAIL_PASSWORD=your_email_password

# 可选：覆盖默认配置
# MOVIEINFO_SERVICES_WEB_PORT=8080
# MOVIEINFO_DATABASE_HOST=localhost
# MOVIEINFO_DATABASE_PORT=3306
# MOVIEINFO_REDIS_HOST=localhost
# MOVIEINFO_REDIS_PORT=6379
```

#### 4.2 创建配置验证脚本

```go
// cmd/config-validator/main.go
package main

import (
	"flag"
	"fmt"
	"os"

	"movieinfo/pkg/config"
)

func main() {
	configPath := flag.String("config", "configs", "配置文件路径")
	verbose := flag.Bool("verbose", false, "详细输出")
	flag.Parse()

	fmt.Println("MovieInfo 配置验证工具")
	fmt.Println("=====================")

	// 加载配置
	manager, err := config.NewManager(*configPath)
	if err != nil {
		fmt.Printf("❌ 配置加载失败: %v\n", err)
		os.Exit(1)
	}

	cfg := manager.Get()

	// 验证配置
	if err := config.ValidateConfig(cfg); err != nil {
		fmt.Printf("❌ 配置验证失败: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("✅ 配置验证通过")

	if *verbose {
		fmt.Println()
		config.PrintConfig(cfg)
	}

	fmt.Println()
	fmt.Println("配置摘要:")
	fmt.Printf("- 应用名称: %s\n", cfg.App.Name)
	fmt.Printf("- 版本: %s\n", cfg.App.Version)
	fmt.Printf("- 环境: %s\n", cfg.App.Environment)
	fmt.Printf("- 调试模式: %t\n", cfg.App.Debug)
	fmt.Printf("- Web服务端口: %d\n", cfg.Services.Web.Port)
	fmt.Printf("- 数据库: %s@%s:%d/%s\n", cfg.Database.Username, cfg.Database.Host, cfg.Database.Port, cfg.Database.Database)
	fmt.Printf("- Redis: %s:%d/%d\n", cfg.Redis.Host, cfg.Redis.Port, cfg.Redis.Database)
	fmt.Printf("- 日志级别: %s\n", cfg.Log.Level)
}
```

### 步骤5：创建配置测试

#### 5.1 创建配置测试文件

```go
// pkg/config/config_test.go
package config

import (
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestLoader_Load(t *testing.T) {
	// 创建临时配置文件
	tempDir := t.TempDir()
	configContent := `
app:
  name: "test-app"
  version: "1.0.0"
  environment: "testing"
  debug: true
  timezone: "UTC"

services:
  user:
    host: "localhost"
    port: 8081
    timeout: "30s"
  movie:
    host: "localhost"
    port: 8082
    timeout: "30s"
  rating:
    host: "localhost"
    port: 8083
    timeout: "30s"
  web:
    host: "localhost"
    port: 8080
    timeout: "30s"
    read_timeout: "10s"
    write_timeout: "10s"
    idle_timeout: "60s"

database:
  driver: "mysql"
  host: "localhost"
  port: 3306
  username: "test_user"
  password: "test_password"
  database: "test_db"
  charset: "utf8mb4"
  parse_time: true
  loc: "Local"
  max_open_conns: 10
  max_idle_conns: 5
  conn_max_lifetime: "1h"
  conn_max_idle_time: "30m"
  log_level: "info"
  slow_threshold: "200ms"

redis:
  host: "localhost"
  port: 6379
  password: ""
  database: 0
  pool_size: 10
  min_idle_conns: 5
  dial_timeout: "5s"
  read_timeout: "3s"
  write_timeout: "3s"
  pool_timeout: "4s"
  idle_timeout: "5m"

log:
  level: "info"
  format: "json"
  output: "stdout"
  max_size: 100
  max_backups: 10
  max_age: 30
  compress: true

jwt:
  secret: "test_secret_key_32_characters_long"
  expire_time: "24h"
  refresh_expire_time: "168h"
  issuer: "test-app"

upload:
  max_size: "10MB"
  allowed_types:
    - "image/jpeg"
    - "image/png"
  upload_path: "uploads"
  url_prefix: "/static/uploads"

email:
  smtp_host: "smtp.test.com"
  smtp_port: 587
  username: "test@test.com"
  password: "test_password"
  from_email: "noreply@test.com"
  from_name: "Test App"

cache:
  default_expire: "1h"
  cleanup_interval: "10m"

rate_limit:
  enabled: true
  requests_per_minute: 60
  burst: 10

monitoring:
  metrics:
    enabled: true
    path: "/metrics"
  health:
    enabled: true
    path: "/health"
  pprof:
    enabled: false
    path: "/debug/pprof"
`

	// 写入配置文件
	configFile := filepath.Join(tempDir, "config.yaml")
	err := os.WriteFile(configFile, []byte(configContent), 0644)
	require.NoError(t, err)

	// 测试加载配置
	loader := NewLoader()
	config, err := loader.Load(tempDir)
	require.NoError(t, err)
	require.NotNil(t, config)

	// 验证配置内容
	assert.Equal(t, "test-app", config.App.Name)
	assert.Equal(t, "1.0.0", config.App.Version)
	assert.Equal(t, "testing", config.App.Environment)
	assert.True(t, config.App.Debug)
	assert.Equal(t, "UTC", config.App.Timezone)

	// 验证服务配置
	assert.Equal(t, "localhost", config.Services.User.Host)
	assert.Equal(t, 8081, config.Services.User.Port)
	assert.Equal(t, 30*time.Second, config.Services.User.Timeout)

	// 验证数据库配置
	assert.Equal(t, "mysql", config.Database.Driver)
	assert.Equal(t, "localhost", config.Database.Host)
	assert.Equal(t, 3306, config.Database.Port)
	assert.Equal(t, "test_user", config.Database.Username)
	assert.Equal(t, "test_password", config.Database.Password)
	assert.Equal(t, "test_db", config.Database.Database)

	// 验证JWT配置
	assert.Equal(t, "test_secret_key_32_characters_long", config.JWT.Secret)
	assert.Equal(t, 24*time.Hour, config.JWT.ExpireTime)
	assert.Equal(t, "test-app", config.JWT.Issuer)
}

func TestManager_Reload(t *testing.T) {
	// 创建临时配置文件
	tempDir := t.TempDir()
	configContent := `
app:
  name: "test-app"
  version: "1.0.0"
  environment: "testing"
  debug: true
  timezone: "UTC"

services:
  user:
    host: "localhost"
    port: 8081
    timeout: "30s"
  movie:
    host: "localhost"
    port: 8082
    timeout: "30s"
  rating:
    host: "localhost"
    port: 8083
    timeout: "30s"
  web:
    host: "localhost"
    port: 8080
    timeout: "30s"
    read_timeout: "10s"
    write_timeout: "10s"
    idle_timeout: "60s"

database:
  driver: "mysql"
  host: "localhost"
  port: 3306
  username: "test_user"
  password: "test_password"
  database: "test_db"
  max_open_conns: 10
  max_idle_conns: 5
  log_level: "info"

redis:
  host: "localhost"
  port: 6379
  database: 0
  pool_size: 10
  min_idle_conns: 5

log:
  level: "info"
  format: "json"
  output: "stdout"
  max_size: 100
  max_backups: 10
  max_age: 30
  compress: true

jwt:
  secret: "test_secret_key_32_characters_long"
  expire_time: "24h"
  refresh_expire_time: "168h"
  issuer: "test-app"

upload:
  max_size: "10MB"
  allowed_types:
    - "image/jpeg"
  upload_path: "uploads"
  url_prefix: "/static/uploads"

email:
  smtp_host: "smtp.test.com"
  smtp_port: 587
  from_email: "noreply@test.com"
  from_name: "Test App"

cache:
  default_expire: "1h"
  cleanup_interval: "10m"

rate_limit:
  enabled: true
  requests_per_minute: 60
  burst: 10

monitoring:
  metrics:
    enabled: true
    path: "/metrics"
  health:
    enabled: true
    path: "/health"
  pprof:
    enabled: false
    path: "/debug/pprof"
`

	// 写入配置文件
	configFile := filepath.Join(tempDir, "config.yaml")
	err := os.WriteFile(configFile, []byte(configContent), 0644)
	require.NoError(t, err)

	// 创建配置管理器
	manager, err := NewManager(tempDir)
	require.NoError(t, err)

	// 验证初始配置
	config := manager.Get()
	assert.Equal(t, "info", config.Log.Level)

	// 修改配置文件
	newConfigContent := configContent + "\nlog:\n  level: \"debug\""
	err = os.WriteFile(configFile, []byte(newConfigContent), 0644)
	require.NoError(t, err)

	// 重新加载配置
	err = manager.Reload()
	require.NoError(t, err)

	// 验证配置已更新
	updatedConfig := manager.Get()
	assert.Equal(t, "debug", updatedConfig.Log.Level)
}

func TestValidateConfig(t *testing.T) {
	tests := []struct {
		name    string
		config  *Config
		wantErr bool
	}{
		{
			name: "valid config",
			config: &Config{
				App: AppConfig{
					Name:        "test",
					Version:     "1.0.0",
					Environment: "testing",
					Timezone:    "UTC",
				},
				JWT: JWTConfig{
					Secret: "test_secret_key_32_characters_long",
				},
				Database: DatabaseConfig{
					Password: "test_password",
					Port:     3306,
				},
				Services: ServicesConfig{
					User:   ServiceConfig{Port: 8081},
					Movie:  ServiceConfig{Port: 8082},
					Rating: ServiceConfig{Port: 8083},
					Web:    WebConfig{ServiceConfig: ServiceConfig{Port: 8080}},
				},
				Redis: RedisConfig{Port: 6379},
				Log:   LogConfig{Level: "info"},
			},
			wantErr: false,
		},
		{
			name: "missing JWT secret",
			config: &Config{
				App: AppConfig{
					Environment: "production",
				},
				JWT: JWTConfig{
					Secret: "",
				},
				Database: DatabaseConfig{
					Password: "test_password",
					Port:     3306,
				},
				Services: ServicesConfig{
					User:   ServiceConfig{Port: 8081},
					Movie:  ServiceConfig{Port: 8082},
					Rating: ServiceConfig{Port: 8083},
					Web:    WebConfig{ServiceConfig: ServiceConfig{Port: 8080}},
				},
				Redis: RedisConfig{Port: 6379},
				Log:   LogConfig{Level: "info"},
			},
			wantErr: true,
		},
		{
			name: "invalid port",
			config: &Config{
				App: AppConfig{
					Environment: "testing",
				},
				JWT: JWTConfig{
					Secret: "test_secret",
				},
				Database: DatabaseConfig{
					Password: "test_password",
					Port:     99999,
				},
				Services: ServicesConfig{
					User:   ServiceConfig{Port: 8081},
					Movie:  ServiceConfig{Port: 8082},
					Rating: ServiceConfig{Port: 8083},
					Web:    WebConfig{ServiceConfig: ServiceConfig{Port: 8080}},
				},
				Redis: RedisConfig{Port: 6379},
				Log:   LogConfig{Level: "info"},
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := ValidateConfig(tt.config)
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestGetEnvFunctions(t *testing.T) {
	// 测试字符串环境变量
	os.Setenv("TEST_STRING", "test_value")
	assert.Equal(t, "test_value", GetEnvString("TEST_STRING", "default"))
	assert.Equal(t, "default", GetEnvString("NON_EXISTENT", "default"))

	// 测试整数环境变量
	os.Setenv("TEST_INT", "123")
	assert.Equal(t, 123, GetEnvInt("TEST_INT", 0))
	assert.Equal(t, 0, GetEnvInt("NON_EXISTENT_INT", 0))

	// 测试布尔环境变量
	os.Setenv("TEST_BOOL", "true")
	assert.True(t, GetEnvBool("TEST_BOOL", false))
	assert.False(t, GetEnvBool("NON_EXISTENT_BOOL", false))

	// 测试时间间隔环境变量
	os.Setenv("TEST_DURATION", "5m")
	assert.Equal(t, 5*time.Minute, GetEnvDuration("TEST_DURATION", time.Second))
	assert.Equal(t, time.Second, GetEnvDuration("NON_EXISTENT_DURATION", time.Second))

	// 清理环境变量
	os.Unsetenv("TEST_STRING")
	os.Unsetenv("TEST_INT")
	os.Unsetenv("TEST_BOOL")
	os.Unsetenv("TEST_DURATION")
}
```

## 代码示例

### 在应用中使用配置管理器

```go
// cmd/web/main.go
package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"movieinfo/pkg/config"
)

func main() {
	// 加载配置
	manager, err := config.NewManager("configs")
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	cfg := manager.Get()

	// 打印配置信息
	if cfg.App.Debug {
		config.PrintConfig(cfg)
	}

	// 启动配置文件监听
	if err := manager.StartWatching(); err != nil {
		log.Printf("Failed to start config watching: %v", err)
	}
	defer manager.StopWatching()

	// 注册配置变更回调
	manager.OnConfigChange(func(newConfig *config.Config) {
		log.Printf("Config changed, new log level: %s", newConfig.Log.Level)
		// 这里可以重新初始化日志器等组件
	})

	// 创建HTTP服务器
	server := &http.Server{
		Addr:         fmt.Sprintf("%s:%d", cfg.Services.Web.Host, cfg.Services.Web.Port),
		ReadTimeout:  cfg.Services.Web.ReadTimeout,
		WriteTimeout: cfg.Services.Web.WriteTimeout,
		IdleTimeout:  cfg.Services.Web.IdleTimeout,
	}

	// 启动服务器
	go func() {
		log.Printf("Starting web server on %s", server.Addr)
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Server failed to start: %v", err)
		}
	}()

	// 等待中断信号
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	log.Println("Shutting down server...")

	// 优雅关闭
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	if err := server.Shutdown(ctx); err != nil {
		log.Fatalf("Server forced to shutdown: %v", err)
	}

	log.Println("Server exited")
}
```

### 在服务中使用配置

```go
// internal/user/service.go
package user

import (
	"database/sql"
	"fmt"

	"movieinfo/pkg/config"
)

type Service struct {
	db     *sql.DB
	config *config.Config
}

func NewService(manager *config.Manager) (*Service, error) {
	cfg := manager.Get()
	
	// 使用配置创建数据库连接
	dsn := manager.GetDSN()
	db, err := sql.Open(cfg.Database.Driver, dsn)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	// 配置连接池
	db.SetMaxOpenConns(cfg.Database.MaxOpenConns)
	db.SetMaxIdleConns(cfg.Database.MaxIdleConns)
	db.SetConnMaxLifetime(cfg.Database.ConnMaxLifetime)
	db.SetConnMaxIdleTime(cfg.Database.ConnMaxIdleTime)

	return &Service{
		db:     db,
		config: cfg,
	}, nil
}

func (s *Service) GetJWTConfig() config.JWTConfig {
	return s.config.JWT
}

func (s *Service) IsDebugMode() bool {
	return s.config.App.Debug
}
```

## 测试验证

### 验证步骤

1. **验证配置文件加载**：
   ```bash
   # 运行配置验证工具
   go run cmd/config-validator/main.go -config configs -verbose
   ```

2. **验证环境变量覆盖**：
   ```bash
   # 设置环境变量
   export MOVIEINFO_APP_ENVIRONMENT=production
   export MOVIEINFO_DATABASE_PASSWORD=secure_password
   export MOVIEINFO_JWT_SECRET=very_secure_jwt_secret_key_32_chars
   
   # 运行验证
   go run cmd/config-validator/main.go -config configs -verbose
   ```

3. **验证配置热更新**：
   ```bash
   # 启动应用
   go run cmd/web/main.go
   
   # 在另一个终端修改配置文件
   echo "log:\n  level: debug" >> configs/config.yaml
   
   # 观察应用日志，应该看到配置重新加载的消息
   ```

4. **验证多环境配置**：
   ```bash
   # 测试开发环境
   MOVIEINFO_APP_ENVIRONMENT=development go run cmd/config-validator/main.go
   
   # 测试生产环境
   MOVIEINFO_APP_ENVIRONMENT=production go run cmd/config-validator/main.go
   ```

5. **运行单元测试**：
   ```bash
   # 运行配置相关测试
   go test ./pkg/config/... -v
   
   # 运行所有测试
   go test ./... -v
   ```

### 预期结果

- 配置文件成功加载，所有字段正确解析
- 环境变量能够正确覆盖配置文件中的值
- 配置验证能够捕获无效配置
- 配置热更新功能正常工作
- 多环境配置能够正确合并
- 所有单元测试通过

## 注意事项

### 安全性注意事项

1. **敏感信息管理**：
   - 永远不要将密码、密钥等敏感信息写入配置文件
   - 使用环境变量传递敏感信息
   - 在生产环境中使用密钥管理服务

2. **配置文件权限**：
   - 设置适当的文件权限，防止未授权访问
   - 在容器环境中使用 secrets 管理敏感配置

3. **配置验证**：
   - 始终验证配置的有效性
   - 为关键配置项设置合理的默认值
   - 在应用启动时进行配置检查

### 性能注意事项

1. **配置缓存**：
   - 配置管理器内部缓存配置，避免重复解析
   - 使用读写锁保证并发安全

2. **热更新频率**：
   - 避免过于频繁的配置更新
   - 实现配置更新的防抖机制

3. **内存使用**：
   - 合理控制配置文件大小
   - 避免在配置中存储大量数据

### 维护性注意事项

1. **配置结构设计**：
   - 保持配置结构的清晰和一致性
   - 为新增配置项提供向后兼容性
   - 使用有意义的配置项名称

2. **文档维护**：
   - 及时更新配置文档
   - 为每个配置项提供清晰的说明
   - 维护配置示例文件

3. **版本管理**：
   - 对配置文件进行版本控制
   - 记录配置变更历史
   - 提供配置迁移指南

## 下一步骤

完成配置管理系统后，下一步将进行日志系统开发（04-日志系统.md）。在开始下一步之前，请确保：

1. ✅ 配置文件结构设计完成
2. ✅ 配置加载器实现完成
3. ✅ 配置管理器实现完成
4. ✅ 环境变量支持实现
5. ✅ 配置验证功能实现
6. ✅ 配置热更新功能实现
7. ✅ 多环境配置支持实现
8. ✅ 配置工具和测试完成

**下一步预告**：
在日志系统阶段，我们将：
- 设计统一的日志格式和级别
- 实现结构化日志记录
- 支持多种日志输出方式
- 集成日志轮转和归档
- 实现日志性能优化
- 提供日志分析和监控接口

**检查清单**：
- [ ] 配置文件是否能正确加载
- [ ] 环境变量是否能正确覆盖配置
- [ ] 配置验证是否正常工作
- [ ] 配置热更新是否正常工作
- [ ] 多环境配置是否正确合并
- [ ] 敏感信息是否通过环境变量管理
- [ ] 配置工具是否可用
- [ ] 单元测试是否全部通过

完成以上检查后，即可进入下一个开发阶段。