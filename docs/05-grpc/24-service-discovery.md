# ç¬¬24æ­¥ï¼šæœåŠ¡æ³¨å†Œä¸å‘ç°

## ğŸ“‹ æ¦‚è¿°

æœåŠ¡æ³¨å†Œä¸å‘ç°æ˜¯å¾®æœåŠ¡æ¶æ„çš„æ ¸å¿ƒç»„ä»¶ï¼Œå®ƒè§£å†³äº†æœåŠ¡é—´å¦‚ä½•æ‰¾åˆ°å½¼æ­¤çš„é—®é¢˜ã€‚å¯¹äºMovieInfoé¡¹ç›®ï¼Œæˆ‘ä»¬éœ€è¦å®ç°ä¸€ä¸ªç®€å•è€Œæœ‰æ•ˆçš„æœåŠ¡å‘ç°æœºåˆ¶ï¼Œä¸ºæœªæ¥çš„å¾®æœåŠ¡åŒ–åšå¥½å‡†å¤‡ã€‚

## ğŸ¯ è®¾è®¡ç›®æ ‡

### 1. **æœåŠ¡è‡ªåŠ¨å‘ç°**
- æœåŠ¡å¯åŠ¨æ—¶è‡ªåŠ¨æ³¨å†Œ
- æœåŠ¡åœæ­¢æ—¶è‡ªåŠ¨æ³¨é”€
- åŠ¨æ€å‘ç°å¯ç”¨æœåŠ¡

### 2. **å¥åº·æ£€æŸ¥**
- å®šæœŸæ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€
- è‡ªåŠ¨å‰”é™¤ä¸å¥åº·æœåŠ¡
- æœåŠ¡æ¢å¤åè‡ªåŠ¨é‡æ–°åŠ å…¥

### 3. **è´Ÿè½½å‡è¡¡**
- æ”¯æŒå¤šç§è´Ÿè½½å‡è¡¡ç­–ç•¥
- åŠ¨æ€è°ƒæ•´æœåŠ¡æƒé‡
- æ•…éšœè½¬ç§»æœºåˆ¶

### 4. **é…ç½®ç®€å•**
- æœ€å°åŒ–é…ç½®è¦æ±‚
- æ”¯æŒå¤šç§éƒ¨ç½²ç¯å¢ƒ
- æ˜“äºé›†æˆå’Œä½¿ç”¨

## ğŸ—ï¸ æœåŠ¡å‘ç°æ¶æ„

### 1. **æ•´ä½“æ¶æ„**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æœåŠ¡å‘ç°æ¶æ„                              â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  ä¸»é¡µæœåŠ¡    â”‚  â”‚  ç”¨æˆ·æœåŠ¡    â”‚  â”‚  ç”µå½±æœåŠ¡    â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ â€¢ æœåŠ¡æ¶ˆè´¹è€… â”‚  â”‚ â€¢ æœåŠ¡æä¾›è€… â”‚  â”‚ â€¢ æœåŠ¡æä¾›è€… â”‚          â”‚
â”‚  â”‚ â€¢ è´Ÿè½½å‡è¡¡   â”‚  â”‚ â€¢ å¥åº·æ£€æŸ¥   â”‚  â”‚ â€¢ å¥åº·æ£€æŸ¥   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚                 â”‚                 â”‚               â”‚
â”‚         â”‚                 â”‚                 â”‚               â”‚
â”‚         â–¼                 â–¼                 â–¼               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              æœåŠ¡æ³¨å†Œä¸­å¿ƒ                                â”‚ â”‚
â”‚  â”‚                                                         â”‚ â”‚
â”‚  â”‚ â€¢ æœåŠ¡æ³¨å†Œ    â€¢ æœåŠ¡å‘ç°    â€¢ å¥åº·æ£€æŸ¥    â€¢ è´Ÿè½½å‡è¡¡     â”‚ â”‚
â”‚  â”‚ â€¢ é…ç½®ç®¡ç†    â€¢ äº‹ä»¶é€šçŸ¥    â€¢ æ•…éšœè½¬ç§»    â€¢ ç›‘æ§ç»Ÿè®¡     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. **æœåŠ¡æ³¨å†Œæµç¨‹**

```
æœåŠ¡å¯åŠ¨ â†’ è¯»å–é…ç½® â†’ æ³¨å†Œåˆ°æ³¨å†Œä¸­å¿ƒ â†’ å¯åŠ¨å¥åº·æ£€æŸ¥ â†’ å¼€å§‹æä¾›æœåŠ¡
    â†“           â†“           â†“             â†“             â†“
  åˆå§‹åŒ–     è·å–åœ°å€     å‘é€æ³¨å†Œè¯·æ±‚    å®šæœŸå¿ƒè·³      å¤„ç†è¯·æ±‚
```

### 3. **æœåŠ¡å‘ç°æµç¨‹**

```
å®¢æˆ·ç«¯å¯åŠ¨ â†’ æŸ¥è¯¢æ³¨å†Œä¸­å¿ƒ â†’ è·å–æœåŠ¡åˆ—è¡¨ â†’ é€‰æ‹©æœåŠ¡å®ä¾‹ â†’ å‘èµ·è°ƒç”¨
     â†“            â†“            â†“            â†“            â†“
   åˆå§‹åŒ–      å‘é€æŸ¥è¯¢è¯·æ±‚   ç¼“å­˜æœåŠ¡ä¿¡æ¯   è´Ÿè½½å‡è¡¡     å»ºç«‹è¿æ¥
```

## ğŸ”§ æ ¸å¿ƒç»„ä»¶å®ç°

### 1. **æœåŠ¡æ³¨å†Œä¸­å¿ƒ**

```go
// æœåŠ¡å®ä¾‹ä¿¡æ¯
type ServiceInstance struct {
    ID       string            `json:"id"`
    Name     string            `json:"name"`
    Address  string            `json:"address"`
    Port     int               `json:"port"`
    Tags     []string          `json:"tags"`
    Meta     map[string]string `json:"meta"`
    Health   HealthStatus      `json:"health"`
    LastSeen time.Time         `json:"last_seen"`
}

type HealthStatus string

const (
    HealthStatusHealthy   HealthStatus = "healthy"
    HealthStatusUnhealthy HealthStatus = "unhealthy"
    HealthStatusUnknown   HealthStatus = "unknown"
)

// æœåŠ¡æ³¨å†Œä¸­å¿ƒæ¥å£
type ServiceRegistry interface {
    Register(instance *ServiceInstance) error
    Deregister(serviceID string) error
    Discover(serviceName string) ([]*ServiceInstance, error)
    Watch(serviceName string) (<-chan []*ServiceInstance, error)
    HealthCheck(serviceID string) error
}

// å†…å­˜å®ç°çš„æœåŠ¡æ³¨å†Œä¸­å¿ƒ
type MemoryServiceRegistry struct {
    services map[string]map[string]*ServiceInstance // serviceName -> serviceID -> instance
    watchers map[string][]chan []*ServiceInstance   // serviceName -> watchers
    mutex    sync.RWMutex
    logger   *logrus.Logger
}

func NewMemoryServiceRegistry() *MemoryServiceRegistry {
    registry := &MemoryServiceRegistry{
        services: make(map[string]map[string]*ServiceInstance),
        watchers: make(map[string][]chan []*ServiceInstance),
        logger:   logrus.New(),
    }
    
    // å¯åŠ¨å¥åº·æ£€æŸ¥
    go registry.startHealthCheck()
    
    return registry
}

func (msr *MemoryServiceRegistry) Register(instance *ServiceInstance) error {
    msr.mutex.Lock()
    defer msr.mutex.Unlock()
    
    if msr.services[instance.Name] == nil {
        msr.services[instance.Name] = make(map[string]*ServiceInstance)
    }
    
    instance.LastSeen = time.Now()
    instance.Health = HealthStatusHealthy
    msr.services[instance.Name][instance.ID] = instance
    
    msr.logger.Infof("Service registered: %s (%s)", instance.Name, instance.ID)
    
    // é€šçŸ¥è§‚å¯Ÿè€…
    msr.notifyWatchers(instance.Name)
    
    return nil
}

func (msr *MemoryServiceRegistry) Deregister(serviceID string) error {
    msr.mutex.Lock()
    defer msr.mutex.Unlock()
    
    for serviceName, instances := range msr.services {
        if instance, exists := instances[serviceID]; exists {
            delete(instances, serviceID)
            msr.logger.Infof("Service deregistered: %s (%s)", serviceName, serviceID)
            
            // é€šçŸ¥è§‚å¯Ÿè€…
            msr.notifyWatchers(serviceName)
            return nil
        }
    }
    
    return fmt.Errorf("service not found: %s", serviceID)
}

func (msr *MemoryServiceRegistry) Discover(serviceName string) ([]*ServiceInstance, error) {
    msr.mutex.RLock()
    defer msr.mutex.RUnlock()
    
    instances := msr.services[serviceName]
    if instances == nil {
        return nil, fmt.Errorf("service not found: %s", serviceName)
    }
    
    var healthyInstances []*ServiceInstance
    for _, instance := range instances {
        if instance.Health == HealthStatusHealthy {
            healthyInstances = append(healthyInstances, instance)
        }
    }
    
    return healthyInstances, nil
}

func (msr *MemoryServiceRegistry) Watch(serviceName string) (<-chan []*ServiceInstance, error) {
    msr.mutex.Lock()
    defer msr.mutex.Unlock()
    
    watcher := make(chan []*ServiceInstance, 1)
    msr.watchers[serviceName] = append(msr.watchers[serviceName], watcher)
    
    // å‘é€å½“å‰çŠ¶æ€
    if instances, err := msr.Discover(serviceName); err == nil {
        select {
        case watcher <- instances:
        default:
        }
    }
    
    return watcher, nil
}

func (msr *MemoryServiceRegistry) notifyWatchers(serviceName string) {
    if watchers, exists := msr.watchers[serviceName]; exists {
        if instances, err := msr.Discover(serviceName); err == nil {
            for _, watcher := range watchers {
                select {
                case watcher <- instances:
                default:
                    // éé˜»å¡å‘é€
                }
            }
        }
    }
}

func (msr *MemoryServiceRegistry) startHealthCheck() {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        msr.performHealthCheck()
    }
}

func (msr *MemoryServiceRegistry) performHealthCheck() {
    msr.mutex.Lock()
    defer msr.mutex.Unlock()
    
    now := time.Now()
    for serviceName, instances := range msr.services {
        for serviceID, instance := range instances {
            // æ£€æŸ¥æœ€åå¿ƒè·³æ—¶é—´
            if now.Sub(instance.LastSeen) > time.Minute*2 {
                instance.Health = HealthStatusUnhealthy
                msr.logger.Warnf("Service unhealthy: %s (%s)", serviceName, serviceID)
                msr.notifyWatchers(serviceName)
            }
        }
    }
}
```

### 2. **æœåŠ¡æ³¨å†Œå®¢æˆ·ç«¯**

```go
// æœåŠ¡æ³¨å†Œå®¢æˆ·ç«¯
type ServiceRegistrar struct {
    registry     ServiceRegistry
    instance     *ServiceInstance
    stopCh       chan struct{}
    healthCheck  HealthChecker
    logger       *logrus.Logger
}

type HealthChecker interface {
    Check() error
}

func NewServiceRegistrar(registry ServiceRegistry, instance *ServiceInstance) *ServiceRegistrar {
    return &ServiceRegistrar{
        registry: registry,
        instance: instance,
        stopCh:   make(chan struct{}),
        logger:   logrus.New(),
    }
}

func (sr *ServiceRegistrar) Start() error {
    // æ³¨å†ŒæœåŠ¡
    if err := sr.registry.Register(sr.instance); err != nil {
        return fmt.Errorf("failed to register service: %v", err)
    }
    
    // å¯åŠ¨å¿ƒè·³
    go sr.startHeartbeat()
    
    sr.logger.Infof("Service registrar started for %s", sr.instance.Name)
    return nil
}

func (sr *ServiceRegistrar) Stop() error {
    close(sr.stopCh)
    
    // æ³¨é”€æœåŠ¡
    if err := sr.registry.Deregister(sr.instance.ID); err != nil {
        sr.logger.Errorf("Failed to deregister service: %v", err)
        return err
    }
    
    sr.logger.Infof("Service registrar stopped for %s", sr.instance.Name)
    return nil
}

func (sr *ServiceRegistrar) startHeartbeat() {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            if err := sr.sendHeartbeat(); err != nil {
                sr.logger.Errorf("Failed to send heartbeat: %v", err)
            }
        case <-sr.stopCh:
            return
        }
    }
}

func (sr *ServiceRegistrar) sendHeartbeat() error {
    // æ‰§è¡Œå¥åº·æ£€æŸ¥
    if sr.healthCheck != nil {
        if err := sr.healthCheck.Check(); err != nil {
            sr.instance.Health = HealthStatusUnhealthy
            sr.logger.Warnf("Health check failed: %v", err)
        } else {
            sr.instance.Health = HealthStatusHealthy
        }
    }
    
    // æ›´æ–°æœ€åå¿ƒè·³æ—¶é—´
    sr.instance.LastSeen = time.Now()
    
    // é‡æ–°æ³¨å†Œï¼ˆæ›´æ–°ä¿¡æ¯ï¼‰
    return sr.registry.Register(sr.instance)
}
```

### 3. **æœåŠ¡å‘ç°å®¢æˆ·ç«¯**

```go
// æœåŠ¡å‘ç°å®¢æˆ·ç«¯
type ServiceDiscoverer struct {
    registry    ServiceRegistry
    serviceName string
    instances   []*ServiceInstance
    balancer    LoadBalancer
    mutex       sync.RWMutex
    logger      *logrus.Logger
}

func NewServiceDiscoverer(registry ServiceRegistry, serviceName string) *ServiceDiscoverer {
    discoverer := &ServiceDiscoverer{
        registry:    registry,
        serviceName: serviceName,
        balancer:    NewRoundRobinBalancer(),
        logger:      logrus.New(),
    }
    
    // å¯åŠ¨æœåŠ¡ç›‘å¬
    go discoverer.startWatching()
    
    return discoverer
}

func (sd *ServiceDiscoverer) GetInstance() (*ServiceInstance, error) {
    sd.mutex.RLock()
    defer sd.mutex.RUnlock()
    
    if len(sd.instances) == 0 {
        return nil, errors.New("no healthy instances available")
    }
    
    return sd.balancer.Select(sd.instances)
}

func (sd *ServiceDiscoverer) GetAllInstances() []*ServiceInstance {
    sd.mutex.RLock()
    defer sd.mutex.RUnlock()
    
    // è¿”å›å‰¯æœ¬
    instances := make([]*ServiceInstance, len(sd.instances))
    copy(instances, sd.instances)
    return instances
}

func (sd *ServiceDiscoverer) startWatching() {
    watcher, err := sd.registry.Watch(sd.serviceName)
    if err != nil {
        sd.logger.Errorf("Failed to watch service %s: %v", sd.serviceName, err)
        return
    }
    
    for instances := range watcher {
        sd.mutex.Lock()
        sd.instances = instances
        sd.mutex.Unlock()
        
        sd.logger.Infof("Service instances updated for %s: %d instances", 
            sd.serviceName, len(instances))
    }
}
```

## âš–ï¸ è´Ÿè½½å‡è¡¡ç­–ç•¥

### 1. **è´Ÿè½½å‡è¡¡æ¥å£**

```go
type LoadBalancer interface {
    Select(instances []*ServiceInstance) (*ServiceInstance, error)
}

// è½®è¯¢è´Ÿè½½å‡è¡¡
type RoundRobinBalancer struct {
    counter uint64
}

func NewRoundRobinBalancer() *RoundRobinBalancer {
    return &RoundRobinBalancer{}
}

func (rrb *RoundRobinBalancer) Select(instances []*ServiceInstance) (*ServiceInstance, error) {
    if len(instances) == 0 {
        return nil, errors.New("no instances available")
    }
    
    index := atomic.AddUint64(&rrb.counter, 1) % uint64(len(instances))
    return instances[index], nil
}

// éšæœºè´Ÿè½½å‡è¡¡
type RandomBalancer struct {
    rand *rand.Rand
    mutex sync.Mutex
}

func NewRandomBalancer() *RandomBalancer {
    return &RandomBalancer{
        rand: rand.New(rand.NewSource(time.Now().UnixNano())),
    }
}

func (rb *RandomBalancer) Select(instances []*ServiceInstance) (*ServiceInstance, error) {
    if len(instances) == 0 {
        return nil, errors.New("no instances available")
    }
    
    rb.mutex.Lock()
    index := rb.rand.Intn(len(instances))
    rb.mutex.Unlock()
    
    return instances[index], nil
}

// åŠ æƒè½®è¯¢è´Ÿè½½å‡è¡¡
type WeightedRoundRobinBalancer struct {
    weights map[string]int
    current map[string]int
    mutex   sync.Mutex
}

func NewWeightedRoundRobinBalancer(weights map[string]int) *WeightedRoundRobinBalancer {
    return &WeightedRoundRobinBalancer{
        weights: weights,
        current: make(map[string]int),
    }
}

func (wrrb *WeightedRoundRobinBalancer) Select(instances []*ServiceInstance) (*ServiceInstance, error) {
    if len(instances) == 0 {
        return nil, errors.New("no instances available")
    }
    
    wrrb.mutex.Lock()
    defer wrrb.mutex.Unlock()
    
    var selected *ServiceInstance
    maxWeight := -1
    
    for _, instance := range instances {
        weight := wrrb.weights[instance.ID]
        if weight == 0 {
            weight = 1 // é»˜è®¤æƒé‡
        }
        
        wrrb.current[instance.ID] += weight
        
        if wrrb.current[instance.ID] > maxWeight {
            maxWeight = wrrb.current[instance.ID]
            selected = instance
        }
    }
    
    if selected != nil {
        wrrb.current[selected.ID] -= wrrb.getTotalWeight(instances)
    }
    
    return selected, nil
}

func (wrrb *WeightedRoundRobinBalancer) getTotalWeight(instances []*ServiceInstance) int {
    total := 0
    for _, instance := range instances {
        weight := wrrb.weights[instance.ID]
        if weight == 0 {
            weight = 1
        }
        total += weight
    }
    return total
}
```

## ğŸ”§ é›†æˆç¤ºä¾‹

### 1. **æœåŠ¡ç«¯é›†æˆ**

```go
// åœ¨æœåŠ¡å¯åŠ¨æ—¶æ³¨å†Œ
func StartUserService(config *Config) error {
    // åˆ›å»ºæœåŠ¡æ³¨å†Œä¸­å¿ƒå®¢æˆ·ç«¯
    registry := NewMemoryServiceRegistry()
    
    // åˆ›å»ºæœåŠ¡å®ä¾‹ä¿¡æ¯
    instance := &ServiceInstance{
        ID:      fmt.Sprintf("user-service-%s", uuid.New().String()),
        Name:    "user-service",
        Address: config.Server.Host,
        Port:    config.Server.GRPCPort,
        Tags:    []string{"user", "auth"},
        Meta: map[string]string{
            "version": "1.0.0",
            "region":  "local",
        },
    }
    
    // åˆ›å»ºæœåŠ¡æ³¨å†Œå™¨
    registrar := NewServiceRegistrar(registry, instance)
    
    // å¯åŠ¨æœåŠ¡æ³¨å†Œ
    if err := registrar.Start(); err != nil {
        return fmt.Errorf("failed to start service registrar: %v", err)
    }
    
    // å¯åŠ¨gRPCæœåŠ¡å™¨
    server := grpc.NewServer()
    pb.RegisterUserServiceServer(server, &userServiceImpl{})
    
    listener, err := net.Listen("tcp", fmt.Sprintf(":%d", config.Server.GRPCPort))
    if err != nil {
        return fmt.Errorf("failed to listen: %v", err)
    }
    
    // ä¼˜é›…å…³é—­å¤„ç†
    go func() {
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
        <-sigCh
        
        registrar.Stop()
        server.GracefulStop()
    }()
    
    return server.Serve(listener)
}
```

### 2. **å®¢æˆ·ç«¯é›†æˆ**

```go
// åœ¨å®¢æˆ·ç«¯ä½¿ç”¨æœåŠ¡å‘ç°
type UserServiceClient struct {
    discoverer *ServiceDiscoverer
    connPool   map[string]*grpc.ClientConn
    mutex      sync.RWMutex
}

func NewUserServiceClient(registry ServiceRegistry) *UserServiceClient {
    return &UserServiceClient{
        discoverer: NewServiceDiscoverer(registry, "user-service"),
        connPool:   make(map[string]*grpc.ClientConn),
    }
}

func (usc *UserServiceClient) Login(ctx context.Context, req *pb.LoginRequest) (*pb.LoginResponse, error) {
    // è·å–æœåŠ¡å®ä¾‹
    instance, err := usc.discoverer.GetInstance()
    if err != nil {
        return nil, fmt.Errorf("failed to get service instance: %v", err)
    }
    
    // è·å–è¿æ¥
    conn, err := usc.getConnection(instance)
    if err != nil {
        return nil, fmt.Errorf("failed to get connection: %v", err)
    }
    
    // åˆ›å»ºå®¢æˆ·ç«¯å¹¶è°ƒç”¨
    client := pb.NewUserServiceClient(conn)
    return client.Login(ctx, req)
}

func (usc *UserServiceClient) getConnection(instance *ServiceInstance) (*grpc.ClientConn, error) {
    address := fmt.Sprintf("%s:%d", instance.Address, instance.Port)
    
    usc.mutex.RLock()
    if conn, exists := usc.connPool[address]; exists {
        usc.mutex.RUnlock()
        return conn, nil
    }
    usc.mutex.RUnlock()
    
    usc.mutex.Lock()
    defer usc.mutex.Unlock()
    
    // åŒé‡æ£€æŸ¥
    if conn, exists := usc.connPool[address]; exists {
        return conn, nil
    }
    
    // åˆ›å»ºæ–°è¿æ¥
    conn, err := grpc.Dial(address, grpc.WithInsecure())
    if err != nil {
        return nil, err
    }
    
    usc.connPool[address] = conn
    return conn, nil
}
```

## ğŸ“Š ç›‘æ§ä¸æŒ‡æ ‡

### 1. **æœåŠ¡å‘ç°æŒ‡æ ‡**

```go
type ServiceDiscoveryMetrics struct {
    registeredServices prometheus.Gauge
    healthyServices    prometheus.Gauge
    discoveryRequests  *prometheus.CounterVec
    registrationTime   *prometheus.HistogramVec
}

func NewServiceDiscoveryMetrics() *ServiceDiscoveryMetrics {
    return &ServiceDiscoveryMetrics{
        registeredServices: prometheus.NewGauge(
            prometheus.GaugeOpts{
                Name: "service_discovery_registered_services",
                Help: "Number of registered services",
            },
        ),
        healthyServices: prometheus.NewGauge(
            prometheus.GaugeOpts{
                Name: "service_discovery_healthy_services",
                Help: "Number of healthy services",
            },
        ),
        discoveryRequests: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "service_discovery_requests_total",
                Help: "Total number of service discovery requests",
            },
            []string{"service_name", "status"},
        ),
        registrationTime: prometheus.NewHistogramVec(
            prometheus.HistogramOpts{
                Name: "service_discovery_registration_duration_seconds",
                Help: "Time taken to register a service",
            },
            []string{"service_name"},
        ),
    }
}
```

## ğŸ“ æ€»ç»“

æœåŠ¡æ³¨å†Œä¸å‘ç°ä¸ºMovieInfoé¡¹ç›®æä¾›äº†å¼ºå¤§çš„æœåŠ¡ç®¡ç†èƒ½åŠ›ï¼š

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
1. **è‡ªåŠ¨æ³¨å†Œ**ï¼šæœåŠ¡å¯åŠ¨æ—¶è‡ªåŠ¨æ³¨å†Œåˆ°æ³¨å†Œä¸­å¿ƒ
2. **å¥åº·æ£€æŸ¥**ï¼šå®šæœŸæ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€
3. **åŠ¨æ€å‘ç°**ï¼šå®¢æˆ·ç«¯åŠ¨æ€å‘ç°å¯ç”¨æœåŠ¡
4. **è´Ÿè½½å‡è¡¡**ï¼šæ”¯æŒå¤šç§è´Ÿè½½å‡è¡¡ç­–ç•¥

**æŠ€æœ¯ç‰¹ç‚¹**ï¼š
- ç®€å•æ˜“ç”¨çš„APIæ¥å£
- æ”¯æŒå¤šç§è´Ÿè½½å‡è¡¡ç­–ç•¥
- å®Œæ•´çš„å¥åº·æ£€æŸ¥æœºåˆ¶
- å®æ—¶çš„æœåŠ¡çŠ¶æ€æ›´æ–°

**æ‰©å±•èƒ½åŠ›**ï¼š
- æ”¯æŒåˆ†å¸ƒå¼éƒ¨ç½²
- å¯é›†æˆå¤–éƒ¨æ³¨å†Œä¸­å¿ƒï¼ˆå¦‚Consulã€Etcdï¼‰
- æ”¯æŒæœåŠ¡ç½‘æ ¼æ¼”è¿›

ä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬å°†å®ç°gRPCä¸­é—´ä»¶ï¼Œä¸ºæœåŠ¡è°ƒç”¨æ·»åŠ è®¤è¯ã€æ—¥å¿—ã€ç›‘æ§ç­‰æ¨ªåˆ‡å…³æ³¨ç‚¹ã€‚

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ  
**æœ€åæ›´æ–°**: 2025-07-22  
**ä¸‹ä¸€æ­¥**: [ç¬¬25æ­¥ï¼šgRPCä¸­é—´ä»¶](25-middleware.md)
