# ç¬¬34æ­¥ï¼šç”µå½±æœç´¢åŠŸèƒ½

## ğŸ“‹ æ¦‚è¿°

ç”µå½±æœç´¢åŠŸèƒ½æ˜¯MovieInfoé¡¹ç›®çš„æ ¸å¿ƒå‘ç°æœºåˆ¶ï¼Œä¸ºç”¨æˆ·æä¾›å¿«é€Ÿã€å‡†ç¡®ã€æ™ºèƒ½çš„ç”µå½±æŸ¥æ‰¾ä½“éªŒã€‚ä¸€ä¸ªä¼˜ç§€çš„æœç´¢ç³»ç»Ÿéœ€è¦æ”¯æŒå¤šç§æœç´¢æ–¹å¼ã€æ™ºèƒ½æ’åºç®—æ³•å’Œé«˜æ€§èƒ½çš„æŸ¥è¯¢å¤„ç†ã€‚

## ğŸ¯ è®¾è®¡ç›®æ ‡

### 1. **æœç´¢å‡†ç¡®æ€§**
- å…¨æ–‡æœç´¢æ”¯æŒ
- æ¨¡ç³ŠåŒ¹é…ç®—æ³•
- æ™ºèƒ½çº é”™åŠŸèƒ½
- å¤šè¯­è¨€æœç´¢æ”¯æŒ

### 2. **æœç´¢æ€§èƒ½**
- æ¯«ç§’çº§å“åº”æ—¶é—´
- é«˜å¹¶å‘æŸ¥è¯¢æ”¯æŒ
- æ™ºèƒ½ç¼“å­˜ç­–ç•¥
- ç´¢å¼•ä¼˜åŒ–è®¾è®¡

### 3. **ç”¨æˆ·ä½“éªŒ**
- å®æ—¶æœç´¢å»ºè®®
- æœç´¢å†å²è®°å½•
- çƒ­é—¨æœç´¢æ¨è
- é«˜çº§ç­›é€‰åŠŸèƒ½

## ğŸ” æœç´¢æ¶æ„è®¾è®¡

### 1. **æœç´¢ç³»ç»Ÿæ¶æ„**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç”µå½±æœç´¢ç³»ç»Ÿæ¶æ„                          â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  æœç´¢æ¥å£    â”‚  â”‚  æœç´¢å¼•æ“    â”‚  â”‚  ç´¢å¼•ç®¡ç†    â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ â€¢ å…³é”®è¯æœç´¢ â”‚  â”‚ â€¢ å…¨æ–‡æœç´¢   â”‚  â”‚ â€¢ å€’æ’ç´¢å¼•   â”‚          â”‚
â”‚  â”‚ â€¢ é«˜çº§æœç´¢   â”‚  â”‚ â€¢ æ¨¡ç³ŠåŒ¹é…   â”‚  â”‚ â€¢ åˆ†è¯ç´¢å¼•   â”‚          â”‚
â”‚  â”‚ â€¢ æœç´¢å»ºè®®   â”‚  â”‚ â€¢ ç›¸å…³æ€§æ’åº â”‚  â”‚ â€¢ å®æ—¶æ›´æ–°   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                              â”‚                              â”‚
â”‚                              â–¼                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                  æœç´¢ä¼˜åŒ–å±‚                              â”‚ â”‚
â”‚  â”‚                                                         â”‚ â”‚
â”‚  â”‚ â€¢ æŸ¥è¯¢ç¼“å­˜    â€¢ ç»“æœç¼“å­˜    â€¢ çƒ­è¯ç¼“å­˜    â€¢ ç»Ÿè®¡åˆ†æ     â”‚ â”‚
â”‚  â”‚ â€¢ æœç´¢æ—¥å¿—    â€¢ æ€§èƒ½ç›‘æ§    â€¢ ç”¨æˆ·è¡Œä¸º    â€¢ æ™ºèƒ½æ¨è     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. **æœç´¢è¯·æ±‚ç»“æ„**

```go
// æœç´¢è¯·æ±‚å‚æ•°
type MovieSearchRequest struct {
    // åŸºç¡€æœç´¢å‚æ•°
    Query    string `json:"query" form:"query" binding:"required"`
    Page     int    `json:"page" form:"page" binding:"min=1"`
    PageSize int    `json:"page_size" form:"page_size" binding:"min=1,max=50"`
    
    // æœç´¢ç±»å‹
    SearchType string `json:"search_type" form:"search_type"` // all, title, person, company
    
    // æ’åºå‚æ•°
    SortBy    string `json:"sort_by" form:"sort_by"`       // relevance, rating, release_date, popularity
    SortOrder string `json:"sort_order" form:"sort_order"` // asc, desc
    
    // ç­›é€‰å‚æ•°
    Genres      []string `json:"genres" form:"genres"`
    YearFrom    int      `json:"year_from" form:"year_from"`
    YearTo      int      `json:"year_to" form:"year_to"`
    RatingFrom  float64  `json:"rating_from" form:"rating_from"`
    RatingTo    float64  `json:"rating_to" form:"rating_to"`
    Countries   []string `json:"countries" form:"countries"`
    Languages   []string `json:"languages" form:"languages"`
    
    // æœç´¢é€‰é¡¹
    IncludeAdult bool `json:"include_adult" form:"include_adult"`
    ExactMatch   bool `json:"exact_match" form:"exact_match"`
    
    // ç”¨æˆ·ä¿¡æ¯ï¼ˆç”¨äºä¸ªæ€§åŒ–ï¼‰
    UserID string `json:"-"` // ä»è®¤è¯ä¸­è·å–
}

// æœç´¢å“åº”ç»“æ„
type MovieSearchResponse struct {
    Success      bool                `json:"success"`
    Message      string              `json:"message,omitempty"`
    Data         *MovieSearchData    `json:"data,omitempty"`
    Pagination   *PaginationInfo     `json:"pagination,omitempty"`
    SearchInfo   *SearchInfo         `json:"search_info,omitempty"`
    Suggestions  []SearchSuggestion  `json:"suggestions,omitempty"`
}

// æœç´¢æ•°æ®
type MovieSearchData struct {
    Movies      []MovieSearchResult `json:"movies"`
    Total       int64               `json:"total"`
    SearchTime  float64             `json:"search_time_ms"`
}

// æœç´¢ç»“æœé¡¹
type MovieSearchResult struct {
    ID            string    `json:"id"`
    Title         string    `json:"title"`
    OriginalTitle string    `json:"original_title,omitempty"`
    PosterURL     string    `json:"poster_url"`
    Overview      string    `json:"overview"`
    ReleaseDate   string    `json:"release_date"`
    Rating        float64   `json:"rating"`
    VoteCount     int       `json:"vote_count"`
    Popularity    float64   `json:"popularity"`
    Genres        []Genre   `json:"genres"`
    
    // æœç´¢ç›¸å…³
    Relevance     float64   `json:"relevance"`
    MatchedFields []string  `json:"matched_fields"`
    Highlights    []string  `json:"highlights,omitempty"`
}

// æœç´¢ä¿¡æ¯
type SearchInfo struct {
    Query           string  `json:"query"`
    ProcessedQuery  string  `json:"processed_query"`
    SearchTime      float64 `json:"search_time_ms"`
    TotalResults    int64   `json:"total_results"`
    CorrectedQuery  string  `json:"corrected_query,omitempty"`
    DidYouMean      string  `json:"did_you_mean,omitempty"`
}

// æœç´¢å»ºè®®
type SearchSuggestion struct {
    Text        string  `json:"text"`
    Type        string  `json:"type"` // movie, person, genre
    Count       int     `json:"count"`
    Popularity  float64 `json:"popularity"`
}
```

## ğŸ”§ æœç´¢å¼•æ“å®ç°

### 1. **æ ¸å¿ƒæœç´¢æœåŠ¡**

```go
type MovieSearchService struct {
    searchEngine   SearchEngine
    movieRepo      MovieRepository
    cacheStore     CacheStore
    suggestionService SuggestionService
    logger         *logrus.Logger
    metrics        *SearchMetrics
}

func NewMovieSearchService(
    searchEngine SearchEngine,
    movieRepo MovieRepository,
    cacheStore CacheStore,
    suggestionService SuggestionService,
) *MovieSearchService {
    return &MovieSearchService{
        searchEngine:      searchEngine,
        movieRepo:         movieRepo,
        cacheStore:        cacheStore,
        suggestionService: suggestionService,
        logger:            logrus.New(),
        metrics:           NewSearchMetrics(),
    }
}

// æœç´¢ç”µå½±
func (mss *MovieSearchService) SearchMovies(ctx context.Context, req *MovieSearchRequest) (*MovieSearchResponse, error) {
    start := time.Now()
    defer func() {
        mss.metrics.ObserveSearchDuration(time.Since(start))
    }()

    // éªŒè¯å’Œé¢„å¤„ç†è¯·æ±‚
    if err := mss.validateAndPreprocessRequest(req); err != nil {
        mss.metrics.IncInvalidRequests()
        return &MovieSearchResponse{
            Success: false,
            Message: err.Error(),
        }, nil
    }

    // ç”Ÿæˆç¼“å­˜é”®
    cacheKey := mss.generateCacheKey(req)

    // å°è¯•ä»ç¼“å­˜è·å–ç»“æœ
    if cachedResult, err := mss.getFromCache(ctx, cacheKey); err == nil {
        mss.metrics.IncCacheHits()
        return cachedResult, nil
    }
    mss.metrics.IncCacheMisses()

    // æ‰§è¡Œæœç´¢
    searchResult, err := mss.executeSearch(ctx, req)
    if err != nil {
        mss.logger.Errorf("Search execution failed: %v", err)
        mss.metrics.IncSearchErrors()
        return nil, errors.New("æœç´¢æ‰§è¡Œå¤±è´¥")
    }

    // è·å–æœç´¢å»ºè®®
    suggestions, err := mss.getSuggestions(ctx, req.Query)
    if err != nil {
        mss.logger.Errorf("Failed to get suggestions: %v", err)
        // å»ºè®®è·å–å¤±è´¥ä¸å½±å“ä¸»è¦æœç´¢åŠŸèƒ½
    }

    // æ„å»ºå“åº”
    response := &MovieSearchResponse{
        Success:     true,
        Data:        searchResult.Data,
        Pagination:  searchResult.Pagination,
        SearchInfo:  searchResult.SearchInfo,
        Suggestions: suggestions,
    }

    // å¼‚æ­¥ç¼“å­˜ç»“æœ
    go func() {
        if err := mss.cacheResult(context.Background(), cacheKey, response); err != nil {
            mss.logger.Errorf("Failed to cache search result: %v", err)
        }
    }()

    // å¼‚æ­¥è®°å½•æœç´¢æ—¥å¿—
    go mss.logSearchQuery(context.Background(), req, searchResult.Data.Total)

    mss.metrics.IncSuccessfulSearches()
    return response, nil
}

// æ‰§è¡Œæœç´¢
func (mss *MovieSearchService) executeSearch(ctx context.Context, req *MovieSearchRequest) (*SearchResult, error) {
    searchStart := time.Now()

    // æ„å»ºæœç´¢æŸ¥è¯¢
    searchQuery := mss.buildSearchQuery(req)

    // æ‰§è¡Œæœç´¢å¼•æ“æŸ¥è¯¢
    engineResult, err := mss.searchEngine.Search(ctx, searchQuery)
    if err != nil {
        return nil, err
    }

    searchTime := time.Since(searchStart).Seconds() * 1000 // è½¬æ¢ä¸ºæ¯«ç§’

    // è½¬æ¢æœç´¢ç»“æœ
    movies := mss.convertSearchResults(engineResult.Hits)

    // æ„å»ºåˆ†é¡µä¿¡æ¯
    pagination := &PaginationInfo{
        CurrentPage:  req.Page,
        PageSize:     req.PageSize,
        TotalPages:   int(math.Ceil(float64(engineResult.Total) / float64(req.PageSize))),
        TotalItems:   engineResult.Total,
        HasNext:      req.Page < int(math.Ceil(float64(engineResult.Total)/float64(req.PageSize))),
        HasPrevious:  req.Page > 1,
    }

    // æ„å»ºæœç´¢ä¿¡æ¯
    searchInfo := &SearchInfo{
        Query:          req.Query,
        ProcessedQuery: searchQuery.ProcessedQuery,
        SearchTime:     searchTime,
        TotalResults:   engineResult.Total,
        CorrectedQuery: engineResult.CorrectedQuery,
        DidYouMean:     engineResult.DidYouMean,
    }

    return &SearchResult{
        Data: &MovieSearchData{
            Movies:     movies,
            Total:      engineResult.Total,
            SearchTime: searchTime,
        },
        Pagination: pagination,
        SearchInfo: searchInfo,
    }, nil
}

// æ„å»ºæœç´¢æŸ¥è¯¢
func (mss *MovieSearchService) buildSearchQuery(req *MovieSearchRequest) *SearchQuery {
    query := &SearchQuery{
        Query:      req.Query,
        SearchType: req.SearchType,
        Page:       req.Page,
        PageSize:   req.PageSize,
        SortBy:     req.SortBy,
        SortOrder:  req.SortOrder,
        Filters:    make(map[string]interface{}),
    }

    // å¤„ç†æŸ¥è¯¢æ–‡æœ¬
    query.ProcessedQuery = mss.preprocessQuery(req.Query)

    // æ·»åŠ ç­›é€‰æ¡ä»¶
    if len(req.Genres) > 0 {
        query.Filters["genres"] = req.Genres
    }
    
    if req.YearFrom > 0 || req.YearTo > 0 {
        yearFilter := make(map[string]int)
        if req.YearFrom > 0 {
            yearFilter["gte"] = req.YearFrom
        }
        if req.YearTo > 0 {
            yearFilter["lte"] = req.YearTo
        }
        query.Filters["release_year"] = yearFilter
    }

    if req.RatingFrom > 0 || req.RatingTo > 0 {
        ratingFilter := make(map[string]float64)
        if req.RatingFrom > 0 {
            ratingFilter["gte"] = req.RatingFrom
        }
        if req.RatingTo > 0 {
            ratingFilter["lte"] = req.RatingTo
        }
        query.Filters["rating"] = ratingFilter
    }

    if len(req.Countries) > 0 {
        query.Filters["countries"] = req.Countries
    }

    if len(req.Languages) > 0 {
        query.Filters["languages"] = req.Languages
    }

    if !req.IncludeAdult {
        query.Filters["adult"] = false
    }

    return query
}

// é¢„å¤„ç†æŸ¥è¯¢æ–‡æœ¬
func (mss *MovieSearchService) preprocessQuery(query string) string {
    // å»é™¤å¤šä½™ç©ºæ ¼
    query = strings.TrimSpace(query)
    query = regexp.MustCompile(`\s+`).ReplaceAllString(query, " ")

    // è½¬æ¢ä¸ºå°å†™
    query = strings.ToLower(query)

    // ç§»é™¤ç‰¹æ®Šå­—ç¬¦ï¼ˆä¿ç•™åŸºæœ¬æ ‡ç‚¹ï¼‰
    query = regexp.MustCompile(`[^\w\s\-\.\,\!\?]`).ReplaceAllString(query, "")

    return query
}
```

### 2. **æœç´¢å¼•æ“æ¥å£**

```go
type SearchEngine interface {
    Search(ctx context.Context, query *SearchQuery) (*SearchEngineResult, error)
    Index(ctx context.Context, document *SearchDocument) error
    Update(ctx context.Context, id string, document *SearchDocument) error
    Delete(ctx context.Context, id string) error
    Suggest(ctx context.Context, query string, limit int) ([]SearchSuggestion, error)
}

// Elasticsearchå®ç°
type ElasticsearchEngine struct {
    client *elasticsearch.Client
    index  string
    logger *logrus.Logger
}

func NewElasticsearchEngine(client *elasticsearch.Client, index string) *ElasticsearchEngine {
    return &ElasticsearchEngine{
        client: client,
        index:  index,
        logger: logrus.New(),
    }
}

func (es *ElasticsearchEngine) Search(ctx context.Context, query *SearchQuery) (*SearchEngineResult, error) {
    // æ„å»ºElasticsearchæŸ¥è¯¢
    esQuery := es.buildElasticsearchQuery(query)

    // æ‰§è¡Œæœç´¢
    res, err := es.client.Search(
        es.client.Search.WithContext(ctx),
        es.client.Search.WithIndex(es.index),
        es.client.Search.WithBody(esQuery),
        es.client.Search.WithTrackTotalHits(true),
    )
    if err != nil {
        return nil, err
    }
    defer res.Body.Close()

    // è§£æå“åº”
    var response ElasticsearchResponse
    if err := json.NewDecoder(res.Body).Decode(&response); err != nil {
        return nil, err
    }

    // è½¬æ¢ä¸ºé€šç”¨ç»“æœæ ¼å¼
    result := &SearchEngineResult{
        Total: response.Hits.Total.Value,
        Hits:  make([]SearchHit, len(response.Hits.Hits)),
    }

    for i, hit := range response.Hits.Hits {
        result.Hits[i] = SearchHit{
            ID:        hit.ID,
            Score:     hit.Score,
            Source:    hit.Source,
            Highlight: hit.Highlight,
        }
    }

    return result, nil
}

func (es *ElasticsearchEngine) buildElasticsearchQuery(query *SearchQuery) io.Reader {
    esQuery := map[string]interface{}{
        "query": map[string]interface{}{
            "bool": map[string]interface{}{
                "must": []map[string]interface{}{
                    {
                        "multi_match": map[string]interface{}{
                            "query":  query.ProcessedQuery,
                            "fields": []string{"title^3", "original_title^2", "overview", "genres.name", "cast.name", "crew.name"},
                            "type":   "best_fields",
                            "fuzziness": "AUTO",
                        },
                    },
                },
                "filter": es.buildFilters(query.Filters),
            },
        },
        "highlight": map[string]interface{}{
            "fields": map[string]interface{}{
                "title":          map[string]interface{}{},
                "original_title": map[string]interface{}{},
                "overview":       map[string]interface{}{},
            },
        },
        "sort": es.buildSort(query.SortBy, query.SortOrder),
        "from": (query.Page - 1) * query.PageSize,
        "size": query.PageSize,
    }

    jsonQuery, _ := json.Marshal(esQuery)
    return bytes.NewReader(jsonQuery)
}
```

### 3. **æœç´¢å»ºè®®æœåŠ¡**

```go
type SuggestionService struct {
    redis      *redis.Client
    movieRepo  MovieRepository
    logger     *logrus.Logger
}

func NewSuggestionService(redis *redis.Client, movieRepo MovieRepository) *SuggestionService {
    return &SuggestionService{
        redis:     redis,
        movieRepo: movieRepo,
        logger:    logrus.New(),
    }
}

// è·å–æœç´¢å»ºè®®
func (ss *SuggestionService) GetSuggestions(ctx context.Context, query string, limit int) ([]SearchSuggestion, error) {
    if len(query) < 2 {
        return []SearchSuggestion{}, nil
    }

    var suggestions []SearchSuggestion

    // è·å–ç”µå½±æ ‡é¢˜å»ºè®®
    movieSuggestions, err := ss.getMovieSuggestions(ctx, query, limit/2)
    if err != nil {
        ss.logger.Errorf("Failed to get movie suggestions: %v", err)
    } else {
        suggestions = append(suggestions, movieSuggestions...)
    }

    // è·å–äººç‰©å»ºè®®
    personSuggestions, err := ss.getPersonSuggestions(ctx, query, limit/4)
    if err != nil {
        ss.logger.Errorf("Failed to get person suggestions: %v", err)
    } else {
        suggestions = append(suggestions, personSuggestions...)
    }

    // è·å–ç±»å‹å»ºè®®
    genreSuggestions, err := ss.getGenreSuggestions(ctx, query, limit/4)
    if err != nil {
        ss.logger.Errorf("Failed to get genre suggestions: %v", err)
    } else {
        suggestions = append(suggestions, genreSuggestions...)
    }

    // æŒ‰ç›¸å…³æ€§æ’åº
    sort.Slice(suggestions, func(i, j int) bool {
        return suggestions[i].Popularity > suggestions[j].Popularity
    })

    if len(suggestions) > limit {
        suggestions = suggestions[:limit]
    }

    return suggestions, nil
}

// è·å–çƒ­é—¨æœç´¢
func (ss *SuggestionService) GetHotSearches(ctx context.Context, limit int) ([]SearchSuggestion, error) {
    key := "hot_searches"
    
    // ä»Redisè·å–çƒ­é—¨æœç´¢
    results, err := ss.redis.ZRevRange(ctx, key, 0, int64(limit-1)).Result()
    if err != nil {
        return nil, err
    }

    suggestions := make([]SearchSuggestion, len(results))
    for i, result := range results {
        score, _ := ss.redis.ZScore(ctx, key, result).Result()
        suggestions[i] = SearchSuggestion{
            Text:       result,
            Type:       "hot",
            Popularity: score,
        }
    }

    return suggestions, nil
}

// è®°å½•æœç´¢æŸ¥è¯¢
func (ss *SuggestionService) RecordSearchQuery(ctx context.Context, query string) {
    if len(query) < 2 {
        return
    }

    key := "hot_searches"
    
    // å¢åŠ æœç´¢æ¬¡æ•°
    ss.redis.ZIncrBy(ctx, key, 1, query)
    
    // è®¾ç½®è¿‡æœŸæ—¶é—´ï¼ˆ7å¤©ï¼‰
    ss.redis.Expire(ctx, key, 7*24*time.Hour)
}
```

## ğŸ“Š æ€§èƒ½ç›‘æ§

### 1. **æœç´¢æŒ‡æ ‡æ”¶é›†**

```go
type SearchMetrics struct {
    searchRequests     *prometheus.CounterVec
    searchDuration     prometheus.Histogram
    cacheHitRate       *prometheus.CounterVec
    searchErrors       *prometheus.CounterVec
    queryComplexity    prometheus.Histogram
    resultCount        prometheus.Histogram
}

func NewSearchMetrics() *SearchMetrics {
    return &SearchMetrics{
        searchRequests: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "movie_search_requests_total",
                Help: "Total number of movie search requests",
            },
            []string{"search_type", "status"},
        ),
        searchDuration: prometheus.NewHistogram(
            prometheus.HistogramOpts{
                Name: "movie_search_duration_seconds",
                Help: "Duration of movie search requests",
            },
        ),
        cacheHitRate: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "movie_search_cache_operations_total",
                Help: "Total number of search cache operations",
            },
            []string{"type"},
        ),
        searchErrors: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "movie_search_errors_total",
                Help: "Total number of search errors",
            },
            []string{"error_type"},
        ),
        queryComplexity: prometheus.NewHistogram(
            prometheus.HistogramOpts{
                Name: "movie_search_query_complexity",
                Help: "Complexity of search queries",
            },
        ),
        resultCount: prometheus.NewHistogram(
            prometheus.HistogramOpts{
                Name: "movie_search_result_count",
                Help: "Number of search results returned",
            },
        ),
    }
}
```

## ğŸ”§ HTTPå¤„ç†å™¨

### 1. **æœç´¢APIç«¯ç‚¹**

```go
func (mc *MovieController) SearchMovies(c *gin.Context) {
    var req MovieSearchRequest
    
    // ç»‘å®šæŸ¥è¯¢å‚æ•°
    if err := c.ShouldBindQuery(&req); err != nil {
        c.JSON(400, gin.H{
            "success": false,
            "message": "è¯·æ±‚å‚æ•°é”™è¯¯",
            "error":   err.Error(),
        })
        return
    }

    // è·å–ç”¨æˆ·IDï¼ˆç”¨äºä¸ªæ€§åŒ–ï¼‰
    req.UserID = mc.getUserIDFromContext(c)

    // è°ƒç”¨æœç´¢æœåŠ¡
    response, err := mc.movieSearchService.SearchMovies(c.Request.Context(), &req)
    if err != nil {
        mc.logger.Errorf("Failed to search movies: %v", err)
        c.JSON(500, gin.H{
            "success": false,
            "message": "æœç´¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•",
        })
        return
    }

    // è®¾ç½®ç¼“å­˜å¤´
    c.Header("Cache-Control", "public, max-age=300") // 5åˆ†é’Ÿç¼“å­˜

    c.JSON(200, response)
}

// è·å–æœç´¢å»ºè®®
func (mc *MovieController) GetSearchSuggestions(c *gin.Context) {
    query := c.Query("q")
    if len(query) < 2 {
        c.JSON(200, gin.H{
            "success":     true,
            "suggestions": []SearchSuggestion{},
        })
        return
    }

    suggestions, err := mc.suggestionService.GetSuggestions(c.Request.Context(), query, 10)
    if err != nil {
        mc.logger.Errorf("Failed to get suggestions: %v", err)
        c.JSON(500, gin.H{
            "success": false,
            "message": "è·å–å»ºè®®å¤±è´¥",
        })
        return
    }

    c.Header("Cache-Control", "public, max-age=60") // 1åˆ†é’Ÿç¼“å­˜
    c.JSON(200, gin.H{
        "success":     true,
        "suggestions": suggestions,
    })
}

// è·å–çƒ­é—¨æœç´¢
func (mc *MovieController) GetHotSearches(c *gin.Context) {
    hotSearches, err := mc.suggestionService.GetHotSearches(c.Request.Context(), 20)
    if err != nil {
        mc.logger.Errorf("Failed to get hot searches: %v", err)
        c.JSON(500, gin.H{
            "success": false,
            "message": "è·å–çƒ­é—¨æœç´¢å¤±è´¥",
        })
        return
    }

    c.Header("Cache-Control", "public, max-age=3600") // 1å°æ—¶ç¼“å­˜
    c.JSON(200, gin.H{
        "success": true,
        "data":    hotSearches,
    })
}
```

## ğŸ“ æ€»ç»“

ç”µå½±æœç´¢åŠŸèƒ½ä¸ºMovieInfoé¡¹ç›®æä¾›äº†å¼ºå¤§çš„ç”µå½±å‘ç°èƒ½åŠ›ï¼š

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
1. **å…¨æ–‡æœç´¢**ï¼šæ”¯æŒç”µå½±æ ‡é¢˜ã€æ¼”å‘˜ã€å¯¼æ¼”ç­‰å¤šå­—æ®µæœç´¢
2. **æ™ºèƒ½åŒ¹é…**ï¼šæ¨¡ç³Šæœç´¢ã€æ‹¼å†™çº é”™ã€ç›¸å…³æ€§æ’åº
3. **é«˜çº§ç­›é€‰**ï¼šå¤šç»´åº¦ç­›é€‰æ¡ä»¶ç»„åˆ
4. **æœç´¢å»ºè®®**ï¼šå®æ—¶å»ºè®®ã€çƒ­é—¨æœç´¢ã€æœç´¢å†å²

**æ€§èƒ½ä¼˜åŒ–**ï¼š
- Elasticsearchå…¨æ–‡æœç´¢å¼•æ“
- å¤šå±‚ç¼“å­˜ç­–ç•¥
- æŸ¥è¯¢ä¼˜åŒ–å’Œç´¢å¼•è®¾è®¡
- å¼‚æ­¥å¤„ç†å’Œé¢„åŠ è½½

**ç”¨æˆ·ä½“éªŒ**ï¼š
- æ¯«ç§’çº§æœç´¢å“åº”
- æ™ºèƒ½æœç´¢å»ºè®®
- ä¸°å¯Œçš„ç­›é€‰é€‰é¡¹
- ä¸ªæ€§åŒ–æœç´¢ç»“æœ

ä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬å°†å®ç°ç”µå½±åˆ†ç±»ç®¡ç†åŠŸèƒ½ï¼Œä¸ºç”µå½±å†…å®¹æä¾›æœ‰åºçš„ç»„ç»‡ç»“æ„ã€‚

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ  
**æœ€åæ›´æ–°**: 2025-07-22  
**ä¸‹ä¸€æ­¥**: [ç¬¬35æ­¥ï¼šç”µå½±åˆ†ç±»ç®¡ç†](35-category-management.md)
