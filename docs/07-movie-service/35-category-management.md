# ç¬¬35æ­¥ï¼šç”µå½±åˆ†ç±»ç®¡ç†

## ğŸ“‹ æ¦‚è¿°

ç”µå½±åˆ†ç±»ç®¡ç†æ˜¯MovieInfoé¡¹ç›®çš„é‡è¦ç»„ç»‡åŠŸèƒ½ï¼Œä¸ºç”µå½±å†…å®¹æä¾›æœ‰åºçš„åˆ†ç±»ä½“ç³»å’Œç®¡ç†æœºåˆ¶ã€‚ä¸€ä¸ªå®Œå–„çš„åˆ†ç±»ç³»ç»Ÿéœ€è¦æ”¯æŒå¤šç»´åº¦åˆ†ç±»ã€å±‚çº§ç»“æ„ç®¡ç†å’Œçµæ´»çš„åˆ†ç±»ç­–ç•¥ã€‚

## ğŸ¯ è®¾è®¡ç›®æ ‡

### 1. **åˆ†ç±»ä½“ç³»å®Œæ•´æ€§**
- å¤šç»´åº¦åˆ†ç±»æ”¯æŒ
- å±‚çº§ç»“æ„ç®¡ç†
- æ ‡ç­¾ç³»ç»Ÿé›†æˆ
- è‡ªå®šä¹‰åˆ†ç±»æ”¯æŒ

### 2. **ç®¡ç†åŠŸèƒ½å®Œå–„**
- åˆ†ç±»CRUDæ“ä½œ
- æ‰¹é‡ç®¡ç†åŠŸèƒ½
- åˆ†ç±»ç»Ÿè®¡åˆ†æ
- åˆ†ç±»å…³ç³»ç»´æŠ¤

### 3. **ç”¨æˆ·ä½“éªŒä¼˜åŒ–**
- ç›´è§‚çš„åˆ†ç±»å¯¼èˆª
- æ™ºèƒ½åˆ†ç±»æ¨è
- å¿«é€Ÿåˆ†ç±»ç­›é€‰
- ä¸ªæ€§åŒ–åˆ†ç±»å±•ç¤º

## ğŸ—ï¸ åˆ†ç±»ç³»ç»Ÿæ¶æ„

### 1. **åˆ†ç±»ä½“ç³»è®¾è®¡**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç”µå½±åˆ†ç±»ä½“ç³»                              â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  ç±»å‹åˆ†ç±»    â”‚  â”‚  åœ°åŒºåˆ†ç±»    â”‚  â”‚  å¹´ä»£åˆ†ç±»    â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ â€¢ åŠ¨ä½œç‰‡    â”‚  â”‚ â€¢ åè¯­ç”µå½±   â”‚  â”‚ â€¢ 2020å¹´ä»£  â”‚          â”‚
â”‚  â”‚ â€¢ å–œå‰§ç‰‡    â”‚  â”‚ â€¢ æ¬§ç¾ç”µå½±   â”‚  â”‚ â€¢ 2010å¹´ä»£  â”‚          â”‚
â”‚  â”‚ â€¢ å‰§æƒ…ç‰‡    â”‚  â”‚ â€¢ æ—¥éŸ©ç”µå½±   â”‚  â”‚ â€¢ ç»å…¸ç”µå½±   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                              â”‚                              â”‚
â”‚                              â–¼                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                  åˆ†ç±»ç®¡ç†ç³»ç»Ÿ                            â”‚ â”‚
â”‚  â”‚                                                         â”‚ â”‚
â”‚  â”‚ â€¢ åˆ†ç±»åˆ›å»º    â€¢ åˆ†ç±»ç¼–è¾‘    â€¢ åˆ†ç±»åˆ é™¤    â€¢ åˆ†ç±»æ’åº     â”‚ â”‚
â”‚  â”‚ â€¢ å…³ç³»ç®¡ç†    â€¢ ç»Ÿè®¡åˆ†æ    â€¢ æ‰¹é‡æ“ä½œ    â€¢ æƒé™æ§åˆ¶     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. **åˆ†ç±»æ•°æ®æ¨¡å‹**

```go
// åˆ†ç±»åŸºç¡€æ¨¡å‹
type Category struct {
    ID          string    `gorm:"primaryKey" json:"id"`
    Name        string    `gorm:"not null;size:100" json:"name"`
    Slug        string    `gorm:"not null;uniqueIndex;size:100" json:"slug"`
    Description string    `gorm:"size:500" json:"description"`
    Type        string    `gorm:"not null;size:50;index" json:"type"` // genre, country, language, decade, custom
    
    // å±‚çº§ç»“æ„
    ParentID    *string   `gorm:"index" json:"parent_id,omitempty"`
    Parent      *Category `gorm:"foreignKey:ParentID" json:"parent,omitempty"`
    Children    []Category `gorm:"foreignKey:ParentID" json:"children,omitempty"`
    Level       int       `gorm:"not null;default:0" json:"level"`
    Path        string    `gorm:"size:500" json:"path"` // å±‚çº§è·¯å¾„ï¼Œå¦‚ "/action/thriller"
    
    // æ˜¾ç¤ºå±æ€§
    Color       string    `gorm:"size:20" json:"color,omitempty"`
    Icon        string    `gorm:"size:100" json:"icon,omitempty"`
    ImageURL    string    `gorm:"size:500" json:"image_url,omitempty"`
    
    // æ’åºå’ŒçŠ¶æ€
    SortOrder   int       `gorm:"not null;default:0" json:"sort_order"`
    Status      string    `gorm:"not null;default:'active'" json:"status"` // active, inactive, archived
    
    // ç»Ÿè®¡ä¿¡æ¯
    MovieCount  int       `gorm:"not null;default:0" json:"movie_count"`
    ViewCount   int64     `gorm:"not null;default:0" json:"view_count"`
    
    // å…ƒæ•°æ®
    Metadata    JSON      `gorm:"type:json" json:"metadata,omitempty"`
    
    // æ—¶é—´æˆ³
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
    CreatedBy   string    `gorm:"size:50" json:"created_by,omitempty"`
    UpdatedBy   string    `gorm:"size:50" json:"updated_by,omitempty"`
}

// ç”µå½±åˆ†ç±»å…³è”
type MovieCategory struct {
    ID         string    `gorm:"primaryKey" json:"id"`
    MovieID    string    `gorm:"not null;index" json:"movie_id"`
    CategoryID string    `gorm:"not null;index" json:"category_id"`
    Movie      *Movie    `gorm:"foreignKey:MovieID" json:"movie,omitempty"`
    Category   *Category `gorm:"foreignKey:CategoryID" json:"category,omitempty"`
    
    // å…³è”å±æ€§
    Primary    bool      `gorm:"not null;default:false" json:"primary"` // æ˜¯å¦ä¸ºä¸»è¦åˆ†ç±»
    Weight     float64   `gorm:"not null;default:1.0" json:"weight"`    // å…³è”æƒé‡
    
    CreatedAt  time.Time `json:"created_at"`
    CreatedBy  string    `gorm:"size:50" json:"created_by,omitempty"`
}

// åˆ†ç±»è¯·æ±‚ç»“æ„
type CategoryRequest struct {
    Name        string            `json:"name" binding:"required,max=100"`
    Slug        string            `json:"slug" binding:"max=100"`
    Description string            `json:"description" binding:"max=500"`
    Type        string            `json:"type" binding:"required,oneof=genre country language decade custom"`
    ParentID    *string           `json:"parent_id"`
    Color       string            `json:"color" binding:"max=20"`
    Icon        string            `json:"icon" binding:"max=100"`
    ImageURL    string            `json:"image_url" binding:"max=500"`
    SortOrder   int               `json:"sort_order"`
    Status      string            `json:"status" binding:"oneof=active inactive archived"`
    Metadata    map[string]interface{} `json:"metadata"`
}

// åˆ†ç±»å“åº”ç»“æ„
type CategoryResponse struct {
    Success bool      `json:"success"`
    Message string    `json:"message,omitempty"`
    Data    *Category `json:"data,omitempty"`
}

// åˆ†ç±»åˆ—è¡¨å“åº”
type CategoryListResponse struct {
    Success    bool              `json:"success"`
    Message    string            `json:"message,omitempty"`
    Data       []Category        `json:"data,omitempty"`
    Pagination *PaginationInfo   `json:"pagination,omitempty"`
    Statistics *CategoryStats    `json:"statistics,omitempty"`
}

// åˆ†ç±»ç»Ÿè®¡
type CategoryStats struct {
    TotalCategories int                    `json:"total_categories"`
    TypeDistribution map[string]int        `json:"type_distribution"`
    StatusDistribution map[string]int      `json:"status_distribution"`
    TopCategories   []CategoryStatItem     `json:"top_categories"`
}

type CategoryStatItem struct {
    ID         string `json:"id"`
    Name       string `json:"name"`
    MovieCount int    `json:"movie_count"`
    ViewCount  int64  `json:"view_count"`
}
```

## ğŸ”§ åˆ†ç±»ç®¡ç†æœåŠ¡

### 1. **æ ¸å¿ƒåˆ†ç±»æœåŠ¡**

```go
type CategoryService struct {
    categoryRepo CategoryRepository
    movieRepo    MovieRepository
    cacheStore   CacheStore
    logger       *logrus.Logger
    metrics      *CategoryMetrics
}

func NewCategoryService(
    categoryRepo CategoryRepository,
    movieRepo MovieRepository,
    cacheStore CacheStore,
) *CategoryService {
    return &CategoryService{
        categoryRepo: categoryRepo,
        movieRepo:    movieRepo,
        cacheStore:   cacheStore,
        logger:       logrus.New(),
        metrics:      NewCategoryMetrics(),
    }
}

// åˆ›å»ºåˆ†ç±»
func (cs *CategoryService) CreateCategory(ctx context.Context, req *CategoryRequest, userID string) (*CategoryResponse, error) {
    start := time.Now()
    defer func() {
        cs.metrics.ObserveCategoryOperation("create", time.Since(start))
    }()

    // éªŒè¯è¯·æ±‚
    if err := cs.validateCategoryRequest(req); err != nil {
        cs.metrics.IncInvalidRequests("create")
        return &CategoryResponse{
            Success: false,
            Message: err.Error(),
        }, nil
    }

    // ç”ŸæˆSlugï¼ˆå¦‚æœæœªæä¾›ï¼‰
    if req.Slug == "" {
        req.Slug = cs.generateSlug(req.Name)
    }

    // æ£€æŸ¥Slugå”¯ä¸€æ€§
    if exists, err := cs.categoryRepo.ExistsBySlug(ctx, req.Slug); err != nil {
        cs.logger.Errorf("Failed to check slug existence: %v", err)
        return nil, errors.New("åˆ†ç±»åˆ›å»ºå¤±è´¥")
    } else if exists {
        return &CategoryResponse{
            Success: false,
            Message: "åˆ†ç±»æ ‡è¯†å·²å­˜åœ¨",
        }, nil
    }

    // å¤„ç†å±‚çº§å…³ç³»
    var level int
    var path string
    if req.ParentID != nil {
        parent, err := cs.categoryRepo.FindByID(ctx, *req.ParentID)
        if err != nil {
            return &CategoryResponse{
                Success: false,
                Message: "çˆ¶åˆ†ç±»ä¸å­˜åœ¨",
            }, nil
        }
        level = parent.Level + 1
        path = parent.Path + "/" + req.Slug
    } else {
        level = 0
        path = "/" + req.Slug
    }

    // åˆ›å»ºåˆ†ç±»å¯¹è±¡
    category := &Category{
        ID:          uuid.New().String(),
        Name:        req.Name,
        Slug:        req.Slug,
        Description: req.Description,
        Type:        req.Type,
        ParentID:    req.ParentID,
        Level:       level,
        Path:        path,
        Color:       req.Color,
        Icon:        req.Icon,
        ImageURL:    req.ImageURL,
        SortOrder:   req.SortOrder,
        Status:      req.Status,
        Metadata:    req.Metadata,
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
        CreatedBy:   userID,
        UpdatedBy:   userID,
    }

    // ä¿å­˜åˆ†ç±»
    if err := cs.categoryRepo.Create(ctx, category); err != nil {
        cs.logger.Errorf("Failed to create category: %v", err)
        cs.metrics.IncOperationErrors("create")
        return nil, errors.New("åˆ†ç±»åˆ›å»ºå¤±è´¥")
    }

    // æ¸…é™¤ç›¸å…³ç¼“å­˜
    cs.clearCategoryCache(ctx, req.Type)

    cs.metrics.IncSuccessfulOperations("create")
    cs.logger.Infof("Category created: %s (%s)", category.Name, category.ID)

    return &CategoryResponse{
        Success: true,
        Message: "åˆ†ç±»åˆ›å»ºæˆåŠŸ",
        Data:    category,
    }, nil
}

// è·å–åˆ†ç±»åˆ—è¡¨
func (cs *CategoryService) GetCategories(ctx context.Context, categoryType string, includeInactive bool) (*CategoryListResponse, error) {
    start := time.Now()
    defer func() {
        cs.metrics.ObserveCategoryOperation("list", time.Since(start))
    }()

    // ç”Ÿæˆç¼“å­˜é”®
    cacheKey := cs.generateListCacheKey(categoryType, includeInactive)

    // å°è¯•ä»ç¼“å­˜è·å–
    if cachedResult, err := cs.getListFromCache(ctx, cacheKey); err == nil {
        cs.metrics.IncCacheHits()
        return cachedResult, nil
    }
    cs.metrics.IncCacheMisses()

    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    conditions := make(map[string]interface{})
    if categoryType != "" {
        conditions["type"] = categoryType
    }
    if !includeInactive {
        conditions["status"] = "active"
    }

    // è·å–åˆ†ç±»åˆ—è¡¨
    categories, err := cs.categoryRepo.FindWithConditions(ctx, conditions)
    if err != nil {
        cs.logger.Errorf("Failed to get categories: %v", err)
        cs.metrics.IncOperationErrors("list")
        return nil, errors.New("è·å–åˆ†ç±»åˆ—è¡¨å¤±è´¥")
    }

    // æ„å»ºå±‚çº§ç»“æ„
    categoryTree := cs.buildCategoryTree(categories)

    // è·å–ç»Ÿè®¡ä¿¡æ¯
    stats, err := cs.getCategoryStatistics(ctx)
    if err != nil {
        cs.logger.Errorf("Failed to get category statistics: %v", err)
        // ç»Ÿè®¡ä¿¡æ¯è·å–å¤±è´¥ä¸å½±å“ä¸»è¦åŠŸèƒ½
    }

    response := &CategoryListResponse{
        Success:    true,
        Data:       categoryTree,
        Statistics: stats,
    }

    // å¼‚æ­¥ç¼“å­˜ç»“æœ
    go func() {
        if err := cs.cacheListResult(context.Background(), cacheKey, response); err != nil {
            cs.logger.Errorf("Failed to cache category list: %v", err)
        }
    }()

    cs.metrics.IncSuccessfulOperations("list")
    return response, nil
}

// æ›´æ–°åˆ†ç±»
func (cs *CategoryService) UpdateCategory(ctx context.Context, categoryID string, req *CategoryRequest, userID string) (*CategoryResponse, error) {
    start := time.Now()
    defer func() {
        cs.metrics.ObserveCategoryOperation("update", time.Since(start))
    }()

    // è·å–ç°æœ‰åˆ†ç±»
    category, err := cs.categoryRepo.FindByID(ctx, categoryID)
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return &CategoryResponse{
                Success: false,
                Message: "åˆ†ç±»ä¸å­˜åœ¨",
            }, nil
        }
        cs.logger.Errorf("Failed to get category: %v", err)
        return nil, errors.New("è·å–åˆ†ç±»å¤±è´¥")
    }

    // éªŒè¯è¯·æ±‚
    if err := cs.validateCategoryRequest(req); err != nil {
        cs.metrics.IncInvalidRequests("update")
        return &CategoryResponse{
            Success: false,
            Message: err.Error(),
        }, nil
    }

    // æ£€æŸ¥Slugå”¯ä¸€æ€§ï¼ˆå¦‚æœæœ‰å˜åŒ–ï¼‰
    if req.Slug != "" && req.Slug != category.Slug {
        if exists, err := cs.categoryRepo.ExistsBySlug(ctx, req.Slug); err != nil {
            cs.logger.Errorf("Failed to check slug existence: %v", err)
            return nil, errors.New("åˆ†ç±»æ›´æ–°å¤±è´¥")
        } else if exists {
            return &CategoryResponse{
                Success: false,
                Message: "åˆ†ç±»æ ‡è¯†å·²å­˜åœ¨",
            }, nil
        }
    }

    // æ›´æ–°åˆ†ç±»å­—æ®µ
    cs.updateCategoryFields(category, req)
    category.UpdatedAt = time.Now()
    category.UpdatedBy = userID

    // å¤„ç†å±‚çº§å…³ç³»å˜åŒ–
    if req.ParentID != nil && (category.ParentID == nil || *req.ParentID != *category.ParentID) {
        if err := cs.updateCategoryHierarchy(ctx, category, req.ParentID); err != nil {
            return &CategoryResponse{
                Success: false,
                Message: err.Error(),
            }, nil
        }
    }

    // ä¿å­˜æ›´æ–°
    if err := cs.categoryRepo.Update(ctx, category); err != nil {
        cs.logger.Errorf("Failed to update category: %v", err)
        cs.metrics.IncOperationErrors("update")
        return nil, errors.New("åˆ†ç±»æ›´æ–°å¤±è´¥")
    }

    // æ¸…é™¤ç›¸å…³ç¼“å­˜
    cs.clearCategoryCache(ctx, category.Type)

    cs.metrics.IncSuccessfulOperations("update")
    cs.logger.Infof("Category updated: %s (%s)", category.Name, category.ID)

    return &CategoryResponse{
        Success: true,
        Message: "åˆ†ç±»æ›´æ–°æˆåŠŸ",
        Data:    category,
    }, nil
}

// åˆ é™¤åˆ†ç±»
func (cs *CategoryService) DeleteCategory(ctx context.Context, categoryID string, userID string) (*CategoryResponse, error) {
    start := time.Now()
    defer func() {
        cs.metrics.ObserveCategoryOperation("delete", time.Since(start))
    }()

    // è·å–åˆ†ç±»
    category, err := cs.categoryRepo.FindByID(ctx, categoryID)
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return &CategoryResponse{
                Success: false,
                Message: "åˆ†ç±»ä¸å­˜åœ¨",
            }, nil
        }
        return nil, errors.New("è·å–åˆ†ç±»å¤±è´¥")
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰å­åˆ†ç±»
    hasChildren, err := cs.categoryRepo.HasChildren(ctx, categoryID)
    if err != nil {
        cs.logger.Errorf("Failed to check children: %v", err)
        return nil, errors.New("åˆ é™¤æ£€æŸ¥å¤±è´¥")
    }
    if hasChildren {
        return &CategoryResponse{
            Success: false,
            Message: "è¯¥åˆ†ç±»ä¸‹è¿˜æœ‰å­åˆ†ç±»ï¼Œæ— æ³•åˆ é™¤",
        }, nil
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰å…³è”ç”µå½±
    movieCount, err := cs.categoryRepo.GetMovieCount(ctx, categoryID)
    if err != nil {
        cs.logger.Errorf("Failed to get movie count: %v", err)
        return nil, errors.New("åˆ é™¤æ£€æŸ¥å¤±è´¥")
    }
    if movieCount > 0 {
        return &CategoryResponse{
            Success: false,
            Message: fmt.Sprintf("è¯¥åˆ†ç±»ä¸‹è¿˜æœ‰%déƒ¨ç”µå½±ï¼Œæ— æ³•åˆ é™¤", movieCount),
        }, nil
    }

    // æ‰§è¡Œåˆ é™¤
    if err := cs.categoryRepo.Delete(ctx, categoryID); err != nil {
        cs.logger.Errorf("Failed to delete category: %v", err)
        cs.metrics.IncOperationErrors("delete")
        return nil, errors.New("åˆ†ç±»åˆ é™¤å¤±è´¥")
    }

    // æ¸…é™¤ç›¸å…³ç¼“å­˜
    cs.clearCategoryCache(ctx, category.Type)

    cs.metrics.IncSuccessfulOperations("delete")
    cs.logger.Infof("Category deleted: %s (%s)", category.Name, category.ID)

    return &CategoryResponse{
        Success: true,
        Message: "åˆ†ç±»åˆ é™¤æˆåŠŸ",
    }, nil
}

// æ„å»ºåˆ†ç±»æ ‘
func (cs *CategoryService) buildCategoryTree(categories []Category) []Category {
    categoryMap := make(map[string]*Category)
    var rootCategories []Category

    // åˆ›å»ºåˆ†ç±»æ˜ å°„
    for i := range categories {
        categoryMap[categories[i].ID] = &categories[i]
        categories[i].Children = []Category{}
    }

    // æ„å»ºå±‚çº§å…³ç³»
    for i := range categories {
        if categories[i].ParentID == nil {
            rootCategories = append(rootCategories, categories[i])
        } else {
            if parent, exists := categoryMap[*categories[i].ParentID]; exists {
                parent.Children = append(parent.Children, categories[i])
            }
        }
    }

    // æ’åº
    cs.sortCategories(rootCategories)
    for _, category := range categoryMap {
        cs.sortCategories(category.Children)
    }

    return rootCategories
}

// æ’åºåˆ†ç±»
func (cs *CategoryService) sortCategories(categories []Category) {
    sort.Slice(categories, func(i, j int) bool {
        if categories[i].SortOrder != categories[j].SortOrder {
            return categories[i].SortOrder < categories[j].SortOrder
        }
        return categories[i].Name < categories[j].Name
    })
}
```

### 2. **åˆ†ç±»å…³è”ç®¡ç†**

```go
// ç”µå½±åˆ†ç±»å…³è”æœåŠ¡
type MovieCategoryService struct {
    movieCategoryRepo MovieCategoryRepository
    categoryRepo      CategoryRepository
    logger            *logrus.Logger
}

func NewMovieCategoryService(
    movieCategoryRepo MovieCategoryRepository,
    categoryRepo CategoryRepository,
) *MovieCategoryService {
    return &MovieCategoryService{
        movieCategoryRepo: movieCategoryRepo,
        categoryRepo:      categoryRepo,
        logger:            logrus.New(),
    }
}

// ä¸ºç”µå½±æ·»åŠ åˆ†ç±»
func (mcs *MovieCategoryService) AddMovieCategories(ctx context.Context, movieID string, categoryIDs []string, userID string) error {
    // éªŒè¯åˆ†ç±»å­˜åœ¨æ€§
    for _, categoryID := range categoryIDs {
        if exists, err := mcs.categoryRepo.ExistsByID(ctx, categoryID); err != nil {
            return err
        } else if !exists {
            return fmt.Errorf("åˆ†ç±» %s ä¸å­˜åœ¨", categoryID)
        }
    }

    // åˆ›å»ºå…³è”è®°å½•
    for i, categoryID := range categoryIDs {
        association := &MovieCategory{
            ID:         uuid.New().String(),
            MovieID:    movieID,
            CategoryID: categoryID,
            Primary:    i == 0, // ç¬¬ä¸€ä¸ªåˆ†ç±»ä¸ºä¸»è¦åˆ†ç±»
            Weight:     1.0,
            CreatedAt:  time.Now(),
            CreatedBy:  userID,
        }

        if err := mcs.movieCategoryRepo.Create(ctx, association); err != nil {
            mcs.logger.Errorf("Failed to create movie category association: %v", err)
            return err
        }
    }

    // æ›´æ–°åˆ†ç±»ç”µå½±è®¡æ•°
    go func() {
        for _, categoryID := range categoryIDs {
            mcs.updateCategoryMovieCount(context.Background(), categoryID)
        }
    }()

    return nil
}

// æ›´æ–°åˆ†ç±»ç”µå½±è®¡æ•°
func (mcs *MovieCategoryService) updateCategoryMovieCount(ctx context.Context, categoryID string) {
    count, err := mcs.movieCategoryRepo.CountMoviesByCategory(ctx, categoryID)
    if err != nil {
        mcs.logger.Errorf("Failed to count movies for category %s: %v", categoryID, err)
        return
    }

    if err := mcs.categoryRepo.UpdateMovieCount(ctx, categoryID, int(count)); err != nil {
        mcs.logger.Errorf("Failed to update movie count for category %s: %v", categoryID, err)
    }
}
```

## ğŸ“Š æ€§èƒ½ç›‘æ§

### 1. **åˆ†ç±»ç®¡ç†æŒ‡æ ‡**

```go
type CategoryMetrics struct {
    operationCount    *prometheus.CounterVec
    operationDuration *prometheus.HistogramVec
    cacheHitRate      *prometheus.CounterVec
    categoryCount     prometheus.Gauge
    errorCount        *prometheus.CounterVec
}

func NewCategoryMetrics() *CategoryMetrics {
    return &CategoryMetrics{
        operationCount: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "category_operations_total",
                Help: "Total number of category operations",
            },
            []string{"operation", "status"},
        ),
        operationDuration: prometheus.NewHistogramVec(
            prometheus.HistogramOpts{
                Name: "category_operation_duration_seconds",
                Help: "Duration of category operations",
            },
            []string{"operation"},
        ),
        cacheHitRate: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "category_cache_operations_total",
                Help: "Total number of category cache operations",
            },
            []string{"type"},
        ),
        categoryCount: prometheus.NewGauge(
            prometheus.GaugeOpts{
                Name: "categories_total",
                Help: "Total number of categories",
            },
        ),
        errorCount: prometheus.NewCounterVec(
            prometheus.CounterOpts{
                Name: "category_errors_total",
                Help: "Total number of category errors",
            },
            []string{"operation", "error_type"},
        ),
    }
}
```

## ğŸ”§ HTTPå¤„ç†å™¨

### 1. **åˆ†ç±»ç®¡ç†APIç«¯ç‚¹**

```go
func (cc *CategoryController) CreateCategory(c *gin.Context) {
    var req CategoryRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{
            "success": false,
            "message": "è¯·æ±‚å‚æ•°é”™è¯¯",
            "error":   err.Error(),
        })
        return
    }

    userID := cc.getUserIDFromContext(c)
    response, err := cc.categoryService.CreateCategory(c.Request.Context(), &req, userID)
    if err != nil {
        cc.logger.Errorf("Failed to create category: %v", err)
        c.JSON(500, gin.H{
            "success": false,
            "message": "åˆ†ç±»åˆ›å»ºå¤±è´¥",
        })
        return
    }

    c.JSON(200, response)
}

func (cc *CategoryController) GetCategories(c *gin.Context) {
    categoryType := c.Query("type")
    includeInactive := c.Query("include_inactive") == "true"

    response, err := cc.categoryService.GetCategories(c.Request.Context(), categoryType, includeInactive)
    if err != nil {
        cc.logger.Errorf("Failed to get categories: %v", err)
        c.JSON(500, gin.H{
            "success": false,
            "message": "è·å–åˆ†ç±»åˆ—è¡¨å¤±è´¥",
        })
        return
    }

    c.Header("Cache-Control", "public, max-age=1800") // 30åˆ†é’Ÿç¼“å­˜
    c.JSON(200, response)
}
```

## ğŸ“ æ€»ç»“

ç”µå½±åˆ†ç±»ç®¡ç†ä¸ºMovieInfoé¡¹ç›®æä¾›äº†å®Œæ•´çš„å†…å®¹ç»„ç»‡ä½“ç³»ï¼š

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
1. **å¤šç»´åˆ†ç±»**ï¼šç±»å‹ã€åœ°åŒºã€å¹´ä»£ç­‰å¤šç»´åº¦åˆ†ç±»æ”¯æŒ
2. **å±‚çº§ç®¡ç†**ï¼šæ”¯æŒåˆ†ç±»çš„å±‚çº§ç»“æ„å’Œå…³ç³»ç®¡ç†
3. **æ‰¹é‡æ“ä½œ**ï¼šé«˜æ•ˆçš„æ‰¹é‡åˆ†ç±»ç®¡ç†åŠŸèƒ½
4. **ç»Ÿè®¡åˆ†æ**ï¼šå®Œæ•´çš„åˆ†ç±»ä½¿ç”¨ç»Ÿè®¡å’Œåˆ†æ

**ç®¡ç†ç‰¹æ€§**ï¼š
- çµæ´»çš„åˆ†ç±»åˆ›å»ºå’Œç¼–è¾‘
- æ™ºèƒ½çš„å±‚çº§å…³ç³»ç»´æŠ¤
- å®Œå–„çš„æƒé™æ§åˆ¶æœºåˆ¶
- å®æ—¶çš„ç»Ÿè®¡ä¿¡æ¯æ›´æ–°

**æ€§èƒ½ä¼˜åŒ–**ï¼š
- å¤šå±‚ç¼“å­˜ç­–ç•¥
- æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
- å¼‚æ­¥ç»Ÿè®¡æ›´æ–°
- ç›‘æ§æŒ‡æ ‡æ”¶é›†

è‡³æ­¤ï¼Œç”µå½±æœåŠ¡çš„æ ¸å¿ƒåŠŸèƒ½å·²ç»å®Œæˆã€‚ä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬å°†ç»§ç»­å®Œæˆè¯„è®ºæœåŠ¡ã€ä¸»é¡µæœåŠ¡ç­‰å…¶ä»–æ¨¡å—çš„å¼€å‘æ–‡æ¡£ã€‚

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ  
**æœ€åæ›´æ–°**: 2025-07-22  
**ä¸‹ä¸€æ­¥**: [ç¬¬36æ­¥ï¼šè¯„è®ºæ•°æ®æ¨¡å‹](../08-comment-service/36-comment-model.md)
